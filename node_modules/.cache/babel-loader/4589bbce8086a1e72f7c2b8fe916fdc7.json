{"ast":null,"code":"/**\n * These objects store data about MathML nodes. This is the MathML equivalent\n * of the types in domTree.js. Since MathML handles its own rendering, and\n * since we're mainly using MathML to improve accessibility, we don't manage\n * any of the styling state that the plain DOM nodes do.\n *\n * The `toNode` and `toMarkup` functions work simlarly to how they do in\n * domTree.js, creating namespaced DOM nodes and HTML text markup respectively.\n */\nvar utils = require(\"./utils\");\n/**\n * This node represents a general purpose MathML node of any type. The\n * constructor requires the type of node to create (for example, `\"mo\"` or\n * `\"mspace\"`, corresponding to `<mo>` and `<mspace>` tags).\n */\n\n\nfunction MathNode(type, children) {\n  this.type = type;\n  this.attributes = {};\n  this.children = children || [];\n}\n/**\n * Sets an attribute on a MathML node. MathML depends on attributes to convey a\n * semantic content, so this is used heavily.\n */\n\n\nMathNode.prototype.setAttribute = function (name, value) {\n  this.attributes[name] = value;\n};\n/**\n * Converts the math node into a MathML-namespaced DOM element.\n */\n\n\nMathNode.prototype.toNode = function () {\n  var node = document.createElementNS(\"http://www.w3.org/1998/Math/MathML\", this.type);\n\n  for (var attr in this.attributes) {\n    if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n      node.setAttribute(attr, this.attributes[attr]);\n    }\n  }\n\n  for (var i = 0; i < this.children.length; i++) {\n    node.appendChild(this.children[i].toNode());\n  }\n\n  return node;\n};\n/**\n * Converts the math node into an HTML markup string.\n */\n\n\nMathNode.prototype.toMarkup = function () {\n  var markup = \"<\" + this.type; // Add the attributes\n\n  for (var attr in this.attributes) {\n    if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n      markup += \" \" + attr + \"=\\\"\";\n      markup += utils.escape(this.attributes[attr]);\n      markup += \"\\\"\";\n    }\n  }\n\n  markup += \">\";\n\n  for (var i = 0; i < this.children.length; i++) {\n    markup += this.children[i].toMarkup();\n  }\n\n  markup += \"</\" + this.type + \">\";\n  return markup;\n};\n/**\n * This node represents a piece of text.\n */\n\n\nfunction TextNode(text) {\n  this.text = text;\n}\n/**\n * Converts the text node into a DOM text node.\n */\n\n\nTextNode.prototype.toNode = function () {\n  return document.createTextNode(this.text);\n};\n/**\n * Converts the text node into HTML markup (which is just the text itself).\n */\n\n\nTextNode.prototype.toMarkup = function () {\n  return utils.escape(this.text);\n};\n\nmodule.exports = {\n  MathNode: MathNode,\n  TextNode: TextNode\n};","map":{"version":3,"sources":["/Users/justinf/perseus-configured/node_modules/katex/src/mathMLTree.js"],"names":["utils","require","MathNode","type","children","attributes","prototype","setAttribute","name","value","toNode","node","document","createElementNS","attr","Object","hasOwnProperty","call","i","length","appendChild","toMarkup","markup","escape","TextNode","text","createTextNode","module","exports"],"mappings":"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","sourcesContent":["/**\n * These objects store data about MathML nodes. This is the MathML equivalent\n * of the types in domTree.js. Since MathML handles its own rendering, and\n * since we're mainly using MathML to improve accessibility, we don't manage\n * any of the styling state that the plain DOM nodes do.\n *\n * The `toNode` and `toMarkup` functions work simlarly to how they do in\n * domTree.js, creating namespaced DOM nodes and HTML text markup respectively.\n */\n\nvar utils = require(\"./utils\");\n\n/**\n * This node represents a general purpose MathML node of any type. The\n * constructor requires the type of node to create (for example, `\"mo\"` or\n * `\"mspace\"`, corresponding to `<mo>` and `<mspace>` tags).\n */\nfunction MathNode(type, children) {\n    this.type = type;\n    this.attributes = {};\n    this.children = children || [];\n}\n\n/**\n * Sets an attribute on a MathML node. MathML depends on attributes to convey a\n * semantic content, so this is used heavily.\n */\nMathNode.prototype.setAttribute = function(name, value) {\n    this.attributes[name] = value;\n};\n\n/**\n * Converts the math node into a MathML-namespaced DOM element.\n */\nMathNode.prototype.toNode = function() {\n    var node = document.createElementNS(\n        \"http://www.w3.org/1998/Math/MathML\", this.type);\n\n    for (var attr in this.attributes) {\n        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n            node.setAttribute(attr, this.attributes[attr]);\n        }\n    }\n\n    for (var i = 0; i < this.children.length; i++) {\n        node.appendChild(this.children[i].toNode());\n    }\n\n    return node;\n};\n\n/**\n * Converts the math node into an HTML markup string.\n */\nMathNode.prototype.toMarkup = function() {\n    var markup = \"<\" + this.type;\n\n    // Add the attributes\n    for (var attr in this.attributes) {\n        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n            markup += \" \" + attr + \"=\\\"\";\n            markup += utils.escape(this.attributes[attr]);\n            markup += \"\\\"\";\n        }\n    }\n\n    markup += \">\";\n\n    for (var i = 0; i < this.children.length; i++) {\n        markup += this.children[i].toMarkup();\n    }\n\n    markup += \"</\" + this.type + \">\";\n\n    return markup;\n};\n\n/**\n * This node represents a piece of text.\n */\nfunction TextNode(text) {\n    this.text = text;\n}\n\n/**\n * Converts the text node into a DOM text node.\n */\nTextNode.prototype.toNode = function() {\n    return document.createTextNode(this.text);\n};\n\n/**\n * Converts the text node into HTML markup (which is just the text itself).\n */\nTextNode.prototype.toMarkup = function() {\n    return utils.escape(this.text);\n};\n\nmodule.exports = {\n    MathNode: MathNode,\n    TextNode: TextNode\n};\n"]},"metadata":{},"sourceType":"script"}