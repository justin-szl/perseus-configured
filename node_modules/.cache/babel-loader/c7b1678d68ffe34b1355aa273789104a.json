{"ast":null,"code":"/* eslint no-constant-condition:0 */\nvar functions = require(\"./functions\");\n\nvar environments = require(\"./environments\");\n\nvar MacroExpander = require(\"./MacroExpander\");\n\nvar symbols = require(\"./symbols\");\n\nvar utils = require(\"./utils\");\n\nvar cjkRegex = require(\"./unicodeRegexes\").cjkRegex;\n\nvar parseData = require(\"./parseData\");\n\nvar ParseError = require(\"./ParseError\");\n/**\n * This file contains the parser used to parse out a TeX expression from the\n * input. Since TeX isn't context-free, standard parsers don't work particularly\n * well.\n *\n * The strategy of this parser is as such:\n *\n * The main functions (the `.parse...` ones) take a position in the current\n * parse string to parse tokens from. The lexer (found in Lexer.js, stored at\n * this.lexer) also supports pulling out tokens at arbitrary places. When\n * individual tokens are needed at a position, the lexer is called to pull out a\n * token, which is then used.\n *\n * The parser has a property called \"mode\" indicating the mode that\n * the parser is currently in. Currently it has to be one of \"math\" or\n * \"text\", which denotes whether the current environment is a math-y\n * one or a text-y one (e.g. inside \\text). Currently, this serves to\n * limit the functions which can be used in text mode.\n *\n * The main functions then return an object which contains the useful data that\n * was parsed at its given point, and a new position at the end of the parsed\n * data. The main functions can call each other and continue the parsing by\n * using the returned position as a new starting point.\n *\n * There are also extra `.handle...` functions, which pull out some reused\n * functionality into self-contained functions.\n *\n * The earlier functions return ParseNodes.\n * The later functions (which are called deeper in the parse) sometimes return\n * ParseFuncOrArgument, which contain a ParseNode as well as some data about\n * whether the parsed object is a function which is missing some arguments, or a\n * standalone object which can be used as an argument to another function.\n */\n\n/**\n * Main Parser class\n */\n\n\nfunction Parser(input, settings) {\n  // Create a new macro expander (gullet) and (indirectly via that) also a\n  // new lexer (mouth) for this parser (stomach, in the language of TeX)\n  this.gullet = new MacroExpander(input, settings.macros); // Store the settings for use in parsing\n\n  this.settings = settings; // Count leftright depth (for \\middle errors)\n\n  this.leftrightDepth = 0;\n}\n\nvar ParseNode = parseData.ParseNode;\n/**\n * An initial function (without its arguments), or an argument to a function.\n * The `result` argument should be a ParseNode.\n */\n\nfunction ParseFuncOrArgument(result, isFunction, token) {\n  this.result = result; // Is this a function (i.e. is it something defined in functions.js)?\n\n  this.isFunction = isFunction;\n  this.token = token;\n}\n/**\n * Checks a result to make sure it has the right type, and throws an\n * appropriate error otherwise.\n *\n * @param {boolean=} consume whether to consume the expected token,\n *                           defaults to true\n */\n\n\nParser.prototype.expect = function (text, consume) {\n  if (this.nextToken.text !== text) {\n    throw new ParseError(\"Expected '\" + text + \"', got '\" + this.nextToken.text + \"'\", this.nextToken);\n  }\n\n  if (consume !== false) {\n    this.consume();\n  }\n};\n/**\n * Considers the current look ahead token as consumed,\n * and fetches the one after that as the new look ahead.\n */\n\n\nParser.prototype.consume = function () {\n  this.nextToken = this.gullet.get(this.mode === \"math\");\n};\n\nParser.prototype.switchMode = function (newMode) {\n  this.gullet.unget(this.nextToken);\n  this.mode = newMode;\n  this.consume();\n};\n/**\n * Main parsing function, which parses an entire input.\n *\n * @return {?Array.<ParseNode>}\n */\n\n\nParser.prototype.parse = function () {\n  // Try to parse the input\n  this.mode = \"math\";\n  this.consume();\n  var parse = this.parseInput();\n  return parse;\n};\n/**\n * Parses an entire input tree.\n */\n\n\nParser.prototype.parseInput = function () {\n  // Parse an expression\n  var expression = this.parseExpression(false); // If we succeeded, make sure there's an EOF at the end\n\n  this.expect(\"EOF\", false);\n  return expression;\n};\n\nvar endOfExpression = [\"}\", \"\\\\end\", \"\\\\right\", \"&\", \"\\\\\\\\\", \"\\\\cr\"];\n/**\n * Parses an \"expression\", which is a list of atoms.\n *\n * @param {boolean} breakOnInfix  Should the parsing stop when we hit infix\n *                  nodes? This happens when functions have higher precendence\n *                  than infix nodes in implicit parses.\n *\n * @param {?string} breakOnTokenText  The text of the token that the expression\n *                  should end with, or `null` if something else should end the\n *                  expression.\n *\n * @return {ParseNode}\n */\n\nParser.prototype.parseExpression = function (breakOnInfix, breakOnTokenText) {\n  var body = []; // Keep adding atoms to the body until we can't parse any more atoms (either\n  // we reached the end, a }, or a \\right)\n\n  while (true) {\n    var lex = this.nextToken;\n\n    if (endOfExpression.indexOf(lex.text) !== -1) {\n      break;\n    }\n\n    if (breakOnTokenText && lex.text === breakOnTokenText) {\n      break;\n    }\n\n    if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {\n      break;\n    }\n\n    var atom = this.parseAtom();\n\n    if (!atom) {\n      if (!this.settings.throwOnError && lex.text[0] === \"\\\\\") {\n        var errorNode = this.handleUnsupportedCmd();\n        body.push(errorNode);\n        continue;\n      }\n\n      break;\n    }\n\n    body.push(atom);\n  }\n\n  return this.handleInfixNodes(body);\n};\n/**\n * Rewrites infix operators such as \\over with corresponding commands such\n * as \\frac.\n *\n * There can only be one infix operator per group.  If there's more than one\n * then the expression is ambiguous.  This can be resolved by adding {}.\n *\n * @returns {Array}\n */\n\n\nParser.prototype.handleInfixNodes = function (body) {\n  var overIndex = -1;\n  var funcName;\n\n  for (var i = 0; i < body.length; i++) {\n    var node = body[i];\n\n    if (node.type === \"infix\") {\n      if (overIndex !== -1) {\n        throw new ParseError(\"only one infix operator per group\", node.value.token);\n      }\n\n      overIndex = i;\n      funcName = node.value.replaceWith;\n    }\n  }\n\n  if (overIndex !== -1) {\n    var numerNode;\n    var denomNode;\n    var numerBody = body.slice(0, overIndex);\n    var denomBody = body.slice(overIndex + 1);\n\n    if (numerBody.length === 1 && numerBody[0].type === \"ordgroup\") {\n      numerNode = numerBody[0];\n    } else {\n      numerNode = new ParseNode(\"ordgroup\", numerBody, this.mode);\n    }\n\n    if (denomBody.length === 1 && denomBody[0].type === \"ordgroup\") {\n      denomNode = denomBody[0];\n    } else {\n      denomNode = new ParseNode(\"ordgroup\", denomBody, this.mode);\n    }\n\n    var value = this.callFunction(funcName, [numerNode, denomNode], null);\n    return [new ParseNode(value.type, value, this.mode)];\n  } else {\n    return body;\n  }\n}; // The greediness of a superscript or subscript\n\n\nvar SUPSUB_GREEDINESS = 1;\n/**\n * Handle a subscript or superscript with nice errors.\n */\n\nParser.prototype.handleSupSubscript = function (name) {\n  var symbolToken = this.nextToken;\n  var symbol = symbolToken.text;\n  this.consume();\n  var group = this.parseGroup();\n\n  if (!group) {\n    if (!this.settings.throwOnError && this.nextToken.text[0] === \"\\\\\") {\n      return this.handleUnsupportedCmd();\n    } else {\n      throw new ParseError(\"Expected group after '\" + symbol + \"'\", symbolToken);\n    }\n  } else if (group.isFunction) {\n    // ^ and _ have a greediness, so handle interactions with functions'\n    // greediness\n    var funcGreediness = functions[group.result].greediness;\n\n    if (funcGreediness > SUPSUB_GREEDINESS) {\n      return this.parseFunction(group);\n    } else {\n      throw new ParseError(\"Got function '\" + group.result + \"' with no arguments \" + \"as \" + name, symbolToken);\n    }\n  } else {\n    return group.result;\n  }\n};\n/**\n * Converts the textual input of an unsupported command into a text node\n * contained within a color node whose color is determined by errorColor\n */\n\n\nParser.prototype.handleUnsupportedCmd = function () {\n  var text = this.nextToken.text;\n  var textordArray = [];\n\n  for (var i = 0; i < text.length; i++) {\n    textordArray.push(new ParseNode(\"textord\", text[i], \"text\"));\n  }\n\n  var textNode = new ParseNode(\"text\", {\n    body: textordArray,\n    type: \"text\"\n  }, this.mode);\n  var colorNode = new ParseNode(\"color\", {\n    color: this.settings.errorColor,\n    value: [textNode],\n    type: \"color\"\n  }, this.mode);\n  this.consume();\n  return colorNode;\n};\n/**\n * Parses a group with optional super/subscripts.\n *\n * @return {?ParseNode}\n */\n\n\nParser.prototype.parseAtom = function () {\n  // The body of an atom is an implicit group, so that things like\n  // \\left(x\\right)^2 work correctly.\n  var base = this.parseImplicitGroup(); // In text mode, we don't have superscripts or subscripts\n\n  if (this.mode === \"text\") {\n    return base;\n  } // Note that base may be empty (i.e. null) at this point.\n\n\n  var superscript;\n  var subscript;\n\n  while (true) {\n    // Lex the first token\n    var lex = this.nextToken;\n\n    if (lex.text === \"\\\\limits\" || lex.text === \"\\\\nolimits\") {\n      // We got a limit control\n      if (!base || base.type !== \"op\") {\n        throw new ParseError(\"Limit controls must follow a math operator\", lex);\n      } else {\n        var limits = lex.text === \"\\\\limits\";\n        base.value.limits = limits;\n        base.value.alwaysHandleSupSub = true;\n      }\n\n      this.consume();\n    } else if (lex.text === \"^\") {\n      // We got a superscript start\n      if (superscript) {\n        throw new ParseError(\"Double superscript\", lex);\n      }\n\n      superscript = this.handleSupSubscript(\"superscript\");\n    } else if (lex.text === \"_\") {\n      // We got a subscript start\n      if (subscript) {\n        throw new ParseError(\"Double subscript\", lex);\n      }\n\n      subscript = this.handleSupSubscript(\"subscript\");\n    } else if (lex.text === \"'\") {\n      // We got a prime\n      var prime = new ParseNode(\"textord\", \"\\\\prime\", this.mode); // Many primes can be grouped together, so we handle this here\n\n      var primes = [prime];\n      this.consume(); // Keep lexing tokens until we get something that's not a prime\n\n      while (this.nextToken.text === \"'\") {\n        // For each one, add another prime to the list\n        primes.push(prime);\n        this.consume();\n      } // Put them into an ordgroup as the superscript\n\n\n      superscript = new ParseNode(\"ordgroup\", primes, this.mode);\n    } else {\n      // If it wasn't ^, _, or ', stop parsing super/subscripts\n      break;\n    }\n  }\n\n  if (superscript || subscript) {\n    // If we got either a superscript or subscript, create a supsub\n    return new ParseNode(\"supsub\", {\n      base: base,\n      sup: superscript,\n      sub: subscript\n    }, this.mode);\n  } else {\n    // Otherwise return the original body\n    return base;\n  }\n}; // A list of the size-changing functions, for use in parseImplicitGroup\n\n\nvar sizeFuncs = [\"\\\\tiny\", \"\\\\scriptsize\", \"\\\\footnotesize\", \"\\\\small\", \"\\\\normalsize\", \"\\\\large\", \"\\\\Large\", \"\\\\LARGE\", \"\\\\huge\", \"\\\\Huge\"]; // A list of the style-changing functions, for use in parseImplicitGroup\n\nvar styleFuncs = [\"\\\\displaystyle\", \"\\\\textstyle\", \"\\\\scriptstyle\", \"\\\\scriptscriptstyle\"];\n/**\n * Parses an implicit group, which is a group that starts at the end of a\n * specified, and ends right before a higher explicit group ends, or at EOL. It\n * is used for functions that appear to affect the current style, like \\Large or\n * \\textrm, where instead of keeping a style we just pretend that there is an\n * implicit grouping after it until the end of the group. E.g.\n *   small text {\\Large large text} small text again\n * It is also used for \\left and \\right to get the correct grouping.\n *\n * @return {?ParseNode}\n */\n\nParser.prototype.parseImplicitGroup = function () {\n  var start = this.parseSymbol();\n\n  if (start == null) {\n    // If we didn't get anything we handle, fall back to parseFunction\n    return this.parseFunction();\n  }\n\n  var func = start.result;\n  var body;\n\n  if (func === \"\\\\left\") {\n    // If we see a left:\n    // Parse the entire left function (including the delimiter)\n    var left = this.parseFunction(start); // Parse out the implicit body\n\n    ++this.leftrightDepth;\n    body = this.parseExpression(false);\n    --this.leftrightDepth; // Check the next token\n\n    this.expect(\"\\\\right\", false);\n    var right = this.parseFunction();\n    return new ParseNode(\"leftright\", {\n      body: body,\n      left: left.value.value,\n      right: right.value.value\n    }, this.mode);\n  } else if (func === \"\\\\begin\") {\n    // begin...end is similar to left...right\n    var begin = this.parseFunction(start);\n    var envName = begin.value.name;\n\n    if (!environments.hasOwnProperty(envName)) {\n      throw new ParseError(\"No such environment: \" + envName, begin.value.nameGroup);\n    } // Build the environment object. Arguments and other information will\n    // be made available to the begin and end methods using properties.\n\n\n    var env = environments[envName];\n    var args = this.parseArguments(\"\\\\begin{\" + envName + \"}\", env);\n    var context = {\n      mode: this.mode,\n      envName: envName,\n      parser: this,\n      positions: args.pop()\n    };\n    var result = env.handler(context, args);\n    this.expect(\"\\\\end\", false);\n    var endNameToken = this.nextToken;\n    var end = this.parseFunction();\n\n    if (end.value.name !== envName) {\n      throw new ParseError(\"Mismatch: \\\\begin{\" + envName + \"} matched \" + \"by \\\\end{\" + end.value.name + \"}\", endNameToken);\n    }\n\n    result.position = end.position;\n    return result;\n  } else if (utils.contains(sizeFuncs, func)) {\n    // If we see a sizing function, parse out the implict body\n    body = this.parseExpression(false);\n    return new ParseNode(\"sizing\", {\n      // Figure out what size to use based on the list of functions above\n      size: \"size\" + (utils.indexOf(sizeFuncs, func) + 1),\n      value: body\n    }, this.mode);\n  } else if (utils.contains(styleFuncs, func)) {\n    // If we see a styling function, parse out the implict body\n    body = this.parseExpression(true);\n    return new ParseNode(\"styling\", {\n      // Figure out what style to use by pulling out the style from\n      // the function name\n      style: func.slice(1, func.length - 5),\n      value: body\n    }, this.mode);\n  } else {\n    // Defer to parseFunction if it's not a function we handle\n    return this.parseFunction(start);\n  }\n};\n/**\n * Parses an entire function, including its base and all of its arguments.\n * The base might either have been parsed already, in which case\n * it is provided as an argument, or it's the next group in the input.\n *\n * @param {ParseFuncOrArgument=} baseGroup optional as described above\n * @return {?ParseNode}\n */\n\n\nParser.prototype.parseFunction = function (baseGroup) {\n  if (!baseGroup) {\n    baseGroup = this.parseGroup();\n  }\n\n  if (baseGroup) {\n    if (baseGroup.isFunction) {\n      var func = baseGroup.result;\n      var funcData = functions[func];\n\n      if (this.mode === \"text\" && !funcData.allowedInText) {\n        throw new ParseError(\"Can't use function '\" + func + \"' in text mode\", baseGroup.token);\n      }\n\n      var args = this.parseArguments(func, funcData);\n      var token = baseGroup.token;\n      var result = this.callFunction(func, args, args.pop(), token);\n      return new ParseNode(result.type, result, this.mode);\n    } else {\n      return baseGroup.result;\n    }\n  } else {\n    return null;\n  }\n};\n/**\n * Call a function handler with a suitable context and arguments.\n */\n\n\nParser.prototype.callFunction = function (name, args, positions, token) {\n  var context = {\n    funcName: name,\n    parser: this,\n    positions: positions,\n    token: token\n  };\n  return functions[name].handler(context, args);\n};\n/**\n * Parses the arguments of a function or environment\n *\n * @param {string} func  \"\\name\" or \"\\begin{name}\"\n * @param {{numArgs:number,numOptionalArgs:number|undefined}} funcData\n * @return the array of arguments, with the list of positions as last element\n */\n\n\nParser.prototype.parseArguments = function (func, funcData) {\n  var totalArgs = funcData.numArgs + funcData.numOptionalArgs;\n\n  if (totalArgs === 0) {\n    return [[this.pos]];\n  }\n\n  var baseGreediness = funcData.greediness;\n  var positions = [this.pos];\n  var args = [];\n\n  for (var i = 0; i < totalArgs; i++) {\n    var nextToken = this.nextToken;\n    var argType = funcData.argTypes && funcData.argTypes[i];\n    var arg;\n\n    if (i < funcData.numOptionalArgs) {\n      if (argType) {\n        arg = this.parseGroupOfType(argType, true);\n      } else {\n        arg = this.parseGroup(true);\n      }\n\n      if (!arg) {\n        args.push(null);\n        positions.push(this.pos);\n        continue;\n      }\n    } else {\n      if (argType) {\n        arg = this.parseGroupOfType(argType);\n      } else {\n        arg = this.parseGroup();\n      }\n\n      if (!arg) {\n        if (!this.settings.throwOnError && this.nextToken.text[0] === \"\\\\\") {\n          arg = new ParseFuncOrArgument(this.handleUnsupportedCmd(this.nextToken.text), false);\n        } else {\n          throw new ParseError(\"Expected group after '\" + func + \"'\", nextToken);\n        }\n      }\n    }\n\n    var argNode;\n\n    if (arg.isFunction) {\n      var argGreediness = functions[arg.result].greediness;\n\n      if (argGreediness > baseGreediness) {\n        argNode = this.parseFunction(arg);\n      } else {\n        throw new ParseError(\"Got function '\" + arg.result + \"' as \" + \"argument to '\" + func + \"'\", nextToken);\n      }\n    } else {\n      argNode = arg.result;\n    }\n\n    args.push(argNode);\n    positions.push(this.pos);\n  }\n\n  args.push(positions);\n  return args;\n};\n/**\n * Parses a group when the mode is changing.\n *\n * @return {?ParseFuncOrArgument}\n */\n\n\nParser.prototype.parseGroupOfType = function (innerMode, optional) {\n  var outerMode = this.mode; // Handle `original` argTypes\n\n  if (innerMode === \"original\") {\n    innerMode = outerMode;\n  }\n\n  if (innerMode === \"color\") {\n    return this.parseColorGroup(optional);\n  }\n\n  if (innerMode === \"size\") {\n    return this.parseSizeGroup(optional);\n  }\n\n  this.switchMode(innerMode);\n\n  if (innerMode === \"text\") {\n    // text mode is special because it should ignore the whitespace before\n    // it\n    while (this.nextToken.text === \" \") {\n      this.consume();\n    }\n  } // By the time we get here, innerMode is one of \"text\" or \"math\".\n  // We switch the mode of the parser, recurse, then restore the old mode.\n\n\n  var res = this.parseGroup(optional);\n  this.switchMode(outerMode);\n  return res;\n};\n/**\n * Parses a group, essentially returning the string formed by the\n * brace-enclosed tokens plus some position information.\n *\n * @param {string} modeName  Used to describe the mode in error messages\n * @param {boolean=} optional  Whether the group is optional or required\n */\n\n\nParser.prototype.parseStringGroup = function (modeName, optional) {\n  if (optional && this.nextToken.text !== \"[\") {\n    return null;\n  }\n\n  var outerMode = this.mode;\n  this.mode = \"text\";\n  this.expect(optional ? \"[\" : \"{\");\n  var str = \"\";\n  var firstToken = this.nextToken;\n  var lastToken = firstToken;\n\n  while (this.nextToken.text !== (optional ? \"]\" : \"}\")) {\n    if (this.nextToken.text === \"EOF\") {\n      throw new ParseError(\"Unexpected end of input in \" + modeName, firstToken.range(this.nextToken, str));\n    }\n\n    lastToken = this.nextToken;\n    str += lastToken.text;\n    this.consume();\n  }\n\n  this.mode = outerMode;\n  this.expect(optional ? \"]\" : \"}\");\n  return firstToken.range(lastToken, str);\n};\n/**\n * Parses a regex-delimited group: the largest sequence of tokens\n * whose concatenated strings match `regex`. Returns the string\n * formed by the tokens plus some position information.\n *\n * @param {RegExp} regex\n * @param {string} modeName  Used to describe the mode in error messages\n */\n\n\nParser.prototype.parseRegexGroup = function (regex, modeName) {\n  var outerMode = this.mode;\n  this.mode = \"text\";\n  var firstToken = this.nextToken;\n  var lastToken = firstToken;\n  var str = \"\";\n\n  while (this.nextToken.text !== \"EOF\" && regex.test(str + this.nextToken.text)) {\n    lastToken = this.nextToken;\n    str += lastToken.text;\n    this.consume();\n  }\n\n  if (str === \"\") {\n    throw new ParseError(\"Invalid \" + modeName + \": '\" + firstToken.text + \"'\", firstToken);\n  }\n\n  this.mode = outerMode;\n  return firstToken.range(lastToken, str);\n};\n/**\n * Parses a color description.\n */\n\n\nParser.prototype.parseColorGroup = function (optional) {\n  var res = this.parseStringGroup(\"color\", optional);\n\n  if (!res) {\n    return null;\n  }\n\n  var match = /^(#[a-z0-9]+|[a-z]+)$/i.exec(res.text);\n\n  if (!match) {\n    throw new ParseError(\"Invalid color: '\" + res.text + \"'\", res);\n  }\n\n  return new ParseFuncOrArgument(new ParseNode(\"color\", match[0], this.mode), false);\n};\n/**\n * Parses a size specification, consisting of magnitude and unit.\n */\n\n\nParser.prototype.parseSizeGroup = function (optional) {\n  var res;\n\n  if (!optional && this.nextToken.text !== \"{\") {\n    res = this.parseRegexGroup(/^[-+]? *(?:$|\\d+|\\d+\\.\\d*|\\.\\d*) *[a-z]{0,2}$/, \"size\");\n  } else {\n    res = this.parseStringGroup(\"size\", optional);\n  }\n\n  if (!res) {\n    return null;\n  }\n\n  var match = /([-+]?) *(\\d+(?:\\.\\d*)?|\\.\\d+) *([a-z]{2})/.exec(res.text);\n\n  if (!match) {\n    throw new ParseError(\"Invalid size: '\" + res.text + \"'\", res);\n  }\n\n  var data = {\n    number: +(match[1] + match[2]),\n    // sign + magnitude, cast to number\n    unit: match[3]\n  };\n\n  if (data.unit !== \"em\" && data.unit !== \"ex\" && data.unit !== \"mu\") {\n    throw new ParseError(\"Invalid unit: '\" + data.unit + \"'\", res);\n  }\n\n  return new ParseFuncOrArgument(new ParseNode(\"color\", data, this.mode), false);\n};\n/**\n * If the argument is false or absent, this parses an ordinary group,\n * which is either a single nucleus (like \"x\") or an expression\n * in braces (like \"{x+y}\").\n * If the argument is true, it parses either a bracket-delimited expression\n * (like \"[x+y]\") or returns null to indicate the absence of a\n * bracket-enclosed group.\n *\n * @param {boolean=} optional  Whether the group is optional or required\n * @return {?ParseFuncOrArgument}\n */\n\n\nParser.prototype.parseGroup = function (optional) {\n  var firstToken = this.nextToken; // Try to parse an open brace\n\n  if (this.nextToken.text === (optional ? \"[\" : \"{\")) {\n    // If we get a brace, parse an expression\n    this.consume();\n    var expression = this.parseExpression(false, optional ? \"]\" : null);\n    var lastToken = this.nextToken; // Make sure we get a close brace\n\n    this.expect(optional ? \"]\" : \"}\");\n\n    if (this.mode === \"text\") {\n      this.formLigatures(expression);\n    }\n\n    return new ParseFuncOrArgument(new ParseNode(\"ordgroup\", expression, this.mode, firstToken, lastToken), false);\n  } else {\n    // Otherwise, just return a nucleus, or nothing for an optional group\n    return optional ? null : this.parseSymbol();\n  }\n};\n/**\n * Form ligature-like combinations of characters for text mode.\n * This includes inputs like \"--\", \"---\", \"``\" and \"''\".\n * The result will simply replace multiple textord nodes with a single\n * character in each value by a single textord node having multiple\n * characters in its value.  The representation is still ASCII source.\n *\n * @param {Array.<ParseNode>} group  the nodes of this group,\n *                                   list will be moified in place\n */\n\n\nParser.prototype.formLigatures = function (group) {\n  var i;\n  var n = group.length - 1;\n\n  for (i = 0; i < n; ++i) {\n    var a = group[i];\n    var v = a.value;\n\n    if (v === \"-\" && group[i + 1].value === \"-\") {\n      if (i + 1 < n && group[i + 2].value === \"-\") {\n        group.splice(i, 3, new ParseNode(\"textord\", \"---\", \"text\", a, group[i + 2]));\n        n -= 2;\n      } else {\n        group.splice(i, 2, new ParseNode(\"textord\", \"--\", \"text\", a, group[i + 1]));\n        n -= 1;\n      }\n    }\n\n    if ((v === \"'\" || v === \"`\") && group[i + 1].value === v) {\n      group.splice(i, 2, new ParseNode(\"textord\", v + v, \"text\", a, group[i + 1]));\n      n -= 1;\n    }\n  }\n};\n/**\n * Parse a single symbol out of the string. Here, we handle both the functions\n * we have defined, as well as the single character symbols\n *\n * @return {?ParseFuncOrArgument}\n */\n\n\nParser.prototype.parseSymbol = function () {\n  var nucleus = this.nextToken;\n\n  if (functions[nucleus.text]) {\n    this.consume(); // If there exists a function with this name, we return the function and\n    // say that it is a function.\n\n    return new ParseFuncOrArgument(nucleus.text, true, nucleus);\n  } else if (symbols[this.mode][nucleus.text]) {\n    this.consume(); // Otherwise if this is a no-argument function, find the type it\n    // corresponds to in the symbols map\n\n    return new ParseFuncOrArgument(new ParseNode(symbols[this.mode][nucleus.text].group, nucleus.text, this.mode, nucleus), false, nucleus);\n  } else if (this.mode === \"text\" && cjkRegex.test(nucleus.text)) {\n    this.consume();\n    return new ParseFuncOrArgument(new ParseNode(\"textord\", nucleus.text, this.mode, nucleus), false, nucleus);\n  } else {\n    return null;\n  }\n};\n\nParser.prototype.ParseNode = ParseNode;\nmodule.exports = Parser;","map":{"version":3,"sources":["/Users/justinf/perseus-configured/node_modules/katex/src/Parser.js"],"names":["functions","require","environments","MacroExpander","symbols","utils","cjkRegex","parseData","ParseError","Parser","input","settings","gullet","macros","leftrightDepth","ParseNode","ParseFuncOrArgument","result","isFunction","token","prototype","expect","text","consume","nextToken","get","mode","switchMode","newMode","unget","parse","parseInput","expression","parseExpression","endOfExpression","breakOnInfix","breakOnTokenText","body","lex","indexOf","infix","atom","parseAtom","throwOnError","errorNode","handleUnsupportedCmd","push","handleInfixNodes","overIndex","funcName","i","length","node","type","value","replaceWith","numerNode","denomNode","numerBody","slice","denomBody","callFunction","SUPSUB_GREEDINESS","handleSupSubscript","name","symbolToken","symbol","group","parseGroup","funcGreediness","greediness","parseFunction","textordArray","textNode","colorNode","color","errorColor","base","parseImplicitGroup","superscript","subscript","limits","alwaysHandleSupSub","prime","primes","sup","sub","sizeFuncs","styleFuncs","start","parseSymbol","func","left","right","begin","envName","hasOwnProperty","nameGroup","env","args","parseArguments","context","parser","positions","pop","handler","endNameToken","end","position","contains","size","style","baseGroup","funcData","allowedInText","totalArgs","numArgs","numOptionalArgs","pos","baseGreediness","argType","argTypes","arg","parseGroupOfType","argNode","argGreediness","innerMode","optional","outerMode","parseColorGroup","parseSizeGroup","res","parseStringGroup","modeName","str","firstToken","lastToken","range","parseRegexGroup","regex","test","match","exec","data","number","unit","formLigatures","n","a","v","splice","nucleus","module","exports"],"mappings":"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","sourcesContent":["/* eslint no-constant-condition:0 */\nvar functions = require(\"./functions\");\nvar environments = require(\"./environments\");\nvar MacroExpander = require(\"./MacroExpander\");\nvar symbols = require(\"./symbols\");\nvar utils = require(\"./utils\");\nvar cjkRegex = require(\"./unicodeRegexes\").cjkRegex;\n\nvar parseData = require(\"./parseData\");\nvar ParseError = require(\"./ParseError\");\n\n/**\n * This file contains the parser used to parse out a TeX expression from the\n * input. Since TeX isn't context-free, standard parsers don't work particularly\n * well.\n *\n * The strategy of this parser is as such:\n *\n * The main functions (the `.parse...` ones) take a position in the current\n * parse string to parse tokens from. The lexer (found in Lexer.js, stored at\n * this.lexer) also supports pulling out tokens at arbitrary places. When\n * individual tokens are needed at a position, the lexer is called to pull out a\n * token, which is then used.\n *\n * The parser has a property called \"mode\" indicating the mode that\n * the parser is currently in. Currently it has to be one of \"math\" or\n * \"text\", which denotes whether the current environment is a math-y\n * one or a text-y one (e.g. inside \\text). Currently, this serves to\n * limit the functions which can be used in text mode.\n *\n * The main functions then return an object which contains the useful data that\n * was parsed at its given point, and a new position at the end of the parsed\n * data. The main functions can call each other and continue the parsing by\n * using the returned position as a new starting point.\n *\n * There are also extra `.handle...` functions, which pull out some reused\n * functionality into self-contained functions.\n *\n * The earlier functions return ParseNodes.\n * The later functions (which are called deeper in the parse) sometimes return\n * ParseFuncOrArgument, which contain a ParseNode as well as some data about\n * whether the parsed object is a function which is missing some arguments, or a\n * standalone object which can be used as an argument to another function.\n */\n\n/**\n * Main Parser class\n */\nfunction Parser(input, settings) {\n    // Create a new macro expander (gullet) and (indirectly via that) also a\n    // new lexer (mouth) for this parser (stomach, in the language of TeX)\n    this.gullet = new MacroExpander(input, settings.macros);\n    // Store the settings for use in parsing\n    this.settings = settings;\n    // Count leftright depth (for \\middle errors)\n    this.leftrightDepth = 0;\n}\n\nvar ParseNode = parseData.ParseNode;\n\n/**\n * An initial function (without its arguments), or an argument to a function.\n * The `result` argument should be a ParseNode.\n */\nfunction ParseFuncOrArgument(result, isFunction, token) {\n    this.result = result;\n    // Is this a function (i.e. is it something defined in functions.js)?\n    this.isFunction = isFunction;\n    this.token = token;\n}\n\n/**\n * Checks a result to make sure it has the right type, and throws an\n * appropriate error otherwise.\n *\n * @param {boolean=} consume whether to consume the expected token,\n *                           defaults to true\n */\nParser.prototype.expect = function(text, consume) {\n    if (this.nextToken.text !== text) {\n        throw new ParseError(\n            \"Expected '\" + text + \"', got '\" + this.nextToken.text + \"'\",\n            this.nextToken\n        );\n    }\n    if (consume !== false) {\n        this.consume();\n    }\n};\n\n/**\n * Considers the current look ahead token as consumed,\n * and fetches the one after that as the new look ahead.\n */\nParser.prototype.consume = function() {\n    this.nextToken = this.gullet.get(this.mode === \"math\");\n};\n\nParser.prototype.switchMode = function(newMode) {\n    this.gullet.unget(this.nextToken);\n    this.mode = newMode;\n    this.consume();\n};\n\n/**\n * Main parsing function, which parses an entire input.\n *\n * @return {?Array.<ParseNode>}\n */\nParser.prototype.parse = function() {\n    // Try to parse the input\n    this.mode = \"math\";\n    this.consume();\n    var parse = this.parseInput();\n    return parse;\n};\n\n/**\n * Parses an entire input tree.\n */\nParser.prototype.parseInput = function() {\n    // Parse an expression\n    var expression = this.parseExpression(false);\n    // If we succeeded, make sure there's an EOF at the end\n    this.expect(\"EOF\", false);\n    return expression;\n};\n\nvar endOfExpression = [\"}\", \"\\\\end\", \"\\\\right\", \"&\", \"\\\\\\\\\", \"\\\\cr\"];\n\n/**\n * Parses an \"expression\", which is a list of atoms.\n *\n * @param {boolean} breakOnInfix  Should the parsing stop when we hit infix\n *                  nodes? This happens when functions have higher precendence\n *                  than infix nodes in implicit parses.\n *\n * @param {?string} breakOnTokenText  The text of the token that the expression\n *                  should end with, or `null` if something else should end the\n *                  expression.\n *\n * @return {ParseNode}\n */\nParser.prototype.parseExpression = function(breakOnInfix, breakOnTokenText) {\n    var body = [];\n    // Keep adding atoms to the body until we can't parse any more atoms (either\n    // we reached the end, a }, or a \\right)\n    while (true) {\n        var lex = this.nextToken;\n        if (endOfExpression.indexOf(lex.text) !== -1) {\n            break;\n        }\n        if (breakOnTokenText && lex.text === breakOnTokenText) {\n            break;\n        }\n        if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {\n            break;\n        }\n        var atom = this.parseAtom();\n        if (!atom) {\n            if (!this.settings.throwOnError && lex.text[0] === \"\\\\\") {\n                var errorNode = this.handleUnsupportedCmd();\n                body.push(errorNode);\n                continue;\n            }\n\n            break;\n        }\n        body.push(atom);\n    }\n    return this.handleInfixNodes(body);\n};\n\n/**\n * Rewrites infix operators such as \\over with corresponding commands such\n * as \\frac.\n *\n * There can only be one infix operator per group.  If there's more than one\n * then the expression is ambiguous.  This can be resolved by adding {}.\n *\n * @returns {Array}\n */\nParser.prototype.handleInfixNodes = function(body) {\n    var overIndex = -1;\n    var funcName;\n\n    for (var i = 0; i < body.length; i++) {\n        var node = body[i];\n        if (node.type === \"infix\") {\n            if (overIndex !== -1) {\n                throw new ParseError(\n                    \"only one infix operator per group\",\n                    node.value.token);\n            }\n            overIndex = i;\n            funcName = node.value.replaceWith;\n        }\n    }\n\n    if (overIndex !== -1) {\n        var numerNode;\n        var denomNode;\n\n        var numerBody = body.slice(0, overIndex);\n        var denomBody = body.slice(overIndex + 1);\n\n        if (numerBody.length === 1 && numerBody[0].type === \"ordgroup\") {\n            numerNode = numerBody[0];\n        } else {\n            numerNode = new ParseNode(\"ordgroup\", numerBody, this.mode);\n        }\n\n        if (denomBody.length === 1 && denomBody[0].type === \"ordgroup\") {\n            denomNode = denomBody[0];\n        } else {\n            denomNode = new ParseNode(\"ordgroup\", denomBody, this.mode);\n        }\n\n        var value = this.callFunction(\n            funcName, [numerNode, denomNode], null);\n        return [new ParseNode(value.type, value, this.mode)];\n    } else {\n        return body;\n    }\n};\n\n// The greediness of a superscript or subscript\nvar SUPSUB_GREEDINESS = 1;\n\n/**\n * Handle a subscript or superscript with nice errors.\n */\nParser.prototype.handleSupSubscript = function(name) {\n    var symbolToken = this.nextToken;\n    var symbol = symbolToken.text;\n    this.consume();\n    var group = this.parseGroup();\n\n    if (!group) {\n        if (!this.settings.throwOnError && this.nextToken.text[0] === \"\\\\\") {\n            return this.handleUnsupportedCmd();\n        } else {\n            throw new ParseError(\n                \"Expected group after '\" + symbol + \"'\",\n                symbolToken\n            );\n        }\n    } else if (group.isFunction) {\n        // ^ and _ have a greediness, so handle interactions with functions'\n        // greediness\n        var funcGreediness = functions[group.result].greediness;\n        if (funcGreediness > SUPSUB_GREEDINESS) {\n            return this.parseFunction(group);\n        } else {\n            throw new ParseError(\n                \"Got function '\" + group.result + \"' with no arguments \" +\n                    \"as \" + name, symbolToken);\n        }\n    } else {\n        return group.result;\n    }\n};\n\n/**\n * Converts the textual input of an unsupported command into a text node\n * contained within a color node whose color is determined by errorColor\n */\nParser.prototype.handleUnsupportedCmd = function() {\n    var text = this.nextToken.text;\n    var textordArray = [];\n\n    for (var i = 0; i < text.length; i++) {\n        textordArray.push(new ParseNode(\"textord\", text[i], \"text\"));\n    }\n\n    var textNode = new ParseNode(\n        \"text\",\n        {\n            body: textordArray,\n            type: \"text\"\n        },\n        this.mode);\n\n    var colorNode = new ParseNode(\n        \"color\",\n        {\n            color: this.settings.errorColor,\n            value: [textNode],\n            type: \"color\"\n        },\n        this.mode);\n\n    this.consume();\n    return colorNode;\n};\n\n/**\n * Parses a group with optional super/subscripts.\n *\n * @return {?ParseNode}\n */\nParser.prototype.parseAtom = function() {\n    // The body of an atom is an implicit group, so that things like\n    // \\left(x\\right)^2 work correctly.\n    var base = this.parseImplicitGroup();\n\n    // In text mode, we don't have superscripts or subscripts\n    if (this.mode === \"text\") {\n        return base;\n    }\n\n    // Note that base may be empty (i.e. null) at this point.\n\n    var superscript;\n    var subscript;\n    while (true) {\n        // Lex the first token\n        var lex = this.nextToken;\n\n        if (lex.text === \"\\\\limits\" || lex.text === \"\\\\nolimits\") {\n            // We got a limit control\n            if (!base || base.type !== \"op\") {\n                throw new ParseError(\n                    \"Limit controls must follow a math operator\",\n                    lex);\n            } else {\n                var limits = lex.text === \"\\\\limits\";\n                base.value.limits = limits;\n                base.value.alwaysHandleSupSub = true;\n            }\n            this.consume();\n        } else if (lex.text === \"^\") {\n            // We got a superscript start\n            if (superscript) {\n                throw new ParseError(\"Double superscript\", lex);\n            }\n            superscript = this.handleSupSubscript(\"superscript\");\n        } else if (lex.text === \"_\") {\n            // We got a subscript start\n            if (subscript) {\n                throw new ParseError(\"Double subscript\", lex);\n            }\n            subscript = this.handleSupSubscript(\"subscript\");\n        } else if (lex.text === \"'\") {\n            // We got a prime\n            var prime = new ParseNode(\"textord\", \"\\\\prime\", this.mode);\n\n            // Many primes can be grouped together, so we handle this here\n            var primes = [prime];\n            this.consume();\n            // Keep lexing tokens until we get something that's not a prime\n            while (this.nextToken.text === \"'\") {\n                // For each one, add another prime to the list\n                primes.push(prime);\n                this.consume();\n            }\n            // Put them into an ordgroup as the superscript\n            superscript = new ParseNode(\"ordgroup\", primes, this.mode);\n        } else {\n            // If it wasn't ^, _, or ', stop parsing super/subscripts\n            break;\n        }\n    }\n\n    if (superscript || subscript) {\n        // If we got either a superscript or subscript, create a supsub\n        return new ParseNode(\"supsub\", {\n            base: base,\n            sup: superscript,\n            sub: subscript\n        }, this.mode);\n    } else {\n        // Otherwise return the original body\n        return base;\n    }\n};\n\n// A list of the size-changing functions, for use in parseImplicitGroup\nvar sizeFuncs = [\n    \"\\\\tiny\", \"\\\\scriptsize\", \"\\\\footnotesize\", \"\\\\small\", \"\\\\normalsize\",\n    \"\\\\large\", \"\\\\Large\", \"\\\\LARGE\", \"\\\\huge\", \"\\\\Huge\"\n];\n\n// A list of the style-changing functions, for use in parseImplicitGroup\nvar styleFuncs = [\n    \"\\\\displaystyle\", \"\\\\textstyle\", \"\\\\scriptstyle\", \"\\\\scriptscriptstyle\"\n];\n\n/**\n * Parses an implicit group, which is a group that starts at the end of a\n * specified, and ends right before a higher explicit group ends, or at EOL. It\n * is used for functions that appear to affect the current style, like \\Large or\n * \\textrm, where instead of keeping a style we just pretend that there is an\n * implicit grouping after it until the end of the group. E.g.\n *   small text {\\Large large text} small text again\n * It is also used for \\left and \\right to get the correct grouping.\n *\n * @return {?ParseNode}\n */\nParser.prototype.parseImplicitGroup = function() {\n    var start = this.parseSymbol();\n\n    if (start == null) {\n        // If we didn't get anything we handle, fall back to parseFunction\n        return this.parseFunction();\n    }\n\n    var func = start.result;\n    var body;\n\n    if (func === \"\\\\left\") {\n        // If we see a left:\n        // Parse the entire left function (including the delimiter)\n        var left = this.parseFunction(start);\n        // Parse out the implicit body\n        ++this.leftrightDepth;\n        body = this.parseExpression(false);\n        --this.leftrightDepth;\n        // Check the next token\n        this.expect(\"\\\\right\", false);\n        var right = this.parseFunction();\n        return new ParseNode(\"leftright\", {\n            body: body,\n            left: left.value.value,\n            right: right.value.value\n        }, this.mode);\n    } else if (func === \"\\\\begin\") {\n        // begin...end is similar to left...right\n        var begin = this.parseFunction(start);\n        var envName = begin.value.name;\n        if (!environments.hasOwnProperty(envName)) {\n            throw new ParseError(\n                \"No such environment: \" + envName, begin.value.nameGroup);\n        }\n        // Build the environment object. Arguments and other information will\n        // be made available to the begin and end methods using properties.\n        var env = environments[envName];\n        var args = this.parseArguments(\"\\\\begin{\" + envName + \"}\", env);\n        var context = {\n            mode: this.mode,\n            envName: envName,\n            parser: this,\n            positions: args.pop()\n        };\n        var result = env.handler(context, args);\n        this.expect(\"\\\\end\", false);\n        var endNameToken = this.nextToken;\n        var end = this.parseFunction();\n        if (end.value.name !== envName) {\n            throw new ParseError(\n                \"Mismatch: \\\\begin{\" + envName + \"} matched \" +\n                \"by \\\\end{\" + end.value.name + \"}\",\n                endNameToken);\n        }\n        result.position = end.position;\n        return result;\n    } else if (utils.contains(sizeFuncs, func)) {\n        // If we see a sizing function, parse out the implict body\n        body = this.parseExpression(false);\n        return new ParseNode(\"sizing\", {\n            // Figure out what size to use based on the list of functions above\n            size: \"size\" + (utils.indexOf(sizeFuncs, func) + 1),\n            value: body\n        }, this.mode);\n    } else if (utils.contains(styleFuncs, func)) {\n        // If we see a styling function, parse out the implict body\n        body = this.parseExpression(true);\n        return new ParseNode(\"styling\", {\n            // Figure out what style to use by pulling out the style from\n            // the function name\n            style: func.slice(1, func.length - 5),\n            value: body\n        }, this.mode);\n    } else {\n        // Defer to parseFunction if it's not a function we handle\n        return this.parseFunction(start);\n    }\n};\n\n/**\n * Parses an entire function, including its base and all of its arguments.\n * The base might either have been parsed already, in which case\n * it is provided as an argument, or it's the next group in the input.\n *\n * @param {ParseFuncOrArgument=} baseGroup optional as described above\n * @return {?ParseNode}\n */\nParser.prototype.parseFunction = function(baseGroup) {\n    if (!baseGroup) {\n        baseGroup = this.parseGroup();\n    }\n\n    if (baseGroup) {\n        if (baseGroup.isFunction) {\n            var func = baseGroup.result;\n            var funcData = functions[func];\n            if (this.mode === \"text\" && !funcData.allowedInText) {\n                throw new ParseError(\n                    \"Can't use function '\" + func + \"' in text mode\",\n                    baseGroup.token);\n            }\n\n            var args = this.parseArguments(func, funcData);\n            var token = baseGroup.token;\n            var result = this.callFunction(func, args, args.pop(), token);\n            return new ParseNode(result.type, result, this.mode);\n        } else {\n            return baseGroup.result;\n        }\n    } else {\n        return null;\n    }\n};\n\n/**\n * Call a function handler with a suitable context and arguments.\n */\nParser.prototype.callFunction = function(name, args, positions, token) {\n    var context = {\n        funcName: name,\n        parser: this,\n        positions: positions,\n        token: token\n    };\n    return functions[name].handler(context, args);\n};\n\n/**\n * Parses the arguments of a function or environment\n *\n * @param {string} func  \"\\name\" or \"\\begin{name}\"\n * @param {{numArgs:number,numOptionalArgs:number|undefined}} funcData\n * @return the array of arguments, with the list of positions as last element\n */\nParser.prototype.parseArguments = function(func, funcData) {\n    var totalArgs = funcData.numArgs + funcData.numOptionalArgs;\n    if (totalArgs === 0) {\n        return [[this.pos]];\n    }\n\n    var baseGreediness = funcData.greediness;\n    var positions = [this.pos];\n    var args = [];\n\n    for (var i = 0; i < totalArgs; i++) {\n        var nextToken = this.nextToken;\n        var argType = funcData.argTypes && funcData.argTypes[i];\n        var arg;\n        if (i < funcData.numOptionalArgs) {\n            if (argType) {\n                arg = this.parseGroupOfType(argType, true);\n            } else {\n                arg = this.parseGroup(true);\n            }\n            if (!arg) {\n                args.push(null);\n                positions.push(this.pos);\n                continue;\n            }\n        } else {\n            if (argType) {\n                arg = this.parseGroupOfType(argType);\n            } else {\n                arg = this.parseGroup();\n            }\n            if (!arg) {\n                if (!this.settings.throwOnError &&\n                    this.nextToken.text[0] === \"\\\\\") {\n                    arg = new ParseFuncOrArgument(\n                        this.handleUnsupportedCmd(this.nextToken.text),\n                        false);\n                } else {\n                    throw new ParseError(\n                        \"Expected group after '\" + func + \"'\", nextToken);\n                }\n            }\n        }\n        var argNode;\n        if (arg.isFunction) {\n            var argGreediness =\n                functions[arg.result].greediness;\n            if (argGreediness > baseGreediness) {\n                argNode = this.parseFunction(arg);\n            } else {\n                throw new ParseError(\n                    \"Got function '\" + arg.result + \"' as \" +\n                    \"argument to '\" + func + \"'\", nextToken);\n            }\n        } else {\n            argNode = arg.result;\n        }\n        args.push(argNode);\n        positions.push(this.pos);\n    }\n\n    args.push(positions);\n\n    return args;\n};\n\n\n/**\n * Parses a group when the mode is changing.\n *\n * @return {?ParseFuncOrArgument}\n */\nParser.prototype.parseGroupOfType = function(innerMode, optional) {\n    var outerMode = this.mode;\n    // Handle `original` argTypes\n    if (innerMode === \"original\") {\n        innerMode = outerMode;\n    }\n\n    if (innerMode === \"color\") {\n        return this.parseColorGroup(optional);\n    }\n    if (innerMode === \"size\") {\n        return this.parseSizeGroup(optional);\n    }\n\n    this.switchMode(innerMode);\n    if (innerMode === \"text\") {\n        // text mode is special because it should ignore the whitespace before\n        // it\n        while (this.nextToken.text === \" \") {\n            this.consume();\n        }\n    }\n    // By the time we get here, innerMode is one of \"text\" or \"math\".\n    // We switch the mode of the parser, recurse, then restore the old mode.\n    var res = this.parseGroup(optional);\n    this.switchMode(outerMode);\n    return res;\n};\n\n/**\n * Parses a group, essentially returning the string formed by the\n * brace-enclosed tokens plus some position information.\n *\n * @param {string} modeName  Used to describe the mode in error messages\n * @param {boolean=} optional  Whether the group is optional or required\n */\nParser.prototype.parseStringGroup = function(modeName, optional) {\n    if (optional && this.nextToken.text !== \"[\") {\n        return null;\n    }\n    var outerMode = this.mode;\n    this.mode = \"text\";\n    this.expect(optional ? \"[\" : \"{\");\n    var str = \"\";\n    var firstToken = this.nextToken;\n    var lastToken = firstToken;\n    while (this.nextToken.text !== (optional ? \"]\" : \"}\")) {\n        if (this.nextToken.text === \"EOF\") {\n            throw new ParseError(\n                \"Unexpected end of input in \" + modeName,\n                firstToken.range(this.nextToken, str));\n        }\n        lastToken = this.nextToken;\n        str += lastToken.text;\n        this.consume();\n    }\n    this.mode = outerMode;\n    this.expect(optional ? \"]\" : \"}\");\n    return firstToken.range(lastToken, str);\n};\n\n/**\n * Parses a regex-delimited group: the largest sequence of tokens\n * whose concatenated strings match `regex`. Returns the string\n * formed by the tokens plus some position information.\n *\n * @param {RegExp} regex\n * @param {string} modeName  Used to describe the mode in error messages\n */\nParser.prototype.parseRegexGroup = function(regex, modeName) {\n    var outerMode = this.mode;\n    this.mode = \"text\";\n    var firstToken = this.nextToken;\n    var lastToken = firstToken;\n    var str = \"\";\n    while (this.nextToken.text !== \"EOF\"\n           && regex.test(str + this.nextToken.text)) {\n        lastToken = this.nextToken;\n        str += lastToken.text;\n        this.consume();\n    }\n    if (str === \"\") {\n        throw new ParseError(\n            \"Invalid \" + modeName + \": '\" + firstToken.text + \"'\",\n            firstToken);\n    }\n    this.mode = outerMode;\n    return firstToken.range(lastToken, str);\n};\n\n/**\n * Parses a color description.\n */\nParser.prototype.parseColorGroup = function(optional) {\n    var res = this.parseStringGroup(\"color\", optional);\n    if (!res) {\n        return null;\n    }\n    var match = (/^(#[a-z0-9]+|[a-z]+)$/i).exec(res.text);\n    if (!match) {\n        throw new ParseError(\"Invalid color: '\" + res.text + \"'\", res);\n    }\n    return new ParseFuncOrArgument(\n        new ParseNode(\"color\", match[0], this.mode),\n        false);\n};\n\n/**\n * Parses a size specification, consisting of magnitude and unit.\n */\nParser.prototype.parseSizeGroup = function(optional) {\n    var res;\n    if (!optional && this.nextToken.text !== \"{\") {\n        res = this.parseRegexGroup(\n            /^[-+]? *(?:$|\\d+|\\d+\\.\\d*|\\.\\d*) *[a-z]{0,2}$/, \"size\");\n    } else {\n        res = this.parseStringGroup(\"size\", optional);\n    }\n    if (!res) {\n        return null;\n    }\n    var match = (/([-+]?) *(\\d+(?:\\.\\d*)?|\\.\\d+) *([a-z]{2})/).exec(res.text);\n    if (!match) {\n        throw new ParseError(\"Invalid size: '\" + res.text + \"'\", res);\n    }\n    var data = {\n        number: +(match[1] + match[2]), // sign + magnitude, cast to number\n        unit: match[3]\n    };\n    if (data.unit !== \"em\" && data.unit !== \"ex\" && data.unit !== \"mu\") {\n        throw new ParseError(\"Invalid unit: '\" + data.unit + \"'\", res);\n    }\n    return new ParseFuncOrArgument(\n        new ParseNode(\"color\", data, this.mode),\n        false);\n};\n\n/**\n * If the argument is false or absent, this parses an ordinary group,\n * which is either a single nucleus (like \"x\") or an expression\n * in braces (like \"{x+y}\").\n * If the argument is true, it parses either a bracket-delimited expression\n * (like \"[x+y]\") or returns null to indicate the absence of a\n * bracket-enclosed group.\n *\n * @param {boolean=} optional  Whether the group is optional or required\n * @return {?ParseFuncOrArgument}\n */\nParser.prototype.parseGroup = function(optional) {\n    var firstToken = this.nextToken;\n    // Try to parse an open brace\n    if (this.nextToken.text === (optional ? \"[\" : \"{\")) {\n        // If we get a brace, parse an expression\n        this.consume();\n        var expression = this.parseExpression(false, optional ? \"]\" : null);\n        var lastToken = this.nextToken;\n        // Make sure we get a close brace\n        this.expect(optional ? \"]\" : \"}\");\n        if (this.mode === \"text\") {\n            this.formLigatures(expression);\n        }\n        return new ParseFuncOrArgument(\n            new ParseNode(\"ordgroup\", expression, this.mode,\n                          firstToken, lastToken),\n            false);\n    } else {\n        // Otherwise, just return a nucleus, or nothing for an optional group\n        return optional ? null : this.parseSymbol();\n    }\n};\n\n/**\n * Form ligature-like combinations of characters for text mode.\n * This includes inputs like \"--\", \"---\", \"``\" and \"''\".\n * The result will simply replace multiple textord nodes with a single\n * character in each value by a single textord node having multiple\n * characters in its value.  The representation is still ASCII source.\n *\n * @param {Array.<ParseNode>} group  the nodes of this group,\n *                                   list will be moified in place\n */\nParser.prototype.formLigatures = function(group) {\n    var i;\n    var n = group.length - 1;\n    for (i = 0; i < n; ++i) {\n        var a = group[i];\n        var v = a.value;\n        if (v === \"-\" && group[i + 1].value === \"-\") {\n            if (i + 1 < n && group[i + 2].value === \"-\") {\n                group.splice(i, 3, new ParseNode(\n                    \"textord\", \"---\", \"text\", a, group[i + 2]));\n                n -= 2;\n            } else {\n                group.splice(i, 2, new ParseNode(\n                    \"textord\", \"--\", \"text\", a, group[i + 1]));\n                n -= 1;\n            }\n        }\n        if ((v === \"'\" || v === \"`\") && group[i + 1].value === v) {\n            group.splice(i, 2, new ParseNode(\n                \"textord\", v + v, \"text\", a, group[i + 1]));\n            n -= 1;\n        }\n    }\n};\n\n/**\n * Parse a single symbol out of the string. Here, we handle both the functions\n * we have defined, as well as the single character symbols\n *\n * @return {?ParseFuncOrArgument}\n */\nParser.prototype.parseSymbol = function() {\n    var nucleus = this.nextToken;\n\n    if (functions[nucleus.text]) {\n        this.consume();\n        // If there exists a function with this name, we return the function and\n        // say that it is a function.\n        return new ParseFuncOrArgument(\n            nucleus.text,\n            true, nucleus);\n    } else if (symbols[this.mode][nucleus.text]) {\n        this.consume();\n        // Otherwise if this is a no-argument function, find the type it\n        // corresponds to in the symbols map\n        return new ParseFuncOrArgument(\n            new ParseNode(symbols[this.mode][nucleus.text].group,\n                          nucleus.text, this.mode, nucleus),\n            false, nucleus);\n    } else if (this.mode === \"text\" && cjkRegex.test(nucleus.text)) {\n        this.consume();\n        return new ParseFuncOrArgument(\n            new ParseNode(\"textord\", nucleus.text, this.mode, nucleus),\n            false, nucleus);\n    } else {\n        return null;\n    }\n};\n\nParser.prototype.ParseNode = ParseNode;\n\nmodule.exports = Parser;\n"]},"metadata":{},"sourceType":"script"}