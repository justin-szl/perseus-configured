{"ast":null,"code":"/* eslint no-constant-condition:0 */\nvar parseData = require(\"./parseData\");\n\nvar ParseError = require(\"./ParseError\");\n\nvar Style = require(\"./Style\");\n\nvar ParseNode = parseData.ParseNode;\n/**\n * Parse the body of the environment, with rows delimited by \\\\ and\n * columns delimited by &, and create a nested list in row-major order\n * with one group per cell.\n */\n\nfunction parseArray(parser, result) {\n  var row = [];\n  var body = [row];\n  var rowGaps = [];\n\n  while (true) {\n    var cell = parser.parseExpression(false, null);\n    row.push(new ParseNode(\"ordgroup\", cell, parser.mode));\n    var next = parser.nextToken.text;\n\n    if (next === \"&\") {\n      parser.consume();\n    } else if (next === \"\\\\end\") {\n      break;\n    } else if (next === \"\\\\\\\\\" || next === \"\\\\cr\") {\n      var cr = parser.parseFunction();\n      rowGaps.push(cr.value.size);\n      row = [];\n      body.push(row);\n    } else {\n      throw new ParseError(\"Expected & or \\\\\\\\ or \\\\end\", parser.nextToken);\n    }\n  }\n\n  result.body = body;\n  result.rowGaps = rowGaps;\n  return new ParseNode(result.type, result, parser.mode);\n}\n/*\n * An environment definition is very similar to a function definition:\n * it is declared with a name or a list of names, a set of properties\n * and a handler containing the actual implementation.\n *\n * The properties include:\n *  - numArgs: The number of arguments after the \\begin{name} function.\n *  - argTypes: (optional) Just like for a function\n *  - allowedInText: (optional) Whether or not the environment is allowed inside\n *                   text mode (default false) (not enforced yet)\n *  - numOptionalArgs: (optional) Just like for a function\n * A bare number instead of that object indicates the numArgs value.\n *\n * The handler function will receive two arguments\n *  - context: information and references provided by the parser\n *  - args: an array of arguments passed to \\begin{name}\n * The context contains the following properties:\n *  - envName: the name of the environment, one of the listed names.\n *  - parser: the parser object\n *  - lexer: the lexer object\n *  - positions: the positions associated with these arguments from args.\n * The handler must return a ParseResult.\n */\n\n\nfunction defineEnvironment(names, props, handler) {\n  if (typeof names === \"string\") {\n    names = [names];\n  }\n\n  if (typeof props === \"number\") {\n    props = {\n      numArgs: props\n    };\n  } // Set default values of environments\n\n\n  var data = {\n    numArgs: props.numArgs || 0,\n    argTypes: props.argTypes,\n    greediness: 1,\n    allowedInText: !!props.allowedInText,\n    numOptionalArgs: props.numOptionalArgs || 0,\n    handler: handler\n  };\n\n  for (var i = 0; i < names.length; ++i) {\n    module.exports[names[i]] = data;\n  }\n} // Arrays are part of LaTeX, defined in lttab.dtx so its documentation\n// is part of the source2e.pdf file of LaTeX2e source documentation.\n\n\ndefineEnvironment(\"array\", {\n  numArgs: 1\n}, function (context, args) {\n  var colalign = args[0];\n  colalign = colalign.value.map ? colalign.value : [colalign];\n  var cols = colalign.map(function (node) {\n    var ca = node.value;\n\n    if (\"lcr\".indexOf(ca) !== -1) {\n      return {\n        type: \"align\",\n        align: ca\n      };\n    } else if (ca === \"|\") {\n      return {\n        type: \"separator\",\n        separator: \"|\"\n      };\n    }\n\n    throw new ParseError(\"Unknown column alignment: \" + node.value, node);\n  });\n  var res = {\n    type: \"array\",\n    cols: cols,\n    hskipBeforeAndAfter: true // \\@preamble in lttab.dtx\n\n  };\n  res = parseArray(context.parser, res);\n  return res;\n}); // The matrix environments of amsmath builds on the array environment\n// of LaTeX, which is discussed above.\n\ndefineEnvironment([\"matrix\", \"pmatrix\", \"bmatrix\", \"Bmatrix\", \"vmatrix\", \"Vmatrix\"], {}, function (context) {\n  var delimiters = {\n    \"matrix\": null,\n    \"pmatrix\": [\"(\", \")\"],\n    \"bmatrix\": [\"[\", \"]\"],\n    \"Bmatrix\": [\"\\\\{\", \"\\\\}\"],\n    \"vmatrix\": [\"|\", \"|\"],\n    \"Vmatrix\": [\"\\\\Vert\", \"\\\\Vert\"]\n  }[context.envName];\n  var res = {\n    type: \"array\",\n    hskipBeforeAndAfter: false // \\hskip -\\arraycolsep in amsmath\n\n  };\n  res = parseArray(context.parser, res);\n\n  if (delimiters) {\n    res = new ParseNode(\"leftright\", {\n      body: [res],\n      left: delimiters[0],\n      right: delimiters[1]\n    }, context.mode);\n  }\n\n  return res;\n}); // A cases environment (in amsmath.sty) is almost equivalent to\n// \\def\\arraystretch{1.2}%\n// \\left\\{\\begin{array}{@{}l@{\\quad}l@{}} … \\end{array}\\right.\n\ndefineEnvironment(\"cases\", {}, function (context) {\n  var res = {\n    type: \"array\",\n    arraystretch: 1.2,\n    cols: [{\n      type: \"align\",\n      align: \"l\",\n      pregap: 0,\n      // TODO(kevinb) get the current style.\n      // For now we use the metrics for TEXT style which is what we were\n      // doing before.  Before attempting to get the current style we\n      // should look at TeX's behavior especially for \\over and matrices.\n      postgap: Style.TEXT.metrics.quad\n    }, {\n      type: \"align\",\n      align: \"l\",\n      pregap: 0,\n      postgap: 0\n    }]\n  };\n  res = parseArray(context.parser, res);\n  res = new ParseNode(\"leftright\", {\n    body: [res],\n    left: \"\\\\{\",\n    right: \".\"\n  }, context.mode);\n  return res;\n}); // An aligned environment is like the align* environment\n// except it operates within math mode.\n// Note that we assume \\nomallineskiplimit to be zero,\n// so that \\strut@ is the same as \\strut.\n\ndefineEnvironment(\"aligned\", {}, function (context) {\n  var res = {\n    type: \"array\",\n    cols: []\n  };\n  res = parseArray(context.parser, res);\n  var emptyGroup = new ParseNode(\"ordgroup\", [], context.mode);\n  var numCols = 0;\n  res.value.body.forEach(function (row) {\n    var i;\n\n    for (i = 1; i < row.length; i += 2) {\n      row[i].value.unshift(emptyGroup);\n    }\n\n    if (numCols < row.length) {\n      numCols = row.length;\n    }\n  });\n\n  for (var i = 0; i < numCols; ++i) {\n    var align = \"r\";\n    var pregap = 0;\n\n    if (i % 2 === 1) {\n      align = \"l\";\n    } else if (i > 0) {\n      pregap = 2; // one \\qquad between columns\n    }\n\n    res.value.cols[i] = {\n      type: \"align\",\n      align: align,\n      pregap: pregap,\n      postgap: 0\n    };\n  }\n\n  return res;\n});","map":{"version":3,"sources":["/Users/justinf/perseus-configured/node_modules/katex/src/environments.js"],"names":["parseData","require","ParseError","Style","ParseNode","parseArray","parser","result","row","body","rowGaps","cell","parseExpression","push","mode","next","nextToken","text","consume","cr","parseFunction","value","size","type","defineEnvironment","names","props","handler","numArgs","data","argTypes","greediness","allowedInText","numOptionalArgs","i","length","module","exports","context","args","colalign","map","cols","node","ca","indexOf","align","separator","res","hskipBeforeAndAfter","delimiters","envName","left","right","arraystretch","pregap","postgap","TEXT","metrics","quad","emptyGroup","numCols","forEach","unshift"],"mappings":"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","sourcesContent":["/* eslint no-constant-condition:0 */\nvar parseData = require(\"./parseData\");\nvar ParseError = require(\"./ParseError\");\nvar Style = require(\"./Style\");\n\nvar ParseNode = parseData.ParseNode;\n\n/**\n * Parse the body of the environment, with rows delimited by \\\\ and\n * columns delimited by &, and create a nested list in row-major order\n * with one group per cell.\n */\nfunction parseArray(parser, result) {\n    var row = [];\n    var body = [row];\n    var rowGaps = [];\n    while (true) {\n        var cell = parser.parseExpression(false, null);\n        row.push(new ParseNode(\"ordgroup\", cell, parser.mode));\n        var next = parser.nextToken.text;\n        if (next === \"&\") {\n            parser.consume();\n        } else if (next === \"\\\\end\") {\n            break;\n        } else if (next === \"\\\\\\\\\" || next === \"\\\\cr\") {\n            var cr = parser.parseFunction();\n            rowGaps.push(cr.value.size);\n            row = [];\n            body.push(row);\n        } else {\n            throw new ParseError(\"Expected & or \\\\\\\\ or \\\\end\",\n                                 parser.nextToken);\n        }\n    }\n    result.body = body;\n    result.rowGaps = rowGaps;\n    return new ParseNode(result.type, result, parser.mode);\n}\n\n/*\n * An environment definition is very similar to a function definition:\n * it is declared with a name or a list of names, a set of properties\n * and a handler containing the actual implementation.\n *\n * The properties include:\n *  - numArgs: The number of arguments after the \\begin{name} function.\n *  - argTypes: (optional) Just like for a function\n *  - allowedInText: (optional) Whether or not the environment is allowed inside\n *                   text mode (default false) (not enforced yet)\n *  - numOptionalArgs: (optional) Just like for a function\n * A bare number instead of that object indicates the numArgs value.\n *\n * The handler function will receive two arguments\n *  - context: information and references provided by the parser\n *  - args: an array of arguments passed to \\begin{name}\n * The context contains the following properties:\n *  - envName: the name of the environment, one of the listed names.\n *  - parser: the parser object\n *  - lexer: the lexer object\n *  - positions: the positions associated with these arguments from args.\n * The handler must return a ParseResult.\n */\n\nfunction defineEnvironment(names, props, handler) {\n    if (typeof names === \"string\") {\n        names = [names];\n    }\n    if (typeof props === \"number\") {\n        props = { numArgs: props };\n    }\n    // Set default values of environments\n    var data = {\n        numArgs: props.numArgs || 0,\n        argTypes: props.argTypes,\n        greediness: 1,\n        allowedInText: !!props.allowedInText,\n        numOptionalArgs: props.numOptionalArgs || 0,\n        handler: handler\n    };\n    for (var i = 0; i < names.length; ++i) {\n        module.exports[names[i]] = data;\n    }\n}\n\n// Arrays are part of LaTeX, defined in lttab.dtx so its documentation\n// is part of the source2e.pdf file of LaTeX2e source documentation.\ndefineEnvironment(\"array\", {\n    numArgs: 1\n}, function(context, args) {\n    var colalign = args[0];\n    colalign = colalign.value.map ? colalign.value : [colalign];\n    var cols = colalign.map(function(node) {\n        var ca = node.value;\n        if (\"lcr\".indexOf(ca) !== -1) {\n            return {\n                type: \"align\",\n                align: ca\n            };\n        } else if (ca === \"|\") {\n            return {\n                type: \"separator\",\n                separator: \"|\"\n            };\n        }\n        throw new ParseError(\n            \"Unknown column alignment: \" + node.value,\n            node);\n    });\n    var res = {\n        type: \"array\",\n        cols: cols,\n        hskipBeforeAndAfter: true // \\@preamble in lttab.dtx\n    };\n    res = parseArray(context.parser, res);\n    return res;\n});\n\n// The matrix environments of amsmath builds on the array environment\n// of LaTeX, which is discussed above.\ndefineEnvironment([\n    \"matrix\",\n    \"pmatrix\",\n    \"bmatrix\",\n    \"Bmatrix\",\n    \"vmatrix\",\n    \"Vmatrix\"\n], {\n}, function(context) {\n    var delimiters = {\n        \"matrix\": null,\n        \"pmatrix\": [\"(\", \")\"],\n        \"bmatrix\": [\"[\", \"]\"],\n        \"Bmatrix\": [\"\\\\{\", \"\\\\}\"],\n        \"vmatrix\": [\"|\", \"|\"],\n        \"Vmatrix\": [\"\\\\Vert\", \"\\\\Vert\"]\n    }[context.envName];\n    var res = {\n        type: \"array\",\n        hskipBeforeAndAfter: false // \\hskip -\\arraycolsep in amsmath\n    };\n    res = parseArray(context.parser, res);\n    if (delimiters) {\n        res = new ParseNode(\"leftright\", {\n            body: [res],\n            left: delimiters[0],\n            right: delimiters[1]\n        }, context.mode);\n    }\n    return res;\n});\n\n// A cases environment (in amsmath.sty) is almost equivalent to\n// \\def\\arraystretch{1.2}%\n// \\left\\{\\begin{array}{@{}l@{\\quad}l@{}} … \\end{array}\\right.\ndefineEnvironment(\"cases\", {\n}, function(context) {\n    var res = {\n        type: \"array\",\n        arraystretch: 1.2,\n        cols: [{\n            type: \"align\",\n            align: \"l\",\n            pregap: 0,\n            // TODO(kevinb) get the current style.\n            // For now we use the metrics for TEXT style which is what we were\n            // doing before.  Before attempting to get the current style we\n            // should look at TeX's behavior especially for \\over and matrices.\n            postgap: Style.TEXT.metrics.quad\n        }, {\n            type: \"align\",\n            align: \"l\",\n            pregap: 0,\n            postgap: 0\n        }]\n    };\n    res = parseArray(context.parser, res);\n    res = new ParseNode(\"leftright\", {\n        body: [res],\n        left: \"\\\\{\",\n        right: \".\"\n    }, context.mode);\n    return res;\n});\n\n// An aligned environment is like the align* environment\n// except it operates within math mode.\n// Note that we assume \\nomallineskiplimit to be zero,\n// so that \\strut@ is the same as \\strut.\ndefineEnvironment(\"aligned\", {\n}, function(context) {\n    var res = {\n        type: \"array\",\n        cols: []\n    };\n    res = parseArray(context.parser, res);\n    var emptyGroup = new ParseNode(\"ordgroup\", [], context.mode);\n    var numCols = 0;\n    res.value.body.forEach(function(row) {\n        var i;\n        for (i = 1; i < row.length; i += 2) {\n            row[i].value.unshift(emptyGroup);\n        }\n        if (numCols < row.length) {\n            numCols = row.length;\n        }\n    });\n    for (var i = 0; i < numCols; ++i) {\n        var align = \"r\";\n        var pregap = 0;\n        if (i % 2 === 1) {\n            align = \"l\";\n        } else if (i > 0) {\n            pregap = 2; // one \\qquad between columns\n        }\n        res.value.cols[i] = {\n            type: \"align\",\n            align: align,\n            pregap: pregap,\n            postgap: 0\n        };\n    }\n    return res;\n});\n"]},"metadata":{},"sourceType":"script"}