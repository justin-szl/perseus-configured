{"ast":null,"code":"var utils = require(\"./utils\");\n\nvar ParseError = require(\"./ParseError\");\n\nvar parseData = require(\"./parseData\");\n\nvar ParseNode = parseData.ParseNode;\n/* This file contains a list of functions that we parse, identified by\n * the calls to defineFunction.\n *\n * The first argument to defineFunction is a single name or a list of names.\n * All functions named in such a list will share a single implementation.\n *\n * Each declared function can have associated properties, which\n * include the following:\n *\n *  - numArgs: The number of arguments the function takes.\n *             If this is the only property, it can be passed as a number\n *             instead of an element of a properties object.\n *  - argTypes: (optional) An array corresponding to each argument of the\n *              function, giving the type of argument that should be parsed. Its\n *              length should be equal to `numArgs + numOptionalArgs`. Valid\n *              types:\n *               - \"size\": A size-like thing, such as \"1em\" or \"5ex\"\n *               - \"color\": An html color, like \"#abc\" or \"blue\"\n *               - \"original\": The same type as the environment that the\n *                             function being parsed is in (e.g. used for the\n *                             bodies of functions like \\color where the first\n *                             argument is special and the second argument is\n *                             parsed normally)\n *              Other possible types (probably shouldn't be used)\n *               - \"text\": Text-like (e.g. \\text)\n *               - \"math\": Normal math\n *              If undefined, this will be treated as an appropriate length\n *              array of \"original\" strings\n *  - greediness: (optional) The greediness of the function to use ungrouped\n *                arguments.\n *\n *                E.g. if you have an expression\n *                  \\sqrt \\frac 1 2\n *                since \\frac has greediness=2 vs \\sqrt's greediness=1, \\frac\n *                will use the two arguments '1' and '2' as its two arguments,\n *                then that whole function will be used as the argument to\n *                \\sqrt. On the other hand, the expressions\n *                  \\frac \\frac 1 2 3\n *                and\n *                  \\frac \\sqrt 1 2\n *                will fail because \\frac and \\frac have equal greediness\n *                and \\sqrt has a lower greediness than \\frac respectively. To\n *                make these parse, we would have to change them to:\n *                  \\frac {\\frac 1 2} 3\n *                and\n *                  \\frac {\\sqrt 1} 2\n *\n *                The default value is `1`\n *  - allowedInText: (optional) Whether or not the function is allowed inside\n *                   text mode (default false)\n *  - numOptionalArgs: (optional) The number of optional arguments the function\n *                     should parse. If the optional arguments aren't found,\n *                     `null` will be passed to the handler in their place.\n *                     (default 0)\n *  - infix: (optional) Must be true if the function is an infix operator.\n *\n * The last argument is that implementation, the handler for the function(s).\n * It is called to handle these functions and their arguments.\n * It receives two arguments:\n *  - context contains information and references provided by the parser\n *  - args is an array of arguments obtained from TeX input\n * The context contains the following properties:\n *  - funcName: the text (i.e. name) of the function, including \\\n *  - parser: the parser object\n *  - lexer: the lexer object\n *  - positions: the positions in the overall string of the function\n *               and the arguments.\n * The latter three should only be used to produce error messages.\n *\n * The function should return an object with the following keys:\n *  - type: The type of element that this is. This is then used in\n *          buildHTML/buildMathML to determine which function\n *          should be called to build this node into a DOM node\n * Any other data can be added to the object, which will be passed\n * in to the function in buildHTML/buildMathML as `group.value`.\n */\n\nfunction defineFunction(names, props, handler) {\n  if (typeof names === \"string\") {\n    names = [names];\n  }\n\n  if (typeof props === \"number\") {\n    props = {\n      numArgs: props\n    };\n  } // Set default values of functions\n\n\n  var data = {\n    numArgs: props.numArgs,\n    argTypes: props.argTypes,\n    greediness: props.greediness === undefined ? 1 : props.greediness,\n    allowedInText: !!props.allowedInText,\n    numOptionalArgs: props.numOptionalArgs || 0,\n    infix: !!props.infix,\n    handler: handler\n  };\n\n  for (var i = 0; i < names.length; ++i) {\n    module.exports[names[i]] = data;\n  }\n} // Since the corresponding buildHTML/buildMathML function expects a\n// list of elements, we normalize for different kinds of arguments\n\n\nvar ordargument = function (arg) {\n  if (arg.type === \"ordgroup\") {\n    return arg.value;\n  } else {\n    return [arg];\n  }\n}; // A normal square root\n\n\ndefineFunction(\"\\\\sqrt\", {\n  numArgs: 1,\n  numOptionalArgs: 1\n}, function (context, args) {\n  var index = args[0];\n  var body = args[1];\n  return {\n    type: \"sqrt\",\n    body: body,\n    index: index\n  };\n}); // Non-mathy text, possibly in a font\n\nvar textFunctionStyles = {\n  \"\\\\text\": undefined,\n  \"\\\\textrm\": \"mathrm\",\n  \"\\\\textsf\": \"mathsf\",\n  \"\\\\texttt\": \"mathtt\",\n  \"\\\\textnormal\": \"mathrm\",\n  \"\\\\textbf\": \"mathbf\",\n  \"\\\\textit\": \"textit\"\n};\ndefineFunction([\"\\\\text\", \"\\\\textrm\", \"\\\\textsf\", \"\\\\texttt\", \"\\\\textnormal\", \"\\\\textbf\", \"\\\\textit\"], {\n  numArgs: 1,\n  argTypes: [\"text\"],\n  greediness: 2,\n  allowedInText: true\n}, function (context, args) {\n  var body = args[0];\n  return {\n    type: \"text\",\n    body: ordargument(body),\n    style: textFunctionStyles[context.funcName]\n  };\n}); // A two-argument custom color\n\ndefineFunction(\"\\\\color\", {\n  numArgs: 2,\n  allowedInText: true,\n  greediness: 3,\n  argTypes: [\"color\", \"original\"]\n}, function (context, args) {\n  var color = args[0];\n  var body = args[1];\n  return {\n    type: \"color\",\n    color: color.value,\n    value: ordargument(body)\n  };\n}); // An overline\n\ndefineFunction(\"\\\\overline\", {\n  numArgs: 1\n}, function (context, args) {\n  var body = args[0];\n  return {\n    type: \"overline\",\n    body: body\n  };\n}); // An underline\n\ndefineFunction(\"\\\\underline\", {\n  numArgs: 1\n}, function (context, args) {\n  var body = args[0];\n  return {\n    type: \"underline\",\n    body: body\n  };\n}); // A box of the width and height\n\ndefineFunction(\"\\\\rule\", {\n  numArgs: 2,\n  numOptionalArgs: 1,\n  argTypes: [\"size\", \"size\", \"size\"]\n}, function (context, args) {\n  var shift = args[0];\n  var width = args[1];\n  var height = args[2];\n  return {\n    type: \"rule\",\n    shift: shift && shift.value,\n    width: width.value,\n    height: height.value\n  };\n}); // TODO: In TeX, \\mkern only accepts mu-units, and \\kern does not accept\n// mu-units. In current KaTeX we relax this; both commands accept any unit.\n\ndefineFunction([\"\\\\kern\", \"\\\\mkern\"], {\n  numArgs: 1,\n  argTypes: [\"size\"]\n}, function (context, args) {\n  return {\n    type: \"kern\",\n    dimension: args[0].value\n  };\n}); // A KaTeX logo\n\ndefineFunction(\"\\\\KaTeX\", {\n  numArgs: 0\n}, function (context) {\n  return {\n    type: \"katex\"\n  };\n});\ndefineFunction(\"\\\\phantom\", {\n  numArgs: 1\n}, function (context, args) {\n  var body = args[0];\n  return {\n    type: \"phantom\",\n    value: ordargument(body)\n  };\n}); // Math class commands except \\mathop\n\ndefineFunction([\"\\\\mathord\", \"\\\\mathbin\", \"\\\\mathrel\", \"\\\\mathopen\", \"\\\\mathclose\", \"\\\\mathpunct\", \"\\\\mathinner\"], {\n  numArgs: 1\n}, function (context, args) {\n  var body = args[0];\n  return {\n    type: \"mclass\",\n    mclass: \"m\" + context.funcName.substr(5),\n    value: ordargument(body)\n  };\n}); // Build a relation by placing one symbol on top of another\n\ndefineFunction(\"\\\\stackrel\", {\n  numArgs: 2\n}, function (context, args) {\n  var top = args[0];\n  var bottom = args[1];\n  var bottomop = new ParseNode(\"op\", {\n    type: \"op\",\n    limits: true,\n    alwaysHandleSupSub: true,\n    symbol: false,\n    value: ordargument(bottom)\n  }, bottom.mode);\n  var supsub = new ParseNode(\"supsub\", {\n    base: bottomop,\n    sup: top,\n    sub: null\n  }, top.mode);\n  return {\n    type: \"mclass\",\n    mclass: \"mrel\",\n    value: [supsub]\n  };\n}); // \\mod-type functions\n\ndefineFunction(\"\\\\bmod\", {\n  numArgs: 0\n}, function (context, args) {\n  return {\n    type: \"mod\",\n    modType: \"bmod\",\n    value: null\n  };\n});\ndefineFunction([\"\\\\pod\", \"\\\\pmod\", \"\\\\mod\"], {\n  numArgs: 1\n}, function (context, args) {\n  var body = args[0];\n  return {\n    type: \"mod\",\n    modType: context.funcName.substr(1),\n    value: ordargument(body)\n  };\n}); // Extra data needed for the delimiter handler down below\n\nvar delimiterSizes = {\n  \"\\\\bigl\": {\n    mclass: \"mopen\",\n    size: 1\n  },\n  \"\\\\Bigl\": {\n    mclass: \"mopen\",\n    size: 2\n  },\n  \"\\\\biggl\": {\n    mclass: \"mopen\",\n    size: 3\n  },\n  \"\\\\Biggl\": {\n    mclass: \"mopen\",\n    size: 4\n  },\n  \"\\\\bigr\": {\n    mclass: \"mclose\",\n    size: 1\n  },\n  \"\\\\Bigr\": {\n    mclass: \"mclose\",\n    size: 2\n  },\n  \"\\\\biggr\": {\n    mclass: \"mclose\",\n    size: 3\n  },\n  \"\\\\Biggr\": {\n    mclass: \"mclose\",\n    size: 4\n  },\n  \"\\\\bigm\": {\n    mclass: \"mrel\",\n    size: 1\n  },\n  \"\\\\Bigm\": {\n    mclass: \"mrel\",\n    size: 2\n  },\n  \"\\\\biggm\": {\n    mclass: \"mrel\",\n    size: 3\n  },\n  \"\\\\Biggm\": {\n    mclass: \"mrel\",\n    size: 4\n  },\n  \"\\\\big\": {\n    mclass: \"mord\",\n    size: 1\n  },\n  \"\\\\Big\": {\n    mclass: \"mord\",\n    size: 2\n  },\n  \"\\\\bigg\": {\n    mclass: \"mord\",\n    size: 3\n  },\n  \"\\\\Bigg\": {\n    mclass: \"mord\",\n    size: 4\n  }\n};\nvar delimiters = [\"(\", \")\", \"[\", \"\\\\lbrack\", \"]\", \"\\\\rbrack\", \"\\\\{\", \"\\\\lbrace\", \"\\\\}\", \"\\\\rbrace\", \"\\\\lfloor\", \"\\\\rfloor\", \"\\\\lceil\", \"\\\\rceil\", \"<\", \">\", \"\\\\langle\", \"\\\\rangle\", \"\\\\lt\", \"\\\\gt\", \"\\\\lvert\", \"\\\\rvert\", \"\\\\lVert\", \"\\\\rVert\", \"\\\\lgroup\", \"\\\\rgroup\", \"\\\\lmoustache\", \"\\\\rmoustache\", \"/\", \"\\\\backslash\", \"|\", \"\\\\vert\", \"\\\\|\", \"\\\\Vert\", \"\\\\uparrow\", \"\\\\Uparrow\", \"\\\\downarrow\", \"\\\\Downarrow\", \"\\\\updownarrow\", \"\\\\Updownarrow\", \".\"];\nvar fontAliases = {\n  \"\\\\Bbb\": \"\\\\mathbb\",\n  \"\\\\bold\": \"\\\\mathbf\",\n  \"\\\\frak\": \"\\\\mathfrak\"\n}; // Single-argument color functions\n\ndefineFunction([\"\\\\blue\", \"\\\\orange\", \"\\\\pink\", \"\\\\red\", \"\\\\green\", \"\\\\gray\", \"\\\\purple\", \"\\\\blueA\", \"\\\\blueB\", \"\\\\blueC\", \"\\\\blueD\", \"\\\\blueE\", \"\\\\tealA\", \"\\\\tealB\", \"\\\\tealC\", \"\\\\tealD\", \"\\\\tealE\", \"\\\\greenA\", \"\\\\greenB\", \"\\\\greenC\", \"\\\\greenD\", \"\\\\greenE\", \"\\\\goldA\", \"\\\\goldB\", \"\\\\goldC\", \"\\\\goldD\", \"\\\\goldE\", \"\\\\redA\", \"\\\\redB\", \"\\\\redC\", \"\\\\redD\", \"\\\\redE\", \"\\\\maroonA\", \"\\\\maroonB\", \"\\\\maroonC\", \"\\\\maroonD\", \"\\\\maroonE\", \"\\\\purpleA\", \"\\\\purpleB\", \"\\\\purpleC\", \"\\\\purpleD\", \"\\\\purpleE\", \"\\\\mintA\", \"\\\\mintB\", \"\\\\mintC\", \"\\\\grayA\", \"\\\\grayB\", \"\\\\grayC\", \"\\\\grayD\", \"\\\\grayE\", \"\\\\grayF\", \"\\\\grayG\", \"\\\\grayH\", \"\\\\grayI\", \"\\\\kaBlue\", \"\\\\kaGreen\"], {\n  numArgs: 1,\n  allowedInText: true,\n  greediness: 3\n}, function (context, args) {\n  var body = args[0];\n  return {\n    type: \"color\",\n    color: \"katex-\" + context.funcName.slice(1),\n    value: ordargument(body)\n  };\n}); // There are 2 flags for operators; whether they produce limits in\n// displaystyle, and whether they are symbols and should grow in\n// displaystyle. These four groups cover the four possible choices.\n// No limits, not symbols\n\ndefineFunction([\"\\\\arcsin\", \"\\\\arccos\", \"\\\\arctan\", \"\\\\arg\", \"\\\\cos\", \"\\\\cosh\", \"\\\\cot\", \"\\\\coth\", \"\\\\csc\", \"\\\\deg\", \"\\\\dim\", \"\\\\exp\", \"\\\\hom\", \"\\\\ker\", \"\\\\lg\", \"\\\\ln\", \"\\\\log\", \"\\\\sec\", \"\\\\sin\", \"\\\\sinh\", \"\\\\tan\", \"\\\\tanh\"], {\n  numArgs: 0\n}, function (context) {\n  return {\n    type: \"op\",\n    limits: false,\n    symbol: false,\n    body: context.funcName\n  };\n}); // Limits, not symbols\n\ndefineFunction([\"\\\\det\", \"\\\\gcd\", \"\\\\inf\", \"\\\\lim\", \"\\\\liminf\", \"\\\\limsup\", \"\\\\max\", \"\\\\min\", \"\\\\Pr\", \"\\\\sup\"], {\n  numArgs: 0\n}, function (context) {\n  return {\n    type: \"op\",\n    limits: true,\n    symbol: false,\n    body: context.funcName\n  };\n}); // No limits, symbols\n\ndefineFunction([\"\\\\int\", \"\\\\iint\", \"\\\\iiint\", \"\\\\oint\"], {\n  numArgs: 0\n}, function (context) {\n  return {\n    type: \"op\",\n    limits: false,\n    symbol: true,\n    body: context.funcName\n  };\n}); // Limits, symbols\n\ndefineFunction([\"\\\\coprod\", \"\\\\bigvee\", \"\\\\bigwedge\", \"\\\\biguplus\", \"\\\\bigcap\", \"\\\\bigcup\", \"\\\\intop\", \"\\\\prod\", \"\\\\sum\", \"\\\\bigotimes\", \"\\\\bigoplus\", \"\\\\bigodot\", \"\\\\bigsqcup\", \"\\\\smallint\"], {\n  numArgs: 0\n}, function (context) {\n  return {\n    type: \"op\",\n    limits: true,\n    symbol: true,\n    body: context.funcName\n  };\n}); // \\mathop class command\n\ndefineFunction(\"\\\\mathop\", {\n  numArgs: 1\n}, function (context, args) {\n  var body = args[0];\n  return {\n    type: \"op\",\n    limits: false,\n    symbol: false,\n    value: ordargument(body)\n  };\n}); // Fractions\n\ndefineFunction([\"\\\\dfrac\", \"\\\\frac\", \"\\\\tfrac\", \"\\\\dbinom\", \"\\\\binom\", \"\\\\tbinom\", \"\\\\\\\\atopfrac\" // can’t be entered directly\n], {\n  numArgs: 2,\n  greediness: 2\n}, function (context, args) {\n  var numer = args[0];\n  var denom = args[1];\n  var hasBarLine;\n  var leftDelim = null;\n  var rightDelim = null;\n  var size = \"auto\";\n\n  switch (context.funcName) {\n    case \"\\\\dfrac\":\n    case \"\\\\frac\":\n    case \"\\\\tfrac\":\n      hasBarLine = true;\n      break;\n\n    case \"\\\\\\\\atopfrac\":\n      hasBarLine = false;\n      break;\n\n    case \"\\\\dbinom\":\n    case \"\\\\binom\":\n    case \"\\\\tbinom\":\n      hasBarLine = false;\n      leftDelim = \"(\";\n      rightDelim = \")\";\n      break;\n\n    default:\n      throw new Error(\"Unrecognized genfrac command\");\n  }\n\n  switch (context.funcName) {\n    case \"\\\\dfrac\":\n    case \"\\\\dbinom\":\n      size = \"display\";\n      break;\n\n    case \"\\\\tfrac\":\n    case \"\\\\tbinom\":\n      size = \"text\";\n      break;\n  }\n\n  return {\n    type: \"genfrac\",\n    numer: numer,\n    denom: denom,\n    hasBarLine: hasBarLine,\n    leftDelim: leftDelim,\n    rightDelim: rightDelim,\n    size: size\n  };\n}); // Left and right overlap functions\n\ndefineFunction([\"\\\\llap\", \"\\\\rlap\"], {\n  numArgs: 1,\n  allowedInText: true\n}, function (context, args) {\n  var body = args[0];\n  return {\n    type: context.funcName.slice(1),\n    body: body\n  };\n}); // Delimiter functions\n\nvar checkDelimiter = function (delim, context) {\n  if (utils.contains(delimiters, delim.value)) {\n    return delim;\n  } else {\n    throw new ParseError(\"Invalid delimiter: '\" + delim.value + \"' after '\" + context.funcName + \"'\", delim);\n  }\n};\n\ndefineFunction([\"\\\\bigl\", \"\\\\Bigl\", \"\\\\biggl\", \"\\\\Biggl\", \"\\\\bigr\", \"\\\\Bigr\", \"\\\\biggr\", \"\\\\Biggr\", \"\\\\bigm\", \"\\\\Bigm\", \"\\\\biggm\", \"\\\\Biggm\", \"\\\\big\", \"\\\\Big\", \"\\\\bigg\", \"\\\\Bigg\"], {\n  numArgs: 1\n}, function (context, args) {\n  var delim = checkDelimiter(args[0], context);\n  return {\n    type: \"delimsizing\",\n    size: delimiterSizes[context.funcName].size,\n    mclass: delimiterSizes[context.funcName].mclass,\n    value: delim.value\n  };\n});\ndefineFunction([\"\\\\left\", \"\\\\right\"], {\n  numArgs: 1\n}, function (context, args) {\n  var delim = checkDelimiter(args[0], context); // \\left and \\right are caught somewhere in Parser.js, which is\n  // why this data doesn't match what is in buildHTML.\n\n  return {\n    type: \"leftright\",\n    value: delim.value\n  };\n});\ndefineFunction(\"\\\\middle\", {\n  numArgs: 1\n}, function (context, args) {\n  var delim = checkDelimiter(args[0], context);\n\n  if (!context.parser.leftrightDepth) {\n    throw new ParseError(\"\\\\middle without preceding \\\\left\", delim);\n  }\n\n  return {\n    type: \"middle\",\n    value: delim.value\n  };\n}); // Sizing functions (handled in Parser.js explicitly, hence no handler)\n\ndefineFunction([\"\\\\tiny\", \"\\\\scriptsize\", \"\\\\footnotesize\", \"\\\\small\", \"\\\\normalsize\", \"\\\\large\", \"\\\\Large\", \"\\\\LARGE\", \"\\\\huge\", \"\\\\Huge\"], 0, null); // Style changing functions (handled in Parser.js explicitly, hence no\n// handler)\n\ndefineFunction([\"\\\\displaystyle\", \"\\\\textstyle\", \"\\\\scriptstyle\", \"\\\\scriptscriptstyle\"], 0, null);\ndefineFunction([// styles\n\"\\\\mathrm\", \"\\\\mathit\", \"\\\\mathbf\", // families\n\"\\\\mathbb\", \"\\\\mathcal\", \"\\\\mathfrak\", \"\\\\mathscr\", \"\\\\mathsf\", \"\\\\mathtt\", // aliases\n\"\\\\Bbb\", \"\\\\bold\", \"\\\\frak\"], {\n  numArgs: 1,\n  greediness: 2\n}, function (context, args) {\n  var body = args[0];\n  var func = context.funcName;\n\n  if (func in fontAliases) {\n    func = fontAliases[func];\n  }\n\n  return {\n    type: \"font\",\n    font: func.slice(1),\n    body: body\n  };\n}); // Accents\n\ndefineFunction([\"\\\\acute\", \"\\\\grave\", \"\\\\ddot\", \"\\\\tilde\", \"\\\\bar\", \"\\\\breve\", \"\\\\check\", \"\\\\hat\", \"\\\\vec\", \"\\\\dot\" // We don't support expanding accents yet\n// \"\\\\widetilde\", \"\\\\widehat\"\n], {\n  numArgs: 1\n}, function (context, args) {\n  var base = args[0];\n  return {\n    type: \"accent\",\n    accent: context.funcName,\n    base: base\n  };\n}); // Infix generalized fractions\n\ndefineFunction([\"\\\\over\", \"\\\\choose\", \"\\\\atop\"], {\n  numArgs: 0,\n  infix: true\n}, function (context) {\n  var replaceWith;\n\n  switch (context.funcName) {\n    case \"\\\\over\":\n      replaceWith = \"\\\\frac\";\n      break;\n\n    case \"\\\\choose\":\n      replaceWith = \"\\\\binom\";\n      break;\n\n    case \"\\\\atop\":\n      replaceWith = \"\\\\\\\\atopfrac\";\n      break;\n\n    default:\n      throw new Error(\"Unrecognized infix genfrac command\");\n  }\n\n  return {\n    type: \"infix\",\n    replaceWith: replaceWith,\n    token: context.token\n  };\n}); // Row breaks for aligned data\n\ndefineFunction([\"\\\\\\\\\", \"\\\\cr\"], {\n  numArgs: 0,\n  numOptionalArgs: 1,\n  argTypes: [\"size\"]\n}, function (context, args) {\n  var size = args[0];\n  return {\n    type: \"cr\",\n    size: size\n  };\n}); // Environment delimiters\n\ndefineFunction([\"\\\\begin\", \"\\\\end\"], {\n  numArgs: 1,\n  argTypes: [\"text\"]\n}, function (context, args) {\n  var nameGroup = args[0];\n\n  if (nameGroup.type !== \"ordgroup\") {\n    throw new ParseError(\"Invalid environment name\", nameGroup);\n  }\n\n  var name = \"\";\n\n  for (var i = 0; i < nameGroup.value.length; ++i) {\n    name += nameGroup.value[i].value;\n  }\n\n  return {\n    type: \"environment\",\n    name: name,\n    nameGroup: nameGroup\n  };\n});","map":{"version":3,"sources":["/Users/justinf/perseus-configured/node_modules/katex/src/functions.js"],"names":["utils","require","ParseError","parseData","ParseNode","defineFunction","names","props","handler","numArgs","data","argTypes","greediness","undefined","allowedInText","numOptionalArgs","infix","i","length","module","exports","ordargument","arg","type","value","context","args","index","body","textFunctionStyles","style","funcName","color","shift","width","height","dimension","mclass","substr","top","bottom","bottomop","limits","alwaysHandleSupSub","symbol","mode","supsub","base","sup","sub","modType","delimiterSizes","size","delimiters","fontAliases","slice","numer","denom","hasBarLine","leftDelim","rightDelim","Error","checkDelimiter","delim","contains","parser","leftrightDepth","func","font","accent","replaceWith","token","nameGroup","name"],"mappings":"AAAA,IAAIA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAAnB;;AACA,IAAIC,UAAU,GAAGD,OAAO,CAAC,cAAD,CAAxB;;AACA,IAAIE,SAAS,GAAGF,OAAO,CAAC,aAAD,CAAvB;;AACA,IAAIG,SAAS,GAAGD,SAAS,CAACC,SAA1B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,cAAT,CAAwBC,KAAxB,EAA+BC,KAA/B,EAAsCC,OAAtC,EAA+C;AAC3C,MAAI,OAAOF,KAAP,KAAiB,QAArB,EAA+B;AAC3BA,IAAAA,KAAK,GAAG,CAACA,KAAD,CAAR;AACH;;AACD,MAAI,OAAOC,KAAP,KAAiB,QAArB,EAA+B;AAC3BA,IAAAA,KAAK,GAAG;AAAEE,MAAAA,OAAO,EAAEF;AAAX,KAAR;AACH,GAN0C,CAO3C;;;AACA,MAAIG,IAAI,GAAG;AACPD,IAAAA,OAAO,EAAEF,KAAK,CAACE,OADR;AAEPE,IAAAA,QAAQ,EAAEJ,KAAK,CAACI,QAFT;AAGPC,IAAAA,UAAU,EAAGL,KAAK,CAACK,UAAN,KAAqBC,SAAtB,GAAmC,CAAnC,GAAuCN,KAAK,CAACK,UAHlD;AAIPE,IAAAA,aAAa,EAAE,CAAC,CAACP,KAAK,CAACO,aAJhB;AAKPC,IAAAA,eAAe,EAAER,KAAK,CAACQ,eAAN,IAAyB,CALnC;AAMPC,IAAAA,KAAK,EAAE,CAAC,CAACT,KAAK,CAACS,KANR;AAOPR,IAAAA,OAAO,EAAEA;AAPF,GAAX;;AASA,OAAK,IAAIS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,KAAK,CAACY,MAA1B,EAAkC,EAAED,CAApC,EAAuC;AACnCE,IAAAA,MAAM,CAACC,OAAP,CAAed,KAAK,CAACW,CAAD,CAApB,IAA2BP,IAA3B;AACH;AACJ,C,CAED;AACA;;;AACA,IAAIW,WAAW,GAAG,UAASC,GAAT,EAAc;AAC5B,MAAIA,GAAG,CAACC,IAAJ,KAAa,UAAjB,EAA6B;AACzB,WAAOD,GAAG,CAACE,KAAX;AACH,GAFD,MAEO;AACH,WAAO,CAACF,GAAD,CAAP;AACH;AACJ,CAND,C,CAQA;;;AACAjB,cAAc,CAAC,QAAD,EAAW;AACrBI,EAAAA,OAAO,EAAE,CADY;AAErBM,EAAAA,eAAe,EAAE;AAFI,CAAX,EAGX,UAASU,OAAT,EAAkBC,IAAlB,EAAwB;AACvB,MAAIC,KAAK,GAAGD,IAAI,CAAC,CAAD,CAAhB;AACA,MAAIE,IAAI,GAAGF,IAAI,CAAC,CAAD,CAAf;AACA,SAAO;AACHH,IAAAA,IAAI,EAAE,MADH;AAEHK,IAAAA,IAAI,EAAEA,IAFH;AAGHD,IAAAA,KAAK,EAAEA;AAHJ,GAAP;AAKH,CAXa,CAAd,C,CAaA;;AACA,IAAIE,kBAAkB,GAAG;AACrB,YAAUhB,SADW;AACA,cAAY,QADZ;AACsB,cAAY,QADlC;AAErB,cAAY,QAFS;AAEC,kBAAgB,QAFjB;AAE2B,cAAY,QAFvC;AAGrB,cAAY;AAHS,CAAzB;AAMAR,cAAc,CAAC,CACX,QADW,EACD,UADC,EACW,UADX,EACuB,UADvB,EACmC,cADnC,EAEX,UAFW,EAEC,UAFD,CAAD,EAGX;AACCI,EAAAA,OAAO,EAAE,CADV;AAECE,EAAAA,QAAQ,EAAE,CAAC,MAAD,CAFX;AAGCC,EAAAA,UAAU,EAAE,CAHb;AAICE,EAAAA,aAAa,EAAE;AAJhB,CAHW,EAQX,UAASW,OAAT,EAAkBC,IAAlB,EAAwB;AACvB,MAAIE,IAAI,GAAGF,IAAI,CAAC,CAAD,CAAf;AACA,SAAO;AACHH,IAAAA,IAAI,EAAE,MADH;AAEHK,IAAAA,IAAI,EAAEP,WAAW,CAACO,IAAD,CAFd;AAGHE,IAAAA,KAAK,EAAED,kBAAkB,CAACJ,OAAO,CAACM,QAAT;AAHtB,GAAP;AAKH,CAfa,CAAd,C,CAiBA;;AACA1B,cAAc,CAAC,SAAD,EAAY;AACtBI,EAAAA,OAAO,EAAE,CADa;AAEtBK,EAAAA,aAAa,EAAE,IAFO;AAGtBF,EAAAA,UAAU,EAAE,CAHU;AAItBD,EAAAA,QAAQ,EAAE,CAAC,OAAD,EAAU,UAAV;AAJY,CAAZ,EAKX,UAASc,OAAT,EAAkBC,IAAlB,EAAwB;AACvB,MAAIM,KAAK,GAAGN,IAAI,CAAC,CAAD,CAAhB;AACA,MAAIE,IAAI,GAAGF,IAAI,CAAC,CAAD,CAAf;AACA,SAAO;AACHH,IAAAA,IAAI,EAAE,OADH;AAEHS,IAAAA,KAAK,EAAEA,KAAK,CAACR,KAFV;AAGHA,IAAAA,KAAK,EAAEH,WAAW,CAACO,IAAD;AAHf,GAAP;AAKH,CAba,CAAd,C,CAeA;;AACAvB,cAAc,CAAC,YAAD,EAAe;AACzBI,EAAAA,OAAO,EAAE;AADgB,CAAf,EAEX,UAASgB,OAAT,EAAkBC,IAAlB,EAAwB;AACvB,MAAIE,IAAI,GAAGF,IAAI,CAAC,CAAD,CAAf;AACA,SAAO;AACHH,IAAAA,IAAI,EAAE,UADH;AAEHK,IAAAA,IAAI,EAAEA;AAFH,GAAP;AAIH,CARa,CAAd,C,CAUA;;AACAvB,cAAc,CAAC,aAAD,EAAgB;AAC1BI,EAAAA,OAAO,EAAE;AADiB,CAAhB,EAEX,UAASgB,OAAT,EAAkBC,IAAlB,EAAwB;AACvB,MAAIE,IAAI,GAAGF,IAAI,CAAC,CAAD,CAAf;AACA,SAAO;AACHH,IAAAA,IAAI,EAAE,WADH;AAEHK,IAAAA,IAAI,EAAEA;AAFH,GAAP;AAIH,CARa,CAAd,C,CAUA;;AACAvB,cAAc,CAAC,QAAD,EAAW;AACrBI,EAAAA,OAAO,EAAE,CADY;AAErBM,EAAAA,eAAe,EAAE,CAFI;AAGrBJ,EAAAA,QAAQ,EAAE,CAAC,MAAD,EAAS,MAAT,EAAiB,MAAjB;AAHW,CAAX,EAIX,UAASc,OAAT,EAAkBC,IAAlB,EAAwB;AACvB,MAAIO,KAAK,GAAGP,IAAI,CAAC,CAAD,CAAhB;AACA,MAAIQ,KAAK,GAAGR,IAAI,CAAC,CAAD,CAAhB;AACA,MAAIS,MAAM,GAAGT,IAAI,CAAC,CAAD,CAAjB;AACA,SAAO;AACHH,IAAAA,IAAI,EAAE,MADH;AAEHU,IAAAA,KAAK,EAAEA,KAAK,IAAIA,KAAK,CAACT,KAFnB;AAGHU,IAAAA,KAAK,EAAEA,KAAK,CAACV,KAHV;AAIHW,IAAAA,MAAM,EAAEA,MAAM,CAACX;AAJZ,GAAP;AAMH,CAda,CAAd,C,CAgBA;AACA;;AACAnB,cAAc,CAAC,CAAC,QAAD,EAAW,SAAX,CAAD,EAAwB;AAClCI,EAAAA,OAAO,EAAE,CADyB;AAElCE,EAAAA,QAAQ,EAAE,CAAC,MAAD;AAFwB,CAAxB,EAGX,UAASc,OAAT,EAAkBC,IAAlB,EAAwB;AACvB,SAAO;AACHH,IAAAA,IAAI,EAAE,MADH;AAEHa,IAAAA,SAAS,EAAEV,IAAI,CAAC,CAAD,CAAJ,CAAQF;AAFhB,GAAP;AAIH,CARa,CAAd,C,CAUA;;AACAnB,cAAc,CAAC,SAAD,EAAY;AACtBI,EAAAA,OAAO,EAAE;AADa,CAAZ,EAEX,UAASgB,OAAT,EAAkB;AACjB,SAAO;AACHF,IAAAA,IAAI,EAAE;AADH,GAAP;AAGH,CANa,CAAd;AAQAlB,cAAc,CAAC,WAAD,EAAc;AACxBI,EAAAA,OAAO,EAAE;AADe,CAAd,EAEX,UAASgB,OAAT,EAAkBC,IAAlB,EAAwB;AACvB,MAAIE,IAAI,GAAGF,IAAI,CAAC,CAAD,CAAf;AACA,SAAO;AACHH,IAAAA,IAAI,EAAE,SADH;AAEHC,IAAAA,KAAK,EAAEH,WAAW,CAACO,IAAD;AAFf,GAAP;AAIH,CARa,CAAd,C,CAUA;;AACAvB,cAAc,CAAC,CACX,WADW,EACE,WADF,EACe,WADf,EAC4B,YAD5B,EAEX,aAFW,EAEI,aAFJ,EAEmB,aAFnB,CAAD,EAGX;AACCI,EAAAA,OAAO,EAAE;AADV,CAHW,EAKX,UAASgB,OAAT,EAAkBC,IAAlB,EAAwB;AACvB,MAAIE,IAAI,GAAGF,IAAI,CAAC,CAAD,CAAf;AACA,SAAO;AACHH,IAAAA,IAAI,EAAE,QADH;AAEHc,IAAAA,MAAM,EAAE,MAAMZ,OAAO,CAACM,QAAR,CAAiBO,MAAjB,CAAwB,CAAxB,CAFX;AAGHd,IAAAA,KAAK,EAAEH,WAAW,CAACO,IAAD;AAHf,GAAP;AAKH,CAZa,CAAd,C,CAcA;;AACAvB,cAAc,CAAC,YAAD,EAAe;AACzBI,EAAAA,OAAO,EAAE;AADgB,CAAf,EAEX,UAASgB,OAAT,EAAkBC,IAAlB,EAAwB;AACvB,MAAIa,GAAG,GAAGb,IAAI,CAAC,CAAD,CAAd;AACA,MAAIc,MAAM,GAAGd,IAAI,CAAC,CAAD,CAAjB;AAEA,MAAIe,QAAQ,GAAG,IAAIrC,SAAJ,CAAc,IAAd,EAAoB;AAC/BmB,IAAAA,IAAI,EAAE,IADyB;AAE/BmB,IAAAA,MAAM,EAAE,IAFuB;AAG/BC,IAAAA,kBAAkB,EAAE,IAHW;AAI/BC,IAAAA,MAAM,EAAE,KAJuB;AAK/BpB,IAAAA,KAAK,EAAEH,WAAW,CAACmB,MAAD;AALa,GAApB,EAMZA,MAAM,CAACK,IANK,CAAf;AAQA,MAAIC,MAAM,GAAG,IAAI1C,SAAJ,CAAc,QAAd,EAAwB;AACjC2C,IAAAA,IAAI,EAAEN,QAD2B;AAEjCO,IAAAA,GAAG,EAAET,GAF4B;AAGjCU,IAAAA,GAAG,EAAE;AAH4B,GAAxB,EAIVV,GAAG,CAACM,IAJM,CAAb;AAMA,SAAO;AACHtB,IAAAA,IAAI,EAAE,QADH;AAEHc,IAAAA,MAAM,EAAE,MAFL;AAGHb,IAAAA,KAAK,EAAE,CAACsB,MAAD;AAHJ,GAAP;AAKH,CAzBa,CAAd,C,CA2BA;;AACAzC,cAAc,CAAC,QAAD,EAAW;AACrBI,EAAAA,OAAO,EAAE;AADY,CAAX,EAEX,UAASgB,OAAT,EAAkBC,IAAlB,EAAwB;AACvB,SAAO;AACHH,IAAAA,IAAI,EAAE,KADH;AAEH2B,IAAAA,OAAO,EAAE,MAFN;AAGH1B,IAAAA,KAAK,EAAE;AAHJ,GAAP;AAKH,CARa,CAAd;AAUAnB,cAAc,CAAC,CAAC,OAAD,EAAU,QAAV,EAAoB,OAApB,CAAD,EAA+B;AACzCI,EAAAA,OAAO,EAAE;AADgC,CAA/B,EAEX,UAASgB,OAAT,EAAkBC,IAAlB,EAAwB;AACvB,MAAIE,IAAI,GAAGF,IAAI,CAAC,CAAD,CAAf;AACA,SAAO;AACHH,IAAAA,IAAI,EAAE,KADH;AAEH2B,IAAAA,OAAO,EAAEzB,OAAO,CAACM,QAAR,CAAiBO,MAAjB,CAAwB,CAAxB,CAFN;AAGHd,IAAAA,KAAK,EAAEH,WAAW,CAACO,IAAD;AAHf,GAAP;AAKH,CATa,CAAd,C,CAWA;;AACA,IAAIuB,cAAc,GAAG;AACjB,YAAW;AAACd,IAAAA,MAAM,EAAE,OAAT;AAAqBe,IAAAA,IAAI,EAAE;AAA3B,GADM;AAEjB,YAAW;AAACf,IAAAA,MAAM,EAAE,OAAT;AAAqBe,IAAAA,IAAI,EAAE;AAA3B,GAFM;AAGjB,aAAW;AAACf,IAAAA,MAAM,EAAE,OAAT;AAAqBe,IAAAA,IAAI,EAAE;AAA3B,GAHM;AAIjB,aAAW;AAACf,IAAAA,MAAM,EAAE,OAAT;AAAqBe,IAAAA,IAAI,EAAE;AAA3B,GAJM;AAKjB,YAAW;AAACf,IAAAA,MAAM,EAAE,QAAT;AAAqBe,IAAAA,IAAI,EAAE;AAA3B,GALM;AAMjB,YAAW;AAACf,IAAAA,MAAM,EAAE,QAAT;AAAqBe,IAAAA,IAAI,EAAE;AAA3B,GANM;AAOjB,aAAW;AAACf,IAAAA,MAAM,EAAE,QAAT;AAAqBe,IAAAA,IAAI,EAAE;AAA3B,GAPM;AAQjB,aAAW;AAACf,IAAAA,MAAM,EAAE,QAAT;AAAqBe,IAAAA,IAAI,EAAE;AAA3B,GARM;AASjB,YAAW;AAACf,IAAAA,MAAM,EAAE,MAAT;AAAqBe,IAAAA,IAAI,EAAE;AAA3B,GATM;AAUjB,YAAW;AAACf,IAAAA,MAAM,EAAE,MAAT;AAAqBe,IAAAA,IAAI,EAAE;AAA3B,GAVM;AAWjB,aAAW;AAACf,IAAAA,MAAM,EAAE,MAAT;AAAqBe,IAAAA,IAAI,EAAE;AAA3B,GAXM;AAYjB,aAAW;AAACf,IAAAA,MAAM,EAAE,MAAT;AAAqBe,IAAAA,IAAI,EAAE;AAA3B,GAZM;AAajB,WAAW;AAACf,IAAAA,MAAM,EAAE,MAAT;AAAqBe,IAAAA,IAAI,EAAE;AAA3B,GAbM;AAcjB,WAAW;AAACf,IAAAA,MAAM,EAAE,MAAT;AAAqBe,IAAAA,IAAI,EAAE;AAA3B,GAdM;AAejB,YAAW;AAACf,IAAAA,MAAM,EAAE,MAAT;AAAqBe,IAAAA,IAAI,EAAE;AAA3B,GAfM;AAgBjB,YAAW;AAACf,IAAAA,MAAM,EAAE,MAAT;AAAqBe,IAAAA,IAAI,EAAE;AAA3B;AAhBM,CAArB;AAmBA,IAAIC,UAAU,GAAG,CACb,GADa,EACR,GADQ,EACH,GADG,EACE,UADF,EACc,GADd,EACmB,UADnB,EAEb,KAFa,EAEN,UAFM,EAEM,KAFN,EAEa,UAFb,EAGb,UAHa,EAGD,UAHC,EAGW,SAHX,EAGsB,SAHtB,EAIb,GAJa,EAIR,GAJQ,EAIH,UAJG,EAIS,UAJT,EAIqB,MAJrB,EAI6B,MAJ7B,EAKb,SALa,EAKF,SALE,EAKS,SALT,EAKoB,SALpB,EAMb,UANa,EAMD,UANC,EAMW,cANX,EAM2B,cAN3B,EAOb,GAPa,EAOR,aAPQ,EAQb,GARa,EAQR,QARQ,EAQE,KARF,EAQS,QART,EASb,WATa,EASA,WATA,EAUb,aAVa,EAUE,aAVF,EAWb,eAXa,EAWI,eAXJ,EAYb,GAZa,CAAjB;AAeA,IAAIC,WAAW,GAAG;AACd,WAAS,UADK;AAEd,YAAU,UAFI;AAGd,YAAU;AAHI,CAAlB,C,CAMA;;AACAjD,cAAc,CAAC,CACX,QADW,EACD,UADC,EACW,QADX,EACqB,OADrB,EAEX,SAFW,EAEA,QAFA,EAEU,UAFV,EAGX,SAHW,EAGA,SAHA,EAGW,SAHX,EAGsB,SAHtB,EAGiC,SAHjC,EAIX,SAJW,EAIA,SAJA,EAIW,SAJX,EAIsB,SAJtB,EAIiC,SAJjC,EAKX,UALW,EAKC,UALD,EAKa,UALb,EAKyB,UALzB,EAKqC,UALrC,EAMX,SANW,EAMA,SANA,EAMW,SANX,EAMsB,SANtB,EAMiC,SANjC,EAOX,QAPW,EAOD,QAPC,EAOS,QAPT,EAOmB,QAPnB,EAO6B,QAP7B,EAQX,WARW,EAQE,WARF,EAQe,WARf,EAQ4B,WAR5B,EAQyC,WARzC,EASX,WATW,EASE,WATF,EASe,WATf,EAS4B,WAT5B,EASyC,WATzC,EAUX,SAVW,EAUA,SAVA,EAUW,SAVX,EAWX,SAXW,EAWA,SAXA,EAWW,SAXX,EAWsB,SAXtB,EAWiC,SAXjC,EAYX,SAZW,EAYA,SAZA,EAYW,SAZX,EAYsB,SAZtB,EAaX,UAbW,EAaC,WAbD,CAAD,EAcX;AACCI,EAAAA,OAAO,EAAE,CADV;AAECK,EAAAA,aAAa,EAAE,IAFhB;AAGCF,EAAAA,UAAU,EAAE;AAHb,CAdW,EAkBX,UAASa,OAAT,EAAkBC,IAAlB,EAAwB;AACvB,MAAIE,IAAI,GAAGF,IAAI,CAAC,CAAD,CAAf;AACA,SAAO;AACHH,IAAAA,IAAI,EAAE,OADH;AAEHS,IAAAA,KAAK,EAAE,WAAWP,OAAO,CAACM,QAAR,CAAiBwB,KAAjB,CAAuB,CAAvB,CAFf;AAGH/B,IAAAA,KAAK,EAAEH,WAAW,CAACO,IAAD;AAHf,GAAP;AAKH,CAzBa,CAAd,C,CA2BA;AACA;AACA;AAEA;;AACAvB,cAAc,CAAC,CACX,UADW,EACC,UADD,EACa,UADb,EACyB,OADzB,EACkC,OADlC,EAC2C,QAD3C,EAEX,OAFW,EAEF,QAFE,EAEQ,OAFR,EAEiB,OAFjB,EAE0B,OAF1B,EAEmC,OAFnC,EAE4C,OAF5C,EAGX,OAHW,EAGF,MAHE,EAGM,MAHN,EAGc,OAHd,EAGuB,OAHvB,EAGgC,OAHhC,EAGyC,QAHzC,EAIX,OAJW,EAIF,QAJE,CAAD,EAKX;AACCI,EAAAA,OAAO,EAAE;AADV,CALW,EAOX,UAASgB,OAAT,EAAkB;AACjB,SAAO;AACHF,IAAAA,IAAI,EAAE,IADH;AAEHmB,IAAAA,MAAM,EAAE,KAFL;AAGHE,IAAAA,MAAM,EAAE,KAHL;AAIHhB,IAAAA,IAAI,EAAEH,OAAO,CAACM;AAJX,GAAP;AAMH,CAda,CAAd,C,CAgBA;;AACA1B,cAAc,CAAC,CACX,OADW,EACF,OADE,EACO,OADP,EACgB,OADhB,EACyB,UADzB,EACqC,UADrC,EACiD,OADjD,EAEX,OAFW,EAEF,MAFE,EAEM,OAFN,CAAD,EAGX;AACCI,EAAAA,OAAO,EAAE;AADV,CAHW,EAKX,UAASgB,OAAT,EAAkB;AACjB,SAAO;AACHF,IAAAA,IAAI,EAAE,IADH;AAEHmB,IAAAA,MAAM,EAAE,IAFL;AAGHE,IAAAA,MAAM,EAAE,KAHL;AAIHhB,IAAAA,IAAI,EAAEH,OAAO,CAACM;AAJX,GAAP;AAMH,CAZa,CAAd,C,CAcA;;AACA1B,cAAc,CAAC,CACX,OADW,EACF,QADE,EACQ,SADR,EACmB,QADnB,CAAD,EAEX;AACCI,EAAAA,OAAO,EAAE;AADV,CAFW,EAIX,UAASgB,OAAT,EAAkB;AACjB,SAAO;AACHF,IAAAA,IAAI,EAAE,IADH;AAEHmB,IAAAA,MAAM,EAAE,KAFL;AAGHE,IAAAA,MAAM,EAAE,IAHL;AAIHhB,IAAAA,IAAI,EAAEH,OAAO,CAACM;AAJX,GAAP;AAMH,CAXa,CAAd,C,CAaA;;AACA1B,cAAc,CAAC,CACX,UADW,EACC,UADD,EACa,YADb,EAC2B,YAD3B,EACyC,UADzC,EAEX,UAFW,EAEC,SAFD,EAEY,QAFZ,EAEsB,OAFtB,EAE+B,aAF/B,EAGX,YAHW,EAGG,WAHH,EAGgB,YAHhB,EAG8B,YAH9B,CAAD,EAIX;AACCI,EAAAA,OAAO,EAAE;AADV,CAJW,EAMX,UAASgB,OAAT,EAAkB;AACjB,SAAO;AACHF,IAAAA,IAAI,EAAE,IADH;AAEHmB,IAAAA,MAAM,EAAE,IAFL;AAGHE,IAAAA,MAAM,EAAE,IAHL;AAIHhB,IAAAA,IAAI,EAAEH,OAAO,CAACM;AAJX,GAAP;AAMH,CAba,CAAd,C,CAeA;;AACA1B,cAAc,CAAC,UAAD,EAAa;AACvBI,EAAAA,OAAO,EAAE;AADc,CAAb,EAEX,UAASgB,OAAT,EAAkBC,IAAlB,EAAwB;AACvB,MAAIE,IAAI,GAAGF,IAAI,CAAC,CAAD,CAAf;AACA,SAAO;AACHH,IAAAA,IAAI,EAAE,IADH;AAEHmB,IAAAA,MAAM,EAAE,KAFL;AAGHE,IAAAA,MAAM,EAAE,KAHL;AAIHpB,IAAAA,KAAK,EAAEH,WAAW,CAACO,IAAD;AAJf,GAAP;AAMH,CAVa,CAAd,C,CAYA;;AACAvB,cAAc,CAAC,CACX,SADW,EACA,QADA,EACU,SADV,EAEX,UAFW,EAEC,SAFD,EAEY,UAFZ,EAGX,cAHW,CAGI;AAHJ,CAAD,EAIX;AACCI,EAAAA,OAAO,EAAE,CADV;AAECG,EAAAA,UAAU,EAAE;AAFb,CAJW,EAOX,UAASa,OAAT,EAAkBC,IAAlB,EAAwB;AACvB,MAAI8B,KAAK,GAAG9B,IAAI,CAAC,CAAD,CAAhB;AACA,MAAI+B,KAAK,GAAG/B,IAAI,CAAC,CAAD,CAAhB;AACA,MAAIgC,UAAJ;AACA,MAAIC,SAAS,GAAG,IAAhB;AACA,MAAIC,UAAU,GAAG,IAAjB;AACA,MAAIR,IAAI,GAAG,MAAX;;AAEA,UAAQ3B,OAAO,CAACM,QAAhB;AACI,SAAK,SAAL;AACA,SAAK,QAAL;AACA,SAAK,SAAL;AACI2B,MAAAA,UAAU,GAAG,IAAb;AACA;;AACJ,SAAK,cAAL;AACIA,MAAAA,UAAU,GAAG,KAAb;AACA;;AACJ,SAAK,UAAL;AACA,SAAK,SAAL;AACA,SAAK,UAAL;AACIA,MAAAA,UAAU,GAAG,KAAb;AACAC,MAAAA,SAAS,GAAG,GAAZ;AACAC,MAAAA,UAAU,GAAG,GAAb;AACA;;AACJ;AACI,YAAM,IAAIC,KAAJ,CAAU,8BAAV,CAAN;AAjBR;;AAoBA,UAAQpC,OAAO,CAACM,QAAhB;AACI,SAAK,SAAL;AACA,SAAK,UAAL;AACIqB,MAAAA,IAAI,GAAG,SAAP;AACA;;AACJ,SAAK,SAAL;AACA,SAAK,UAAL;AACIA,MAAAA,IAAI,GAAG,MAAP;AACA;AARR;;AAWA,SAAO;AACH7B,IAAAA,IAAI,EAAE,SADH;AAEHiC,IAAAA,KAAK,EAAEA,KAFJ;AAGHC,IAAAA,KAAK,EAAEA,KAHJ;AAIHC,IAAAA,UAAU,EAAEA,UAJT;AAKHC,IAAAA,SAAS,EAAEA,SALR;AAMHC,IAAAA,UAAU,EAAEA,UANT;AAOHR,IAAAA,IAAI,EAAEA;AAPH,GAAP;AASH,CAvDa,CAAd,C,CAyDA;;AACA/C,cAAc,CAAC,CAAC,QAAD,EAAW,QAAX,CAAD,EAAuB;AACjCI,EAAAA,OAAO,EAAE,CADwB;AAEjCK,EAAAA,aAAa,EAAE;AAFkB,CAAvB,EAGX,UAASW,OAAT,EAAkBC,IAAlB,EAAwB;AACvB,MAAIE,IAAI,GAAGF,IAAI,CAAC,CAAD,CAAf;AACA,SAAO;AACHH,IAAAA,IAAI,EAAEE,OAAO,CAACM,QAAR,CAAiBwB,KAAjB,CAAuB,CAAvB,CADH;AAEH3B,IAAAA,IAAI,EAAEA;AAFH,GAAP;AAIH,CATa,CAAd,C,CAWA;;AACA,IAAIkC,cAAc,GAAG,UAASC,KAAT,EAAgBtC,OAAhB,EAAyB;AAC1C,MAAIzB,KAAK,CAACgE,QAAN,CAAeX,UAAf,EAA2BU,KAAK,CAACvC,KAAjC,CAAJ,EAA6C;AACzC,WAAOuC,KAAP;AACH,GAFD,MAEO;AACH,UAAM,IAAI7D,UAAJ,CACF,yBAAyB6D,KAAK,CAACvC,KAA/B,GAAuC,WAAvC,GACAC,OAAO,CAACM,QADR,GACmB,GAFjB,EAEsBgC,KAFtB,CAAN;AAGH;AACJ,CARD;;AAUA1D,cAAc,CAAC,CACX,QADW,EACD,QADC,EACS,SADT,EACoB,SADpB,EAEX,QAFW,EAED,QAFC,EAES,SAFT,EAEoB,SAFpB,EAGX,QAHW,EAGD,QAHC,EAGS,SAHT,EAGoB,SAHpB,EAIX,OAJW,EAID,OAJC,EAIS,QAJT,EAIoB,QAJpB,CAAD,EAKX;AACCI,EAAAA,OAAO,EAAE;AADV,CALW,EAOX,UAASgB,OAAT,EAAkBC,IAAlB,EAAwB;AACvB,MAAIqC,KAAK,GAAGD,cAAc,CAACpC,IAAI,CAAC,CAAD,CAAL,EAAUD,OAAV,CAA1B;AAEA,SAAO;AACHF,IAAAA,IAAI,EAAE,aADH;AAEH6B,IAAAA,IAAI,EAAED,cAAc,CAAC1B,OAAO,CAACM,QAAT,CAAd,CAAiCqB,IAFpC;AAGHf,IAAAA,MAAM,EAAEc,cAAc,CAAC1B,OAAO,CAACM,QAAT,CAAd,CAAiCM,MAHtC;AAIHb,IAAAA,KAAK,EAAEuC,KAAK,CAACvC;AAJV,GAAP;AAMH,CAhBa,CAAd;AAkBAnB,cAAc,CAAC,CACX,QADW,EACD,SADC,CAAD,EAEX;AACCI,EAAAA,OAAO,EAAE;AADV,CAFW,EAIX,UAASgB,OAAT,EAAkBC,IAAlB,EAAwB;AACvB,MAAIqC,KAAK,GAAGD,cAAc,CAACpC,IAAI,CAAC,CAAD,CAAL,EAAUD,OAAV,CAA1B,CADuB,CAGvB;AACA;;AACA,SAAO;AACHF,IAAAA,IAAI,EAAE,WADH;AAEHC,IAAAA,KAAK,EAAEuC,KAAK,CAACvC;AAFV,GAAP;AAIH,CAba,CAAd;AAeAnB,cAAc,CAAC,UAAD,EAAa;AACvBI,EAAAA,OAAO,EAAE;AADc,CAAb,EAEX,UAASgB,OAAT,EAAkBC,IAAlB,EAAwB;AACvB,MAAIqC,KAAK,GAAGD,cAAc,CAACpC,IAAI,CAAC,CAAD,CAAL,EAAUD,OAAV,CAA1B;;AACA,MAAI,CAACA,OAAO,CAACwC,MAAR,CAAeC,cAApB,EAAoC;AAChC,UAAM,IAAIhE,UAAJ,CAAe,mCAAf,EAAoD6D,KAApD,CAAN;AACH;;AAED,SAAO;AACHxC,IAAAA,IAAI,EAAE,QADH;AAEHC,IAAAA,KAAK,EAAEuC,KAAK,CAACvC;AAFV,GAAP;AAIH,CAZa,CAAd,C,CAcA;;AACAnB,cAAc,CAAC,CACX,QADW,EACD,cADC,EACe,gBADf,EACiC,SADjC,EAEX,cAFW,EAEK,SAFL,EAEgB,SAFhB,EAE2B,SAF3B,EAEsC,QAFtC,EAEgD,QAFhD,CAAD,EAGX,CAHW,EAGR,IAHQ,CAAd,C,CAKA;AACA;;AACAA,cAAc,CAAC,CACX,gBADW,EACO,aADP,EACsB,eADtB,EAEX,qBAFW,CAAD,EAGX,CAHW,EAGR,IAHQ,CAAd;AAKAA,cAAc,CAAC,CACX;AACA,UAFW,EAEC,UAFD,EAEa,UAFb,EAIX;AACA,UALW,EAKC,WALD,EAKc,YALd,EAK4B,WAL5B,EAKyC,UALzC,EAMX,UANW,EAQX;AACA,OATW,EASF,QATE,EASQ,QATR,CAAD,EAUX;AACCI,EAAAA,OAAO,EAAE,CADV;AAECG,EAAAA,UAAU,EAAE;AAFb,CAVW,EAaX,UAASa,OAAT,EAAkBC,IAAlB,EAAwB;AACvB,MAAIE,IAAI,GAAGF,IAAI,CAAC,CAAD,CAAf;AACA,MAAIyC,IAAI,GAAG1C,OAAO,CAACM,QAAnB;;AACA,MAAIoC,IAAI,IAAIb,WAAZ,EAAyB;AACrBa,IAAAA,IAAI,GAAGb,WAAW,CAACa,IAAD,CAAlB;AACH;;AACD,SAAO;AACH5C,IAAAA,IAAI,EAAE,MADH;AAEH6C,IAAAA,IAAI,EAAED,IAAI,CAACZ,KAAL,CAAW,CAAX,CAFH;AAGH3B,IAAAA,IAAI,EAAEA;AAHH,GAAP;AAKH,CAxBa,CAAd,C,CA0BA;;AACAvB,cAAc,CAAC,CACX,SADW,EACA,SADA,EACW,QADX,EACqB,SADrB,EACgC,OADhC,EACyC,SADzC,EAEX,SAFW,EAEA,OAFA,EAES,OAFT,EAEkB,OAFlB,CAGX;AACA;AAJW,CAAD,EAKX;AACCI,EAAAA,OAAO,EAAE;AADV,CALW,EAOX,UAASgB,OAAT,EAAkBC,IAAlB,EAAwB;AACvB,MAAIqB,IAAI,GAAGrB,IAAI,CAAC,CAAD,CAAf;AACA,SAAO;AACHH,IAAAA,IAAI,EAAE,QADH;AAEH8C,IAAAA,MAAM,EAAE5C,OAAO,CAACM,QAFb;AAGHgB,IAAAA,IAAI,EAAEA;AAHH,GAAP;AAKH,CAda,CAAd,C,CAgBA;;AACA1C,cAAc,CAAC,CAAC,QAAD,EAAW,UAAX,EAAuB,QAAvB,CAAD,EAAmC;AAC7CI,EAAAA,OAAO,EAAE,CADoC;AAE7CO,EAAAA,KAAK,EAAE;AAFsC,CAAnC,EAGX,UAASS,OAAT,EAAkB;AACjB,MAAI6C,WAAJ;;AACA,UAAQ7C,OAAO,CAACM,QAAhB;AACI,SAAK,QAAL;AACIuC,MAAAA,WAAW,GAAG,QAAd;AACA;;AACJ,SAAK,UAAL;AACIA,MAAAA,WAAW,GAAG,SAAd;AACA;;AACJ,SAAK,QAAL;AACIA,MAAAA,WAAW,GAAG,cAAd;AACA;;AACJ;AACI,YAAM,IAAIT,KAAJ,CAAU,oCAAV,CAAN;AAXR;;AAaA,SAAO;AACHtC,IAAAA,IAAI,EAAE,OADH;AAEH+C,IAAAA,WAAW,EAAEA,WAFV;AAGHC,IAAAA,KAAK,EAAE9C,OAAO,CAAC8C;AAHZ,GAAP;AAKH,CAvBa,CAAd,C,CAyBA;;AACAlE,cAAc,CAAC,CAAC,MAAD,EAAS,MAAT,CAAD,EAAmB;AAC7BI,EAAAA,OAAO,EAAE,CADoB;AAE7BM,EAAAA,eAAe,EAAE,CAFY;AAG7BJ,EAAAA,QAAQ,EAAE,CAAC,MAAD;AAHmB,CAAnB,EAIX,UAASc,OAAT,EAAkBC,IAAlB,EAAwB;AACvB,MAAI0B,IAAI,GAAG1B,IAAI,CAAC,CAAD,CAAf;AACA,SAAO;AACHH,IAAAA,IAAI,EAAE,IADH;AAEH6B,IAAAA,IAAI,EAAEA;AAFH,GAAP;AAIH,CAVa,CAAd,C,CAYA;;AACA/C,cAAc,CAAC,CAAC,SAAD,EAAY,OAAZ,CAAD,EAAuB;AACjCI,EAAAA,OAAO,EAAE,CADwB;AAEjCE,EAAAA,QAAQ,EAAE,CAAC,MAAD;AAFuB,CAAvB,EAGX,UAASc,OAAT,EAAkBC,IAAlB,EAAwB;AACvB,MAAI8C,SAAS,GAAG9C,IAAI,CAAC,CAAD,CAApB;;AACA,MAAI8C,SAAS,CAACjD,IAAV,KAAmB,UAAvB,EAAmC;AAC/B,UAAM,IAAIrB,UAAJ,CAAe,0BAAf,EAA2CsE,SAA3C,CAAN;AACH;;AACD,MAAIC,IAAI,GAAG,EAAX;;AACA,OAAK,IAAIxD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuD,SAAS,CAAChD,KAAV,CAAgBN,MAApC,EAA4C,EAAED,CAA9C,EAAiD;AAC7CwD,IAAAA,IAAI,IAAID,SAAS,CAAChD,KAAV,CAAgBP,CAAhB,EAAmBO,KAA3B;AACH;;AACD,SAAO;AACHD,IAAAA,IAAI,EAAE,aADH;AAEHkD,IAAAA,IAAI,EAAEA,IAFH;AAGHD,IAAAA,SAAS,EAAEA;AAHR,GAAP;AAKH,CAjBa,CAAd","sourcesContent":["var utils = require(\"./utils\");\nvar ParseError = require(\"./ParseError\");\nvar parseData = require(\"./parseData\");\nvar ParseNode = parseData.ParseNode;\n\n/* This file contains a list of functions that we parse, identified by\n * the calls to defineFunction.\n *\n * The first argument to defineFunction is a single name or a list of names.\n * All functions named in such a list will share a single implementation.\n *\n * Each declared function can have associated properties, which\n * include the following:\n *\n *  - numArgs: The number of arguments the function takes.\n *             If this is the only property, it can be passed as a number\n *             instead of an element of a properties object.\n *  - argTypes: (optional) An array corresponding to each argument of the\n *              function, giving the type of argument that should be parsed. Its\n *              length should be equal to `numArgs + numOptionalArgs`. Valid\n *              types:\n *               - \"size\": A size-like thing, such as \"1em\" or \"5ex\"\n *               - \"color\": An html color, like \"#abc\" or \"blue\"\n *               - \"original\": The same type as the environment that the\n *                             function being parsed is in (e.g. used for the\n *                             bodies of functions like \\color where the first\n *                             argument is special and the second argument is\n *                             parsed normally)\n *              Other possible types (probably shouldn't be used)\n *               - \"text\": Text-like (e.g. \\text)\n *               - \"math\": Normal math\n *              If undefined, this will be treated as an appropriate length\n *              array of \"original\" strings\n *  - greediness: (optional) The greediness of the function to use ungrouped\n *                arguments.\n *\n *                E.g. if you have an expression\n *                  \\sqrt \\frac 1 2\n *                since \\frac has greediness=2 vs \\sqrt's greediness=1, \\frac\n *                will use the two arguments '1' and '2' as its two arguments,\n *                then that whole function will be used as the argument to\n *                \\sqrt. On the other hand, the expressions\n *                  \\frac \\frac 1 2 3\n *                and\n *                  \\frac \\sqrt 1 2\n *                will fail because \\frac and \\frac have equal greediness\n *                and \\sqrt has a lower greediness than \\frac respectively. To\n *                make these parse, we would have to change them to:\n *                  \\frac {\\frac 1 2} 3\n *                and\n *                  \\frac {\\sqrt 1} 2\n *\n *                The default value is `1`\n *  - allowedInText: (optional) Whether or not the function is allowed inside\n *                   text mode (default false)\n *  - numOptionalArgs: (optional) The number of optional arguments the function\n *                     should parse. If the optional arguments aren't found,\n *                     `null` will be passed to the handler in their place.\n *                     (default 0)\n *  - infix: (optional) Must be true if the function is an infix operator.\n *\n * The last argument is that implementation, the handler for the function(s).\n * It is called to handle these functions and their arguments.\n * It receives two arguments:\n *  - context contains information and references provided by the parser\n *  - args is an array of arguments obtained from TeX input\n * The context contains the following properties:\n *  - funcName: the text (i.e. name) of the function, including \\\n *  - parser: the parser object\n *  - lexer: the lexer object\n *  - positions: the positions in the overall string of the function\n *               and the arguments.\n * The latter three should only be used to produce error messages.\n *\n * The function should return an object with the following keys:\n *  - type: The type of element that this is. This is then used in\n *          buildHTML/buildMathML to determine which function\n *          should be called to build this node into a DOM node\n * Any other data can be added to the object, which will be passed\n * in to the function in buildHTML/buildMathML as `group.value`.\n */\n\nfunction defineFunction(names, props, handler) {\n    if (typeof names === \"string\") {\n        names = [names];\n    }\n    if (typeof props === \"number\") {\n        props = { numArgs: props };\n    }\n    // Set default values of functions\n    var data = {\n        numArgs: props.numArgs,\n        argTypes: props.argTypes,\n        greediness: (props.greediness === undefined) ? 1 : props.greediness,\n        allowedInText: !!props.allowedInText,\n        numOptionalArgs: props.numOptionalArgs || 0,\n        infix: !!props.infix,\n        handler: handler\n    };\n    for (var i = 0; i < names.length; ++i) {\n        module.exports[names[i]] = data;\n    }\n}\n\n// Since the corresponding buildHTML/buildMathML function expects a\n// list of elements, we normalize for different kinds of arguments\nvar ordargument = function(arg) {\n    if (arg.type === \"ordgroup\") {\n        return arg.value;\n    } else {\n        return [arg];\n    }\n};\n\n// A normal square root\ndefineFunction(\"\\\\sqrt\", {\n    numArgs: 1,\n    numOptionalArgs: 1\n}, function(context, args) {\n    var index = args[0];\n    var body = args[1];\n    return {\n        type: \"sqrt\",\n        body: body,\n        index: index\n    };\n});\n\n// Non-mathy text, possibly in a font\nvar textFunctionStyles = {\n    \"\\\\text\": undefined, \"\\\\textrm\": \"mathrm\", \"\\\\textsf\": \"mathsf\",\n    \"\\\\texttt\": \"mathtt\", \"\\\\textnormal\": \"mathrm\", \"\\\\textbf\": \"mathbf\",\n    \"\\\\textit\": \"textit\"\n};\n\ndefineFunction([\n    \"\\\\text\", \"\\\\textrm\", \"\\\\textsf\", \"\\\\texttt\", \"\\\\textnormal\",\n    \"\\\\textbf\", \"\\\\textit\"\n], {\n    numArgs: 1,\n    argTypes: [\"text\"],\n    greediness: 2,\n    allowedInText: true\n}, function(context, args) {\n    var body = args[0];\n    return {\n        type: \"text\",\n        body: ordargument(body),\n        style: textFunctionStyles[context.funcName]\n    };\n});\n\n// A two-argument custom color\ndefineFunction(\"\\\\color\", {\n    numArgs: 2,\n    allowedInText: true,\n    greediness: 3,\n    argTypes: [\"color\", \"original\"]\n}, function(context, args) {\n    var color = args[0];\n    var body = args[1];\n    return {\n        type: \"color\",\n        color: color.value,\n        value: ordargument(body)\n    };\n});\n\n// An overline\ndefineFunction(\"\\\\overline\", {\n    numArgs: 1\n}, function(context, args) {\n    var body = args[0];\n    return {\n        type: \"overline\",\n        body: body\n    };\n});\n\n// An underline\ndefineFunction(\"\\\\underline\", {\n    numArgs: 1\n}, function(context, args) {\n    var body = args[0];\n    return {\n        type: \"underline\",\n        body: body\n    };\n});\n\n// A box of the width and height\ndefineFunction(\"\\\\rule\", {\n    numArgs: 2,\n    numOptionalArgs: 1,\n    argTypes: [\"size\", \"size\", \"size\"]\n}, function(context, args) {\n    var shift = args[0];\n    var width = args[1];\n    var height = args[2];\n    return {\n        type: \"rule\",\n        shift: shift && shift.value,\n        width: width.value,\n        height: height.value\n    };\n});\n\n// TODO: In TeX, \\mkern only accepts mu-units, and \\kern does not accept\n// mu-units. In current KaTeX we relax this; both commands accept any unit.\ndefineFunction([\"\\\\kern\", \"\\\\mkern\"], {\n    numArgs: 1,\n    argTypes: [\"size\"]\n}, function(context, args) {\n    return {\n        type: \"kern\",\n        dimension: args[0].value\n    };\n});\n\n// A KaTeX logo\ndefineFunction(\"\\\\KaTeX\", {\n    numArgs: 0\n}, function(context) {\n    return {\n        type: \"katex\"\n    };\n});\n\ndefineFunction(\"\\\\phantom\", {\n    numArgs: 1\n}, function(context, args) {\n    var body = args[0];\n    return {\n        type: \"phantom\",\n        value: ordargument(body)\n    };\n});\n\n// Math class commands except \\mathop\ndefineFunction([\n    \"\\\\mathord\", \"\\\\mathbin\", \"\\\\mathrel\", \"\\\\mathopen\",\n    \"\\\\mathclose\", \"\\\\mathpunct\", \"\\\\mathinner\"\n], {\n    numArgs: 1\n}, function(context, args) {\n    var body = args[0];\n    return {\n        type: \"mclass\",\n        mclass: \"m\" + context.funcName.substr(5),\n        value: ordargument(body)\n    };\n});\n\n// Build a relation by placing one symbol on top of another\ndefineFunction(\"\\\\stackrel\", {\n    numArgs: 2\n}, function(context, args) {\n    var top = args[0];\n    var bottom = args[1];\n\n    var bottomop = new ParseNode(\"op\", {\n        type: \"op\",\n        limits: true,\n        alwaysHandleSupSub: true,\n        symbol: false,\n        value: ordargument(bottom)\n    }, bottom.mode);\n\n    var supsub = new ParseNode(\"supsub\", {\n        base: bottomop,\n        sup: top,\n        sub: null\n    }, top.mode);\n\n    return {\n        type: \"mclass\",\n        mclass: \"mrel\",\n        value: [supsub]\n    };\n});\n\n// \\mod-type functions\ndefineFunction(\"\\\\bmod\", {\n    numArgs: 0\n}, function(context, args) {\n    return {\n        type: \"mod\",\n        modType: \"bmod\",\n        value: null\n    };\n});\n\ndefineFunction([\"\\\\pod\", \"\\\\pmod\", \"\\\\mod\"], {\n    numArgs: 1\n}, function(context, args) {\n    var body = args[0];\n    return {\n        type: \"mod\",\n        modType: context.funcName.substr(1),\n        value: ordargument(body)\n    };\n});\n\n// Extra data needed for the delimiter handler down below\nvar delimiterSizes = {\n    \"\\\\bigl\" : {mclass: \"mopen\",    size: 1},\n    \"\\\\Bigl\" : {mclass: \"mopen\",    size: 2},\n    \"\\\\biggl\": {mclass: \"mopen\",    size: 3},\n    \"\\\\Biggl\": {mclass: \"mopen\",    size: 4},\n    \"\\\\bigr\" : {mclass: \"mclose\",   size: 1},\n    \"\\\\Bigr\" : {mclass: \"mclose\",   size: 2},\n    \"\\\\biggr\": {mclass: \"mclose\",   size: 3},\n    \"\\\\Biggr\": {mclass: \"mclose\",   size: 4},\n    \"\\\\bigm\" : {mclass: \"mrel\",     size: 1},\n    \"\\\\Bigm\" : {mclass: \"mrel\",     size: 2},\n    \"\\\\biggm\": {mclass: \"mrel\",     size: 3},\n    \"\\\\Biggm\": {mclass: \"mrel\",     size: 4},\n    \"\\\\big\"  : {mclass: \"mord\",     size: 1},\n    \"\\\\Big\"  : {mclass: \"mord\",     size: 2},\n    \"\\\\bigg\" : {mclass: \"mord\",     size: 3},\n    \"\\\\Bigg\" : {mclass: \"mord\",     size: 4}\n};\n\nvar delimiters = [\n    \"(\", \")\", \"[\", \"\\\\lbrack\", \"]\", \"\\\\rbrack\",\n    \"\\\\{\", \"\\\\lbrace\", \"\\\\}\", \"\\\\rbrace\",\n    \"\\\\lfloor\", \"\\\\rfloor\", \"\\\\lceil\", \"\\\\rceil\",\n    \"<\", \">\", \"\\\\langle\", \"\\\\rangle\", \"\\\\lt\", \"\\\\gt\",\n    \"\\\\lvert\", \"\\\\rvert\", \"\\\\lVert\", \"\\\\rVert\",\n    \"\\\\lgroup\", \"\\\\rgroup\", \"\\\\lmoustache\", \"\\\\rmoustache\",\n    \"/\", \"\\\\backslash\",\n    \"|\", \"\\\\vert\", \"\\\\|\", \"\\\\Vert\",\n    \"\\\\uparrow\", \"\\\\Uparrow\",\n    \"\\\\downarrow\", \"\\\\Downarrow\",\n    \"\\\\updownarrow\", \"\\\\Updownarrow\",\n    \".\"\n];\n\nvar fontAliases = {\n    \"\\\\Bbb\": \"\\\\mathbb\",\n    \"\\\\bold\": \"\\\\mathbf\",\n    \"\\\\frak\": \"\\\\mathfrak\"\n};\n\n// Single-argument color functions\ndefineFunction([\n    \"\\\\blue\", \"\\\\orange\", \"\\\\pink\", \"\\\\red\",\n    \"\\\\green\", \"\\\\gray\", \"\\\\purple\",\n    \"\\\\blueA\", \"\\\\blueB\", \"\\\\blueC\", \"\\\\blueD\", \"\\\\blueE\",\n    \"\\\\tealA\", \"\\\\tealB\", \"\\\\tealC\", \"\\\\tealD\", \"\\\\tealE\",\n    \"\\\\greenA\", \"\\\\greenB\", \"\\\\greenC\", \"\\\\greenD\", \"\\\\greenE\",\n    \"\\\\goldA\", \"\\\\goldB\", \"\\\\goldC\", \"\\\\goldD\", \"\\\\goldE\",\n    \"\\\\redA\", \"\\\\redB\", \"\\\\redC\", \"\\\\redD\", \"\\\\redE\",\n    \"\\\\maroonA\", \"\\\\maroonB\", \"\\\\maroonC\", \"\\\\maroonD\", \"\\\\maroonE\",\n    \"\\\\purpleA\", \"\\\\purpleB\", \"\\\\purpleC\", \"\\\\purpleD\", \"\\\\purpleE\",\n    \"\\\\mintA\", \"\\\\mintB\", \"\\\\mintC\",\n    \"\\\\grayA\", \"\\\\grayB\", \"\\\\grayC\", \"\\\\grayD\", \"\\\\grayE\",\n    \"\\\\grayF\", \"\\\\grayG\", \"\\\\grayH\", \"\\\\grayI\",\n    \"\\\\kaBlue\", \"\\\\kaGreen\"\n], {\n    numArgs: 1,\n    allowedInText: true,\n    greediness: 3\n}, function(context, args) {\n    var body = args[0];\n    return {\n        type: \"color\",\n        color: \"katex-\" + context.funcName.slice(1),\n        value: ordargument(body)\n    };\n});\n\n// There are 2 flags for operators; whether they produce limits in\n// displaystyle, and whether they are symbols and should grow in\n// displaystyle. These four groups cover the four possible choices.\n\n// No limits, not symbols\ndefineFunction([\n    \"\\\\arcsin\", \"\\\\arccos\", \"\\\\arctan\", \"\\\\arg\", \"\\\\cos\", \"\\\\cosh\",\n    \"\\\\cot\", \"\\\\coth\", \"\\\\csc\", \"\\\\deg\", \"\\\\dim\", \"\\\\exp\", \"\\\\hom\",\n    \"\\\\ker\", \"\\\\lg\", \"\\\\ln\", \"\\\\log\", \"\\\\sec\", \"\\\\sin\", \"\\\\sinh\",\n    \"\\\\tan\", \"\\\\tanh\"\n], {\n    numArgs: 0\n}, function(context) {\n    return {\n        type: \"op\",\n        limits: false,\n        symbol: false,\n        body: context.funcName\n    };\n});\n\n// Limits, not symbols\ndefineFunction([\n    \"\\\\det\", \"\\\\gcd\", \"\\\\inf\", \"\\\\lim\", \"\\\\liminf\", \"\\\\limsup\", \"\\\\max\",\n    \"\\\\min\", \"\\\\Pr\", \"\\\\sup\"\n], {\n    numArgs: 0\n}, function(context) {\n    return {\n        type: \"op\",\n        limits: true,\n        symbol: false,\n        body: context.funcName\n    };\n});\n\n// No limits, symbols\ndefineFunction([\n    \"\\\\int\", \"\\\\iint\", \"\\\\iiint\", \"\\\\oint\"\n], {\n    numArgs: 0\n}, function(context) {\n    return {\n        type: \"op\",\n        limits: false,\n        symbol: true,\n        body: context.funcName\n    };\n});\n\n// Limits, symbols\ndefineFunction([\n    \"\\\\coprod\", \"\\\\bigvee\", \"\\\\bigwedge\", \"\\\\biguplus\", \"\\\\bigcap\",\n    \"\\\\bigcup\", \"\\\\intop\", \"\\\\prod\", \"\\\\sum\", \"\\\\bigotimes\",\n    \"\\\\bigoplus\", \"\\\\bigodot\", \"\\\\bigsqcup\", \"\\\\smallint\"\n], {\n    numArgs: 0\n}, function(context) {\n    return {\n        type: \"op\",\n        limits: true,\n        symbol: true,\n        body: context.funcName\n    };\n});\n\n// \\mathop class command\ndefineFunction(\"\\\\mathop\", {\n    numArgs: 1\n}, function(context, args) {\n    var body = args[0];\n    return {\n        type: \"op\",\n        limits: false,\n        symbol: false,\n        value: ordargument(body)\n    };\n});\n\n// Fractions\ndefineFunction([\n    \"\\\\dfrac\", \"\\\\frac\", \"\\\\tfrac\",\n    \"\\\\dbinom\", \"\\\\binom\", \"\\\\tbinom\",\n    \"\\\\\\\\atopfrac\" // can’t be entered directly\n], {\n    numArgs: 2,\n    greediness: 2\n}, function(context, args) {\n    var numer = args[0];\n    var denom = args[1];\n    var hasBarLine;\n    var leftDelim = null;\n    var rightDelim = null;\n    var size = \"auto\";\n\n    switch (context.funcName) {\n        case \"\\\\dfrac\":\n        case \"\\\\frac\":\n        case \"\\\\tfrac\":\n            hasBarLine = true;\n            break;\n        case \"\\\\\\\\atopfrac\":\n            hasBarLine = false;\n            break;\n        case \"\\\\dbinom\":\n        case \"\\\\binom\":\n        case \"\\\\tbinom\":\n            hasBarLine = false;\n            leftDelim = \"(\";\n            rightDelim = \")\";\n            break;\n        default:\n            throw new Error(\"Unrecognized genfrac command\");\n    }\n\n    switch (context.funcName) {\n        case \"\\\\dfrac\":\n        case \"\\\\dbinom\":\n            size = \"display\";\n            break;\n        case \"\\\\tfrac\":\n        case \"\\\\tbinom\":\n            size = \"text\";\n            break;\n    }\n\n    return {\n        type: \"genfrac\",\n        numer: numer,\n        denom: denom,\n        hasBarLine: hasBarLine,\n        leftDelim: leftDelim,\n        rightDelim: rightDelim,\n        size: size\n    };\n});\n\n// Left and right overlap functions\ndefineFunction([\"\\\\llap\", \"\\\\rlap\"], {\n    numArgs: 1,\n    allowedInText: true\n}, function(context, args) {\n    var body = args[0];\n    return {\n        type: context.funcName.slice(1),\n        body: body\n    };\n});\n\n// Delimiter functions\nvar checkDelimiter = function(delim, context) {\n    if (utils.contains(delimiters, delim.value)) {\n        return delim;\n    } else {\n        throw new ParseError(\n            \"Invalid delimiter: '\" + delim.value + \"' after '\" +\n            context.funcName + \"'\", delim);\n    }\n};\n\ndefineFunction([\n    \"\\\\bigl\", \"\\\\Bigl\", \"\\\\biggl\", \"\\\\Biggl\",\n    \"\\\\bigr\", \"\\\\Bigr\", \"\\\\biggr\", \"\\\\Biggr\",\n    \"\\\\bigm\", \"\\\\Bigm\", \"\\\\biggm\", \"\\\\Biggm\",\n    \"\\\\big\",  \"\\\\Big\",  \"\\\\bigg\",  \"\\\\Bigg\"\n], {\n    numArgs: 1\n}, function(context, args) {\n    var delim = checkDelimiter(args[0], context);\n\n    return {\n        type: \"delimsizing\",\n        size: delimiterSizes[context.funcName].size,\n        mclass: delimiterSizes[context.funcName].mclass,\n        value: delim.value\n    };\n});\n\ndefineFunction([\n    \"\\\\left\", \"\\\\right\"\n], {\n    numArgs: 1\n}, function(context, args) {\n    var delim = checkDelimiter(args[0], context);\n\n    // \\left and \\right are caught somewhere in Parser.js, which is\n    // why this data doesn't match what is in buildHTML.\n    return {\n        type: \"leftright\",\n        value: delim.value\n    };\n});\n\ndefineFunction(\"\\\\middle\", {\n    numArgs: 1\n}, function(context, args) {\n    var delim = checkDelimiter(args[0], context);\n    if (!context.parser.leftrightDepth) {\n        throw new ParseError(\"\\\\middle without preceding \\\\left\", delim);\n    }\n\n    return {\n        type: \"middle\",\n        value: delim.value\n    };\n});\n\n// Sizing functions (handled in Parser.js explicitly, hence no handler)\ndefineFunction([\n    \"\\\\tiny\", \"\\\\scriptsize\", \"\\\\footnotesize\", \"\\\\small\",\n    \"\\\\normalsize\", \"\\\\large\", \"\\\\Large\", \"\\\\LARGE\", \"\\\\huge\", \"\\\\Huge\"\n], 0, null);\n\n// Style changing functions (handled in Parser.js explicitly, hence no\n// handler)\ndefineFunction([\n    \"\\\\displaystyle\", \"\\\\textstyle\", \"\\\\scriptstyle\",\n    \"\\\\scriptscriptstyle\"\n], 0, null);\n\ndefineFunction([\n    // styles\n    \"\\\\mathrm\", \"\\\\mathit\", \"\\\\mathbf\",\n\n    // families\n    \"\\\\mathbb\", \"\\\\mathcal\", \"\\\\mathfrak\", \"\\\\mathscr\", \"\\\\mathsf\",\n    \"\\\\mathtt\",\n\n    // aliases\n    \"\\\\Bbb\", \"\\\\bold\", \"\\\\frak\"\n], {\n    numArgs: 1,\n    greediness: 2\n}, function(context, args) {\n    var body = args[0];\n    var func = context.funcName;\n    if (func in fontAliases) {\n        func = fontAliases[func];\n    }\n    return {\n        type: \"font\",\n        font: func.slice(1),\n        body: body\n    };\n});\n\n// Accents\ndefineFunction([\n    \"\\\\acute\", \"\\\\grave\", \"\\\\ddot\", \"\\\\tilde\", \"\\\\bar\", \"\\\\breve\",\n    \"\\\\check\", \"\\\\hat\", \"\\\\vec\", \"\\\\dot\"\n    // We don't support expanding accents yet\n    // \"\\\\widetilde\", \"\\\\widehat\"\n], {\n    numArgs: 1\n}, function(context, args) {\n    var base = args[0];\n    return {\n        type: \"accent\",\n        accent: context.funcName,\n        base: base\n    };\n});\n\n// Infix generalized fractions\ndefineFunction([\"\\\\over\", \"\\\\choose\", \"\\\\atop\"], {\n    numArgs: 0,\n    infix: true\n}, function(context) {\n    var replaceWith;\n    switch (context.funcName) {\n        case \"\\\\over\":\n            replaceWith = \"\\\\frac\";\n            break;\n        case \"\\\\choose\":\n            replaceWith = \"\\\\binom\";\n            break;\n        case \"\\\\atop\":\n            replaceWith = \"\\\\\\\\atopfrac\";\n            break;\n        default:\n            throw new Error(\"Unrecognized infix genfrac command\");\n    }\n    return {\n        type: \"infix\",\n        replaceWith: replaceWith,\n        token: context.token\n    };\n});\n\n// Row breaks for aligned data\ndefineFunction([\"\\\\\\\\\", \"\\\\cr\"], {\n    numArgs: 0,\n    numOptionalArgs: 1,\n    argTypes: [\"size\"]\n}, function(context, args) {\n    var size = args[0];\n    return {\n        type: \"cr\",\n        size: size\n    };\n});\n\n// Environment delimiters\ndefineFunction([\"\\\\begin\", \"\\\\end\"], {\n    numArgs: 1,\n    argTypes: [\"text\"]\n}, function(context, args) {\n    var nameGroup = args[0];\n    if (nameGroup.type !== \"ordgroup\") {\n        throw new ParseError(\"Invalid environment name\", nameGroup);\n    }\n    var name = \"\";\n    for (var i = 0; i < nameGroup.value.length; ++i) {\n        name += nameGroup.value[i].value;\n    }\n    return {\n        type: \"environment\",\n        name: name,\n        nameGroup: nameGroup\n    };\n});\n"]},"metadata":{},"sourceType":"script"}