{"ast":null,"code":"/* eslint no-console:0 */\n\n/**\n * This module contains general functions that can be used for building\n * different kinds of domTree nodes in a consistent manner.\n */\nvar domTree = require(\"./domTree\");\n\nvar fontMetrics = require(\"./fontMetrics\");\n\nvar symbols = require(\"./symbols\");\n\nvar utils = require(\"./utils\");\n\nvar greekCapitals = [\"\\\\Gamma\", \"\\\\Delta\", \"\\\\Theta\", \"\\\\Lambda\", \"\\\\Xi\", \"\\\\Pi\", \"\\\\Sigma\", \"\\\\Upsilon\", \"\\\\Phi\", \"\\\\Psi\", \"\\\\Omega\"]; // The following have to be loaded from Main-Italic font, using class mainit\n\nvar mainitLetters = [\"\\u0131\", // dotless i, \\imath\n\"\\u0237\", // dotless j, \\jmath\n\"\\u00a3\" // \\pounds\n];\n/**\n * Makes a symbolNode after translation via the list of symbols in symbols.js.\n * Correctly pulls out metrics for the character, and optionally takes a list of\n * classes to be attached to the node.\n *\n * TODO: make argument order closer to makeSpan\n * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which\n * should if present come first in `classes`.\n */\n\nvar makeSymbol = function (value, fontFamily, mode, options, classes) {\n  // Replace the value with its replaced value from symbol.js\n  if (symbols[mode][value] && symbols[mode][value].replace) {\n    value = symbols[mode][value].replace;\n  }\n\n  var metrics = fontMetrics.getCharacterMetrics(value, fontFamily);\n  var symbolNode;\n\n  if (metrics) {\n    var italic = metrics.italic;\n\n    if (mode === \"text\") {\n      italic = 0;\n    }\n\n    symbolNode = new domTree.symbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, classes);\n  } else {\n    // TODO(emily): Figure out a good way to only print this in development\n    typeof console !== \"undefined\" && console.warn(\"No character metrics for '\" + value + \"' in style '\" + fontFamily + \"'\");\n    symbolNode = new domTree.symbolNode(value, 0, 0, 0, 0, classes);\n  }\n\n  if (options) {\n    if (options.style.isTight()) {\n      symbolNode.classes.push(\"mtight\");\n    }\n\n    if (options.getColor()) {\n      symbolNode.style.color = options.getColor();\n    }\n  }\n\n  return symbolNode;\n};\n/**\n * Makes a symbol in Main-Regular or AMS-Regular.\n * Used for rel, bin, open, close, inner, and punct.\n */\n\n\nvar mathsym = function (value, mode, options, classes) {\n  // Decide what font to render the symbol in by its entry in the symbols\n  // table.\n  // Have a special case for when the value = \\ because the \\ is used as a\n  // textord in unsupported command errors but cannot be parsed as a regular\n  // text ordinal and is therefore not present as a symbol in the symbols\n  // table for text\n  if (value === \"\\\\\" || symbols[mode][value].font === \"main\") {\n    return makeSymbol(value, \"Main-Regular\", mode, options, classes);\n  } else {\n    return makeSymbol(value, \"AMS-Regular\", mode, options, classes.concat([\"amsrm\"]));\n  }\n};\n/**\n * Makes a symbol in the default font for mathords and textords.\n */\n\n\nvar mathDefault = function (value, mode, options, classes, type) {\n  if (type === \"mathord\") {\n    return mathit(value, mode, options, classes);\n  } else if (type === \"textord\") {\n    return makeSymbol(value, \"Main-Regular\", mode, options, classes.concat([\"mathrm\"]));\n  } else {\n    throw new Error(\"unexpected type: \" + type + \" in mathDefault\");\n  }\n};\n/**\n * Makes a symbol in the italic math font.\n */\n\n\nvar mathit = function (value, mode, options, classes) {\n  if (/[0-9]/.test(value.charAt(0)) || // glyphs for \\imath and \\jmath do not exist in Math-Italic so we\n  // need to use Main-Italic instead\n  utils.contains(mainitLetters, value) || utils.contains(greekCapitals, value)) {\n    return makeSymbol(value, \"Main-Italic\", mode, options, classes.concat([\"mainit\"]));\n  } else {\n    return makeSymbol(value, \"Math-Italic\", mode, options, classes.concat([\"mathit\"]));\n  }\n};\n/**\n * Makes either a mathord or textord in the correct font and color.\n */\n\n\nvar makeOrd = function (group, options, type) {\n  var mode = group.mode;\n  var value = group.value;\n\n  if (symbols[mode][value] && symbols[mode][value].replace) {\n    value = symbols[mode][value].replace;\n  }\n\n  var classes = [\"mord\"];\n  var font = options.font;\n\n  if (font) {\n    if (font === \"mathit\" || utils.contains(mainitLetters, value)) {\n      return mathit(value, mode, options, classes);\n    } else {\n      var fontName = fontMap[font].fontName;\n\n      if (fontMetrics.getCharacterMetrics(value, fontName)) {\n        return makeSymbol(value, fontName, mode, options, classes.concat([font]));\n      } else {\n        return mathDefault(value, mode, options, classes, type);\n      }\n    }\n  } else {\n    return mathDefault(value, mode, options, classes, type);\n  }\n};\n/**\n * Calculate the height, depth, and maxFontSize of an element based on its\n * children.\n */\n\n\nvar sizeElementFromChildren = function (elem) {\n  var height = 0;\n  var depth = 0;\n  var maxFontSize = 0;\n\n  if (elem.children) {\n    for (var i = 0; i < elem.children.length; i++) {\n      if (elem.children[i].height > height) {\n        height = elem.children[i].height;\n      }\n\n      if (elem.children[i].depth > depth) {\n        depth = elem.children[i].depth;\n      }\n\n      if (elem.children[i].maxFontSize > maxFontSize) {\n        maxFontSize = elem.children[i].maxFontSize;\n      }\n    }\n  }\n\n  elem.height = height;\n  elem.depth = depth;\n  elem.maxFontSize = maxFontSize;\n};\n/**\n * Makes a span with the given list of classes, list of children, and options.\n *\n * TODO: Ensure that `options` is always provided (currently some call sites\n * don't pass it).\n * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which\n * should if present come first in `classes`.\n */\n\n\nvar makeSpan = function (classes, children, options) {\n  var span = new domTree.span(classes, children, options);\n  sizeElementFromChildren(span);\n  return span;\n};\n/**\n * Prepends the given children to the given span, updating height, depth, and\n * maxFontSize.\n */\n\n\nvar prependChildren = function (span, children) {\n  span.children = children.concat(span.children);\n  sizeElementFromChildren(span);\n};\n/**\n * Makes a document fragment with the given list of children.\n */\n\n\nvar makeFragment = function (children) {\n  var fragment = new domTree.documentFragment(children);\n  sizeElementFromChildren(fragment);\n  return fragment;\n};\n/**\n * Makes an element placed in each of the vlist elements to ensure that each\n * element has the same max font size. To do this, we create a zero-width space\n * with the correct font size.\n */\n\n\nvar makeFontSizer = function (options, fontSize) {\n  var fontSizeInner = makeSpan([], [new domTree.symbolNode(\"\\u200b\")]);\n  fontSizeInner.style.fontSize = fontSize / options.style.sizeMultiplier + \"em\";\n  var fontSizer = makeSpan([\"fontsize-ensurer\", \"reset-\" + options.size, \"size5\"], [fontSizeInner]);\n  return fontSizer;\n};\n/**\n * Makes a vertical list by stacking elements and kerns on top of each other.\n * Allows for many different ways of specifying the positioning method.\n *\n * Arguments:\n *  - children: A list of child or kern nodes to be stacked on top of each other\n *              (i.e. the first element will be at the bottom, and the last at\n *              the top). Element nodes are specified as\n *                {type: \"elem\", elem: node}\n *              while kern nodes are specified as\n *                {type: \"kern\", size: size}\n *  - positionType: The method by which the vlist should be positioned. Valid\n *                  values are:\n *                   - \"individualShift\": The children list only contains elem\n *                                        nodes, and each node contains an extra\n *                                        \"shift\" value of how much it should be\n *                                        shifted (note that shifting is always\n *                                        moving downwards). positionData is\n *                                        ignored.\n *                   - \"top\": The positionData specifies the topmost point of\n *                            the vlist (note this is expected to be a height,\n *                            so positive values move up)\n *                   - \"bottom\": The positionData specifies the bottommost point\n *                               of the vlist (note this is expected to be a\n *                               depth, so positive values move down\n *                   - \"shift\": The vlist will be positioned such that its\n *                              baseline is positionData away from the baseline\n *                              of the first child. Positive values move\n *                              downwards.\n *                   - \"firstBaseline\": The vlist will be positioned such that\n *                                      its baseline is aligned with the\n *                                      baseline of the first child.\n *                                      positionData is ignored. (this is\n *                                      equivalent to \"shift\" with\n *                                      positionData=0)\n *  - positionData: Data used in different ways depending on positionType\n *  - options: An Options object\n *\n */\n\n\nvar makeVList = function (children, positionType, positionData, options) {\n  var depth;\n  var currPos;\n  var i;\n\n  if (positionType === \"individualShift\") {\n    var oldChildren = children;\n    children = [oldChildren[0]]; // Add in kerns to the list of children to get each element to be\n    // shifted to the correct specified shift\n\n    depth = -oldChildren[0].shift - oldChildren[0].elem.depth;\n    currPos = depth;\n\n    for (i = 1; i < oldChildren.length; i++) {\n      var diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;\n      var size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);\n      currPos = currPos + diff;\n      children.push({\n        type: \"kern\",\n        size: size\n      });\n      children.push(oldChildren[i]);\n    }\n  } else if (positionType === \"top\") {\n    // We always start at the bottom, so calculate the bottom by adding up\n    // all the sizes\n    var bottom = positionData;\n\n    for (i = 0; i < children.length; i++) {\n      if (children[i].type === \"kern\") {\n        bottom -= children[i].size;\n      } else {\n        bottom -= children[i].elem.height + children[i].elem.depth;\n      }\n    }\n\n    depth = bottom;\n  } else if (positionType === \"bottom\") {\n    depth = -positionData;\n  } else if (positionType === \"shift\") {\n    depth = -children[0].elem.depth - positionData;\n  } else if (positionType === \"firstBaseline\") {\n    depth = -children[0].elem.depth;\n  } else {\n    depth = 0;\n  } // Make the fontSizer\n\n\n  var maxFontSize = 0;\n\n  for (i = 0; i < children.length; i++) {\n    if (children[i].type === \"elem\") {\n      maxFontSize = Math.max(maxFontSize, children[i].elem.maxFontSize);\n    }\n  }\n\n  var fontSizer = makeFontSizer(options, maxFontSize); // Create a new list of actual children at the correct offsets\n\n  var realChildren = [];\n  currPos = depth;\n\n  for (i = 0; i < children.length; i++) {\n    if (children[i].type === \"kern\") {\n      currPos += children[i].size;\n    } else {\n      var child = children[i].elem;\n      var shift = -child.depth - currPos;\n      currPos += child.height + child.depth;\n      var childWrap = makeSpan([], [fontSizer, child]);\n      childWrap.height -= shift;\n      childWrap.depth += shift;\n      childWrap.style.top = shift + \"em\";\n      realChildren.push(childWrap);\n    }\n  } // Add in an element at the end with no offset to fix the calculation of\n  // baselines in some browsers (namely IE, sometimes safari)\n\n\n  var baselineFix = makeSpan([\"baseline-fix\"], [fontSizer, new domTree.symbolNode(\"\\u200b\")]);\n  realChildren.push(baselineFix);\n  var vlist = makeSpan([\"vlist\"], realChildren); // Fix the final height and depth, in case there were kerns at the ends\n  // since the makeSpan calculation won't take that in to account.\n\n  vlist.height = Math.max(currPos, vlist.height);\n  vlist.depth = Math.max(-depth, vlist.depth);\n  return vlist;\n}; // A table of size -> font size for the different sizing functions\n\n\nvar sizingMultiplier = {\n  size1: 0.5,\n  size2: 0.7,\n  size3: 0.8,\n  size4: 0.9,\n  size5: 1.0,\n  size6: 1.2,\n  size7: 1.44,\n  size8: 1.73,\n  size9: 2.07,\n  size10: 2.49\n}; // A map of spacing functions to their attributes, like size and corresponding\n// CSS class\n\nvar spacingFunctions = {\n  \"\\\\qquad\": {\n    size: \"2em\",\n    className: \"qquad\"\n  },\n  \"\\\\quad\": {\n    size: \"1em\",\n    className: \"quad\"\n  },\n  \"\\\\enspace\": {\n    size: \"0.5em\",\n    className: \"enspace\"\n  },\n  \"\\\\;\": {\n    size: \"0.277778em\",\n    className: \"thickspace\"\n  },\n  \"\\\\:\": {\n    size: \"0.22222em\",\n    className: \"mediumspace\"\n  },\n  \"\\\\,\": {\n    size: \"0.16667em\",\n    className: \"thinspace\"\n  },\n  \"\\\\!\": {\n    size: \"-0.16667em\",\n    className: \"negativethinspace\"\n  }\n};\n/**\n * Maps TeX font commands to objects containing:\n * - variant: string used for \"mathvariant\" attribute in buildMathML.js\n * - fontName: the \"style\" parameter to fontMetrics.getCharacterMetrics\n */\n// A map between tex font commands an MathML mathvariant attribute values\n\nvar fontMap = {\n  // styles\n  \"mathbf\": {\n    variant: \"bold\",\n    fontName: \"Main-Bold\"\n  },\n  \"mathrm\": {\n    variant: \"normal\",\n    fontName: \"Main-Regular\"\n  },\n  \"textit\": {\n    variant: \"italic\",\n    fontName: \"Main-Italic\"\n  },\n  // \"mathit\" is missing because it requires the use of two fonts: Main-Italic\n  // and Math-Italic.  This is handled by a special case in makeOrd which ends\n  // up calling mathit.\n  // families\n  \"mathbb\": {\n    variant: \"double-struck\",\n    fontName: \"AMS-Regular\"\n  },\n  \"mathcal\": {\n    variant: \"script\",\n    fontName: \"Caligraphic-Regular\"\n  },\n  \"mathfrak\": {\n    variant: \"fraktur\",\n    fontName: \"Fraktur-Regular\"\n  },\n  \"mathscr\": {\n    variant: \"script\",\n    fontName: \"Script-Regular\"\n  },\n  \"mathsf\": {\n    variant: \"sans-serif\",\n    fontName: \"SansSerif-Regular\"\n  },\n  \"mathtt\": {\n    variant: \"monospace\",\n    fontName: \"Typewriter-Regular\"\n  }\n};\nmodule.exports = {\n  fontMap: fontMap,\n  makeSymbol: makeSymbol,\n  mathsym: mathsym,\n  makeSpan: makeSpan,\n  makeFragment: makeFragment,\n  makeVList: makeVList,\n  makeOrd: makeOrd,\n  prependChildren: prependChildren,\n  sizingMultiplier: sizingMultiplier,\n  spacingFunctions: spacingFunctions\n};","map":{"version":3,"sources":["/Users/justinf/perseus-configured/node_modules/katex/src/buildCommon.js"],"names":["domTree","require","fontMetrics","symbols","utils","greekCapitals","mainitLetters","makeSymbol","value","fontFamily","mode","options","classes","replace","metrics","getCharacterMetrics","symbolNode","italic","height","depth","skew","console","warn","style","isTight","push","getColor","color","mathsym","font","concat","mathDefault","type","mathit","Error","test","charAt","contains","makeOrd","group","fontName","fontMap","sizeElementFromChildren","elem","maxFontSize","children","i","length","makeSpan","span","prependChildren","makeFragment","fragment","documentFragment","makeFontSizer","fontSize","fontSizeInner","sizeMultiplier","fontSizer","size","makeVList","positionType","positionData","currPos","oldChildren","shift","diff","bottom","Math","max","realChildren","child","childWrap","top","baselineFix","vlist","sizingMultiplier","size1","size2","size3","size4","size5","size6","size7","size8","size9","size10","spacingFunctions","className","variant","module","exports"],"mappings":"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","sourcesContent":["/* eslint no-console:0 */\n/**\n * This module contains general functions that can be used for building\n * different kinds of domTree nodes in a consistent manner.\n */\n\nvar domTree = require(\"./domTree\");\nvar fontMetrics = require(\"./fontMetrics\");\nvar symbols = require(\"./symbols\");\nvar utils = require(\"./utils\");\n\nvar greekCapitals = [\n    \"\\\\Gamma\",\n    \"\\\\Delta\",\n    \"\\\\Theta\",\n    \"\\\\Lambda\",\n    \"\\\\Xi\",\n    \"\\\\Pi\",\n    \"\\\\Sigma\",\n    \"\\\\Upsilon\",\n    \"\\\\Phi\",\n    \"\\\\Psi\",\n    \"\\\\Omega\"\n];\n\n// The following have to be loaded from Main-Italic font, using class mainit\nvar mainitLetters = [\n    \"\\u0131\",   // dotless i, \\imath\n    \"\\u0237\",   // dotless j, \\jmath\n    \"\\u00a3\"   // \\pounds\n];\n\n/**\n * Makes a symbolNode after translation via the list of symbols in symbols.js.\n * Correctly pulls out metrics for the character, and optionally takes a list of\n * classes to be attached to the node.\n *\n * TODO: make argument order closer to makeSpan\n * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which\n * should if present come first in `classes`.\n */\nvar makeSymbol = function(value, fontFamily, mode, options, classes) {\n    // Replace the value with its replaced value from symbol.js\n    if (symbols[mode][value] && symbols[mode][value].replace) {\n        value = symbols[mode][value].replace;\n    }\n\n    var metrics = fontMetrics.getCharacterMetrics(value, fontFamily);\n\n    var symbolNode;\n    if (metrics) {\n        var italic = metrics.italic;\n        if (mode === \"text\") {\n            italic = 0;\n        }\n        symbolNode = new domTree.symbolNode(\n            value, metrics.height, metrics.depth, italic, metrics.skew,\n            classes);\n    } else {\n        // TODO(emily): Figure out a good way to only print this in development\n        typeof console !== \"undefined\" && console.warn(\n            \"No character metrics for '\" + value + \"' in style '\" +\n                fontFamily + \"'\");\n        symbolNode = new domTree.symbolNode(value, 0, 0, 0, 0, classes);\n    }\n\n    if (options) {\n        if (options.style.isTight()) {\n            symbolNode.classes.push(\"mtight\");\n        }\n        if (options.getColor()) {\n            symbolNode.style.color = options.getColor();\n        }\n    }\n\n    return symbolNode;\n};\n\n/**\n * Makes a symbol in Main-Regular or AMS-Regular.\n * Used for rel, bin, open, close, inner, and punct.\n */\nvar mathsym = function(value, mode, options, classes) {\n    // Decide what font to render the symbol in by its entry in the symbols\n    // table.\n    // Have a special case for when the value = \\ because the \\ is used as a\n    // textord in unsupported command errors but cannot be parsed as a regular\n    // text ordinal and is therefore not present as a symbol in the symbols\n    // table for text\n    if (value === \"\\\\\" || symbols[mode][value].font === \"main\") {\n        return makeSymbol(value, \"Main-Regular\", mode, options, classes);\n    } else {\n        return makeSymbol(\n            value, \"AMS-Regular\", mode, options, classes.concat([\"amsrm\"]));\n    }\n};\n\n/**\n * Makes a symbol in the default font for mathords and textords.\n */\nvar mathDefault = function(value, mode, options, classes, type) {\n    if (type === \"mathord\") {\n        return mathit(value, mode, options, classes);\n    } else if (type === \"textord\") {\n        return makeSymbol(\n            value, \"Main-Regular\", mode, options, classes.concat([\"mathrm\"]));\n    } else {\n        throw new Error(\"unexpected type: \" + type + \" in mathDefault\");\n    }\n};\n\n/**\n * Makes a symbol in the italic math font.\n */\nvar mathit = function(value, mode, options, classes) {\n    if (/[0-9]/.test(value.charAt(0)) ||\n            // glyphs for \\imath and \\jmath do not exist in Math-Italic so we\n            // need to use Main-Italic instead\n            utils.contains(mainitLetters, value) ||\n            utils.contains(greekCapitals, value)) {\n        return makeSymbol(\n            value, \"Main-Italic\", mode, options, classes.concat([\"mainit\"]));\n    } else {\n        return makeSymbol(\n            value, \"Math-Italic\", mode, options, classes.concat([\"mathit\"]));\n    }\n};\n\n/**\n * Makes either a mathord or textord in the correct font and color.\n */\nvar makeOrd = function(group, options, type) {\n    var mode = group.mode;\n    var value = group.value;\n    if (symbols[mode][value] && symbols[mode][value].replace) {\n        value = symbols[mode][value].replace;\n    }\n\n    var classes = [\"mord\"];\n\n    var font = options.font;\n    if (font) {\n        if (font === \"mathit\" || utils.contains(mainitLetters, value)) {\n            return mathit(value, mode, options, classes);\n        } else {\n            var fontName = fontMap[font].fontName;\n            if (fontMetrics.getCharacterMetrics(value, fontName)) {\n                return makeSymbol(\n                    value, fontName, mode, options, classes.concat([font]));\n            } else {\n                return mathDefault(value, mode, options, classes, type);\n            }\n        }\n    } else {\n        return mathDefault(value, mode, options, classes, type);\n    }\n};\n\n/**\n * Calculate the height, depth, and maxFontSize of an element based on its\n * children.\n */\nvar sizeElementFromChildren = function(elem) {\n    var height = 0;\n    var depth = 0;\n    var maxFontSize = 0;\n\n    if (elem.children) {\n        for (var i = 0; i < elem.children.length; i++) {\n            if (elem.children[i].height > height) {\n                height = elem.children[i].height;\n            }\n            if (elem.children[i].depth > depth) {\n                depth = elem.children[i].depth;\n            }\n            if (elem.children[i].maxFontSize > maxFontSize) {\n                maxFontSize = elem.children[i].maxFontSize;\n            }\n        }\n    }\n\n    elem.height = height;\n    elem.depth = depth;\n    elem.maxFontSize = maxFontSize;\n};\n\n/**\n * Makes a span with the given list of classes, list of children, and options.\n *\n * TODO: Ensure that `options` is always provided (currently some call sites\n * don't pass it).\n * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which\n * should if present come first in `classes`.\n */\nvar makeSpan = function(classes, children, options) {\n    var span = new domTree.span(classes, children, options);\n\n    sizeElementFromChildren(span);\n\n    return span;\n};\n\n/**\n * Prepends the given children to the given span, updating height, depth, and\n * maxFontSize.\n */\nvar prependChildren = function(span, children) {\n    span.children = children.concat(span.children);\n\n    sizeElementFromChildren(span);\n};\n\n/**\n * Makes a document fragment with the given list of children.\n */\nvar makeFragment = function(children) {\n    var fragment = new domTree.documentFragment(children);\n\n    sizeElementFromChildren(fragment);\n\n    return fragment;\n};\n\n/**\n * Makes an element placed in each of the vlist elements to ensure that each\n * element has the same max font size. To do this, we create a zero-width space\n * with the correct font size.\n */\nvar makeFontSizer = function(options, fontSize) {\n    var fontSizeInner = makeSpan([], [new domTree.symbolNode(\"\\u200b\")]);\n    fontSizeInner.style.fontSize =\n        (fontSize / options.style.sizeMultiplier) + \"em\";\n\n    var fontSizer = makeSpan(\n        [\"fontsize-ensurer\", \"reset-\" + options.size, \"size5\"],\n        [fontSizeInner]);\n\n    return fontSizer;\n};\n\n/**\n * Makes a vertical list by stacking elements and kerns on top of each other.\n * Allows for many different ways of specifying the positioning method.\n *\n * Arguments:\n *  - children: A list of child or kern nodes to be stacked on top of each other\n *              (i.e. the first element will be at the bottom, and the last at\n *              the top). Element nodes are specified as\n *                {type: \"elem\", elem: node}\n *              while kern nodes are specified as\n *                {type: \"kern\", size: size}\n *  - positionType: The method by which the vlist should be positioned. Valid\n *                  values are:\n *                   - \"individualShift\": The children list only contains elem\n *                                        nodes, and each node contains an extra\n *                                        \"shift\" value of how much it should be\n *                                        shifted (note that shifting is always\n *                                        moving downwards). positionData is\n *                                        ignored.\n *                   - \"top\": The positionData specifies the topmost point of\n *                            the vlist (note this is expected to be a height,\n *                            so positive values move up)\n *                   - \"bottom\": The positionData specifies the bottommost point\n *                               of the vlist (note this is expected to be a\n *                               depth, so positive values move down\n *                   - \"shift\": The vlist will be positioned such that its\n *                              baseline is positionData away from the baseline\n *                              of the first child. Positive values move\n *                              downwards.\n *                   - \"firstBaseline\": The vlist will be positioned such that\n *                                      its baseline is aligned with the\n *                                      baseline of the first child.\n *                                      positionData is ignored. (this is\n *                                      equivalent to \"shift\" with\n *                                      positionData=0)\n *  - positionData: Data used in different ways depending on positionType\n *  - options: An Options object\n *\n */\nvar makeVList = function(children, positionType, positionData, options) {\n    var depth;\n    var currPos;\n    var i;\n    if (positionType === \"individualShift\") {\n        var oldChildren = children;\n        children = [oldChildren[0]];\n\n        // Add in kerns to the list of children to get each element to be\n        // shifted to the correct specified shift\n        depth = -oldChildren[0].shift - oldChildren[0].elem.depth;\n        currPos = depth;\n        for (i = 1; i < oldChildren.length; i++) {\n            var diff = -oldChildren[i].shift - currPos -\n                oldChildren[i].elem.depth;\n            var size = diff -\n                (oldChildren[i - 1].elem.height +\n                 oldChildren[i - 1].elem.depth);\n\n            currPos = currPos + diff;\n\n            children.push({type: \"kern\", size: size});\n            children.push(oldChildren[i]);\n        }\n    } else if (positionType === \"top\") {\n        // We always start at the bottom, so calculate the bottom by adding up\n        // all the sizes\n        var bottom = positionData;\n        for (i = 0; i < children.length; i++) {\n            if (children[i].type === \"kern\") {\n                bottom -= children[i].size;\n            } else {\n                bottom -= children[i].elem.height + children[i].elem.depth;\n            }\n        }\n        depth = bottom;\n    } else if (positionType === \"bottom\") {\n        depth = -positionData;\n    } else if (positionType === \"shift\") {\n        depth = -children[0].elem.depth - positionData;\n    } else if (positionType === \"firstBaseline\") {\n        depth = -children[0].elem.depth;\n    } else {\n        depth = 0;\n    }\n\n    // Make the fontSizer\n    var maxFontSize = 0;\n    for (i = 0; i < children.length; i++) {\n        if (children[i].type === \"elem\") {\n            maxFontSize = Math.max(maxFontSize, children[i].elem.maxFontSize);\n        }\n    }\n    var fontSizer = makeFontSizer(options, maxFontSize);\n\n    // Create a new list of actual children at the correct offsets\n    var realChildren = [];\n    currPos = depth;\n    for (i = 0; i < children.length; i++) {\n        if (children[i].type === \"kern\") {\n            currPos += children[i].size;\n        } else {\n            var child = children[i].elem;\n\n            var shift = -child.depth - currPos;\n            currPos += child.height + child.depth;\n\n            var childWrap = makeSpan([], [fontSizer, child]);\n            childWrap.height -= shift;\n            childWrap.depth += shift;\n            childWrap.style.top = shift + \"em\";\n\n            realChildren.push(childWrap);\n        }\n    }\n\n    // Add in an element at the end with no offset to fix the calculation of\n    // baselines in some browsers (namely IE, sometimes safari)\n    var baselineFix = makeSpan(\n        [\"baseline-fix\"], [fontSizer, new domTree.symbolNode(\"\\u200b\")]);\n    realChildren.push(baselineFix);\n\n    var vlist = makeSpan([\"vlist\"], realChildren);\n    // Fix the final height and depth, in case there were kerns at the ends\n    // since the makeSpan calculation won't take that in to account.\n    vlist.height = Math.max(currPos, vlist.height);\n    vlist.depth = Math.max(-depth, vlist.depth);\n    return vlist;\n};\n\n// A table of size -> font size for the different sizing functions\nvar sizingMultiplier = {\n    size1: 0.5,\n    size2: 0.7,\n    size3: 0.8,\n    size4: 0.9,\n    size5: 1.0,\n    size6: 1.2,\n    size7: 1.44,\n    size8: 1.73,\n    size9: 2.07,\n    size10: 2.49\n};\n\n// A map of spacing functions to their attributes, like size and corresponding\n// CSS class\nvar spacingFunctions = {\n    \"\\\\qquad\": {\n        size: \"2em\",\n        className: \"qquad\"\n    },\n    \"\\\\quad\": {\n        size: \"1em\",\n        className: \"quad\"\n    },\n    \"\\\\enspace\": {\n        size: \"0.5em\",\n        className: \"enspace\"\n    },\n    \"\\\\;\": {\n        size: \"0.277778em\",\n        className: \"thickspace\"\n    },\n    \"\\\\:\": {\n        size: \"0.22222em\",\n        className: \"mediumspace\"\n    },\n    \"\\\\,\": {\n        size: \"0.16667em\",\n        className: \"thinspace\"\n    },\n    \"\\\\!\": {\n        size: \"-0.16667em\",\n        className: \"negativethinspace\"\n    }\n};\n\n/**\n * Maps TeX font commands to objects containing:\n * - variant: string used for \"mathvariant\" attribute in buildMathML.js\n * - fontName: the \"style\" parameter to fontMetrics.getCharacterMetrics\n */\n// A map between tex font commands an MathML mathvariant attribute values\nvar fontMap = {\n    // styles\n    \"mathbf\": {\n        variant: \"bold\",\n        fontName: \"Main-Bold\"\n    },\n    \"mathrm\": {\n        variant: \"normal\",\n        fontName: \"Main-Regular\"\n    },\n    \"textit\": {\n        variant: \"italic\",\n        fontName: \"Main-Italic\"\n    },\n\n    // \"mathit\" is missing because it requires the use of two fonts: Main-Italic\n    // and Math-Italic.  This is handled by a special case in makeOrd which ends\n    // up calling mathit.\n\n    // families\n    \"mathbb\": {\n        variant: \"double-struck\",\n        fontName: \"AMS-Regular\"\n    },\n    \"mathcal\": {\n        variant: \"script\",\n        fontName: \"Caligraphic-Regular\"\n    },\n    \"mathfrak\": {\n        variant: \"fraktur\",\n        fontName: \"Fraktur-Regular\"\n    },\n    \"mathscr\": {\n        variant: \"script\",\n        fontName: \"Script-Regular\"\n    },\n    \"mathsf\": {\n        variant: \"sans-serif\",\n        fontName: \"SansSerif-Regular\"\n    },\n    \"mathtt\": {\n        variant: \"monospace\",\n        fontName: \"Typewriter-Regular\"\n    }\n};\n\nmodule.exports = {\n    fontMap: fontMap,\n    makeSymbol: makeSymbol,\n    mathsym: mathsym,\n    makeSpan: makeSpan,\n    makeFragment: makeFragment,\n    makeVList: makeVList,\n    makeOrd: makeOrd,\n    prependChildren: prependChildren,\n    sizingMultiplier: sizingMultiplier,\n    spacingFunctions: spacingFunctions\n};\n"]},"metadata":{},"sourceType":"script"}