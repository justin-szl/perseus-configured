{"ast":null,"code":"/**\n * This file contains the “gullet” where macros are expanded\n * until only non-macro tokens remain.\n */\nvar Lexer = require(\"./Lexer\");\n\nfunction MacroExpander(input, macros) {\n  this.lexer = new Lexer(input);\n  this.macros = macros;\n  this.stack = []; // contains tokens in REVERSE order\n\n  this.discardedWhiteSpace = [];\n}\n/**\n * Recursively expand first token, then return first non-expandable token.\n */\n\n\nMacroExpander.prototype.nextToken = function () {\n  for (;;) {\n    if (this.stack.length === 0) {\n      this.stack.push(this.lexer.lex());\n    }\n\n    var topToken = this.stack.pop();\n    var name = topToken.text;\n\n    if (!(name.charAt(0) === \"\\\\\" && this.macros.hasOwnProperty(name))) {\n      return topToken;\n    }\n\n    var expansion = this.macros[name];\n\n    if (typeof expansion === \"string\") {\n      var bodyLexer = new Lexer(expansion);\n      expansion = [];\n      var tok = bodyLexer.lex();\n\n      while (tok.text !== \"EOF\") {\n        expansion.push(tok);\n        tok = bodyLexer.lex();\n      }\n\n      expansion.reverse(); // to fit in with stack using push and pop\n\n      this.macros[name] = expansion;\n    }\n\n    this.stack = this.stack.concat(expansion);\n  }\n};\n\nMacroExpander.prototype.get = function (ignoreSpace) {\n  this.discardedWhiteSpace = [];\n  var token = this.nextToken();\n\n  if (ignoreSpace) {\n    while (token.text === \" \") {\n      this.discardedWhiteSpace.push(token);\n      token = this.nextToken();\n    }\n  }\n\n  return token;\n};\n/**\n * Undo the effect of the preceding call to the get method.\n * A call to this method MUST be immediately preceded and immediately followed\n * by a call to get.  Only used during mode switching, i.e. after one token\n * was got in the old mode but should get got again in a new mode\n * with possibly different whitespace handling.\n */\n\n\nMacroExpander.prototype.unget = function (token) {\n  this.stack.push(token);\n\n  while (this.discardedWhiteSpace.length !== 0) {\n    this.stack.push(this.discardedWhiteSpace.pop());\n  }\n};\n\nmodule.exports = MacroExpander;","map":{"version":3,"sources":["/Users/justinf/perseus-configured/node_modules/katex/src/MacroExpander.js"],"names":["Lexer","require","MacroExpander","input","macros","lexer","stack","discardedWhiteSpace","prototype","nextToken","length","push","lex","topToken","pop","name","text","charAt","hasOwnProperty","expansion","bodyLexer","tok","reverse","concat","get","ignoreSpace","token","unget","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAAnB;;AAEA,SAASC,aAAT,CAAuBC,KAAvB,EAA8BC,MAA9B,EAAsC;AAClC,OAAKC,KAAL,GAAa,IAAIL,KAAJ,CAAUG,KAAV,CAAb;AACA,OAAKC,MAAL,GAAcA,MAAd;AACA,OAAKE,KAAL,GAAa,EAAb,CAHkC,CAGjB;;AACjB,OAAKC,mBAAL,GAA2B,EAA3B;AACH;AAED;AACA;AACA;;;AACAL,aAAa,CAACM,SAAd,CAAwBC,SAAxB,GAAoC,YAAW;AAC3C,WAAS;AACL,QAAI,KAAKH,KAAL,CAAWI,MAAX,KAAsB,CAA1B,EAA6B;AACzB,WAAKJ,KAAL,CAAWK,IAAX,CAAgB,KAAKN,KAAL,CAAWO,GAAX,EAAhB;AACH;;AACD,QAAIC,QAAQ,GAAG,KAAKP,KAAL,CAAWQ,GAAX,EAAf;AACA,QAAIC,IAAI,GAAGF,QAAQ,CAACG,IAApB;;AACA,QAAI,EAAED,IAAI,CAACE,MAAL,CAAY,CAAZ,MAAmB,IAAnB,IAA2B,KAAKb,MAAL,CAAYc,cAAZ,CAA2BH,IAA3B,CAA7B,CAAJ,EAAoE;AAChE,aAAOF,QAAP;AACH;;AACD,QAAIM,SAAS,GAAG,KAAKf,MAAL,CAAYW,IAAZ,CAAhB;;AACA,QAAI,OAAOI,SAAP,KAAqB,QAAzB,EAAmC;AAC/B,UAAIC,SAAS,GAAG,IAAIpB,KAAJ,CAAUmB,SAAV,CAAhB;AACAA,MAAAA,SAAS,GAAG,EAAZ;AACA,UAAIE,GAAG,GAAGD,SAAS,CAACR,GAAV,EAAV;;AACA,aAAOS,GAAG,CAACL,IAAJ,KAAa,KAApB,EAA2B;AACvBG,QAAAA,SAAS,CAACR,IAAV,CAAeU,GAAf;AACAA,QAAAA,GAAG,GAAGD,SAAS,CAACR,GAAV,EAAN;AACH;;AACDO,MAAAA,SAAS,CAACG,OAAV,GAR+B,CAQV;;AACrB,WAAKlB,MAAL,CAAYW,IAAZ,IAAoBI,SAApB;AACH;;AACD,SAAKb,KAAL,GAAa,KAAKA,KAAL,CAAWiB,MAAX,CAAkBJ,SAAlB,CAAb;AACH;AACJ,CAxBD;;AA0BAjB,aAAa,CAACM,SAAd,CAAwBgB,GAAxB,GAA8B,UAASC,WAAT,EAAsB;AAChD,OAAKlB,mBAAL,GAA2B,EAA3B;AACA,MAAImB,KAAK,GAAG,KAAKjB,SAAL,EAAZ;;AACA,MAAIgB,WAAJ,EAAiB;AACb,WAAOC,KAAK,CAACV,IAAN,KAAe,GAAtB,EAA2B;AACvB,WAAKT,mBAAL,CAAyBI,IAAzB,CAA8Be,KAA9B;AACAA,MAAAA,KAAK,GAAG,KAAKjB,SAAL,EAAR;AACH;AACJ;;AACD,SAAOiB,KAAP;AACH,CAVD;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAxB,aAAa,CAACM,SAAd,CAAwBmB,KAAxB,GAAgC,UAASD,KAAT,EAAgB;AAC5C,OAAKpB,KAAL,CAAWK,IAAX,CAAgBe,KAAhB;;AACA,SAAO,KAAKnB,mBAAL,CAAyBG,MAAzB,KAAoC,CAA3C,EAA8C;AAC1C,SAAKJ,KAAL,CAAWK,IAAX,CAAgB,KAAKJ,mBAAL,CAAyBO,GAAzB,EAAhB;AACH;AACJ,CALD;;AAOAc,MAAM,CAACC,OAAP,GAAiB3B,aAAjB","sourcesContent":["/**\n * This file contains the “gullet” where macros are expanded\n * until only non-macro tokens remain.\n */\n\nvar Lexer = require(\"./Lexer\");\n\nfunction MacroExpander(input, macros) {\n    this.lexer = new Lexer(input);\n    this.macros = macros;\n    this.stack = []; // contains tokens in REVERSE order\n    this.discardedWhiteSpace = [];\n}\n\n/**\n * Recursively expand first token, then return first non-expandable token.\n */\nMacroExpander.prototype.nextToken = function() {\n    for (;;) {\n        if (this.stack.length === 0) {\n            this.stack.push(this.lexer.lex());\n        }\n        var topToken = this.stack.pop();\n        var name = topToken.text;\n        if (!(name.charAt(0) === \"\\\\\" && this.macros.hasOwnProperty(name))) {\n            return topToken;\n        }\n        var expansion = this.macros[name];\n        if (typeof expansion === \"string\") {\n            var bodyLexer = new Lexer(expansion);\n            expansion = [];\n            var tok = bodyLexer.lex();\n            while (tok.text !== \"EOF\") {\n                expansion.push(tok);\n                tok = bodyLexer.lex();\n            }\n            expansion.reverse(); // to fit in with stack using push and pop\n            this.macros[name] = expansion;\n        }\n        this.stack = this.stack.concat(expansion);\n    }\n};\n\nMacroExpander.prototype.get = function(ignoreSpace) {\n    this.discardedWhiteSpace = [];\n    var token = this.nextToken();\n    if (ignoreSpace) {\n        while (token.text === \" \") {\n            this.discardedWhiteSpace.push(token);\n            token = this.nextToken();\n        }\n    }\n    return token;\n};\n\n/**\n * Undo the effect of the preceding call to the get method.\n * A call to this method MUST be immediately preceded and immediately followed\n * by a call to get.  Only used during mode switching, i.e. after one token\n * was got in the old mode but should get got again in a new mode\n * with possibly different whitespace handling.\n */\nMacroExpander.prototype.unget = function(token) {\n    this.stack.push(token);\n    while (this.discardedWhiteSpace.length !== 0) {\n        this.stack.push(this.discardedWhiteSpace.pop());\n    }\n};\n\nmodule.exports = MacroExpander;\n"]},"metadata":{},"sourceType":"script"}