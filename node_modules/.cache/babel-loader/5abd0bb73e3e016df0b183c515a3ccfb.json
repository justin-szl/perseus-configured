{"ast":null,"code":"/**\n * This file deals with creating delimiters of various sizes. The TeXbook\n * discusses these routines on page 441-442, in the \"Another subroutine sets box\n * x to a specified variable delimiter\" paragraph.\n *\n * There are three main routines here. `makeSmallDelim` makes a delimiter in the\n * normal font, but in either text, script, or scriptscript style.\n * `makeLargeDelim` makes a delimiter in textstyle, but in one of the Size1,\n * Size2, Size3, or Size4 fonts. `makeStackedDelim` makes a delimiter out of\n * smaller pieces that are stacked on top of one another.\n *\n * The functions take a parameter `center`, which determines if the delimiter\n * should be centered around the axis.\n *\n * Then, there are three exposed functions. `sizedDelim` makes a delimiter in\n * one of the given sizes. This is used for things like `\\bigl`.\n * `customSizedDelim` makes a delimiter with a given total height+depth. It is\n * called in places like `\\sqrt`. `leftRightDelim` makes an appropriate\n * delimiter which surrounds an expression of a given height an depth. It is\n * used in `\\left` and `\\right`.\n */\nvar ParseError = require(\"./ParseError\");\n\nvar Style = require(\"./Style\");\n\nvar buildCommon = require(\"./buildCommon\");\n\nvar fontMetrics = require(\"./fontMetrics\");\n\nvar symbols = require(\"./symbols\");\n\nvar utils = require(\"./utils\");\n\nvar makeSpan = buildCommon.makeSpan;\n/**\n * Get the metrics for a given symbol and font, after transformation (i.e.\n * after following replacement from symbols.js)\n */\n\nvar getMetrics = function (symbol, font) {\n  if (symbols.math[symbol] && symbols.math[symbol].replace) {\n    return fontMetrics.getCharacterMetrics(symbols.math[symbol].replace, font);\n  } else {\n    return fontMetrics.getCharacterMetrics(symbol, font);\n  }\n};\n/**\n * Builds a symbol in the given font size (note size is an integer)\n */\n\n\nvar mathrmSize = function (value, size, mode, options) {\n  return buildCommon.makeSymbol(value, \"Size\" + size + \"-Regular\", mode, options);\n};\n/**\n * Puts a delimiter span in a given style, and adds appropriate height, depth,\n * and maxFontSizes.\n */\n\n\nvar styleWrap = function (delim, toStyle, options, classes) {\n  classes = classes || [];\n  var span = makeSpan(classes.concat([\"style-wrap\", options.style.reset(), toStyle.cls()]), [delim], options);\n  var multiplier = toStyle.sizeMultiplier / options.style.sizeMultiplier;\n  span.height *= multiplier;\n  span.depth *= multiplier;\n  span.maxFontSize = toStyle.sizeMultiplier;\n  return span;\n};\n/**\n * Makes a small delimiter. This is a delimiter that comes in the Main-Regular\n * font, but is restyled to either be in textstyle, scriptstyle, or\n * scriptscriptstyle.\n */\n\n\nvar makeSmallDelim = function (delim, style, center, options, mode, classes) {\n  var text = buildCommon.makeSymbol(delim, \"Main-Regular\", mode, options);\n  var span = styleWrap(text, style, options, classes);\n\n  if (center) {\n    var shift = (1 - options.style.sizeMultiplier / style.sizeMultiplier) * options.style.metrics.axisHeight;\n    span.style.top = shift + \"em\";\n    span.height -= shift;\n    span.depth += shift;\n  }\n\n  return span;\n};\n/**\n * Makes a large delimiter. This is a delimiter that comes in the Size1, Size2,\n * Size3, or Size4 fonts. It is always rendered in textstyle.\n */\n\n\nvar makeLargeDelim = function (delim, size, center, options, mode, classes) {\n  var inner = mathrmSize(delim, size, mode, options);\n  var span = styleWrap(makeSpan([\"delimsizing\", \"size\" + size], [inner], options), Style.TEXT, options, classes);\n\n  if (center) {\n    var shift = (1 - options.style.sizeMultiplier) * options.style.metrics.axisHeight;\n    span.style.top = shift + \"em\";\n    span.height -= shift;\n    span.depth += shift;\n  }\n\n  return span;\n};\n/**\n * Make an inner span with the given offset and in the given font. This is used\n * in `makeStackedDelim` to make the stacking pieces for the delimiter.\n */\n\n\nvar makeInner = function (symbol, font, mode) {\n  var sizeClass; // Apply the correct CSS class to choose the right font.\n\n  if (font === \"Size1-Regular\") {\n    sizeClass = \"delim-size1\";\n  } else if (font === \"Size4-Regular\") {\n    sizeClass = \"delim-size4\";\n  }\n\n  var inner = makeSpan([\"delimsizinginner\", sizeClass], [makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]); // Since this will be passed into `makeVList` in the end, wrap the element\n  // in the appropriate tag that VList uses.\n\n  return {\n    type: \"elem\",\n    elem: inner\n  };\n};\n/**\n * Make a stacked delimiter out of a given delimiter, with the total height at\n * least `heightTotal`. This routine is mentioned on page 442 of the TeXbook.\n */\n\n\nvar makeStackedDelim = function (delim, heightTotal, center, options, mode, classes) {\n  // There are four parts, the top, an optional middle, a repeated part, and a\n  // bottom.\n  var top;\n  var middle;\n  var repeat;\n  var bottom;\n  top = repeat = bottom = delim;\n  middle = null; // Also keep track of what font the delimiters are in\n\n  var font = \"Size1-Regular\"; // We set the parts and font based on the symbol. Note that we use\n  // '\\u23d0' instead of '|' and '\\u2016' instead of '\\\\|' for the\n  // repeats of the arrows\n\n  if (delim === \"\\\\uparrow\") {\n    repeat = bottom = \"\\u23d0\";\n  } else if (delim === \"\\\\Uparrow\") {\n    repeat = bottom = \"\\u2016\";\n  } else if (delim === \"\\\\downarrow\") {\n    top = repeat = \"\\u23d0\";\n  } else if (delim === \"\\\\Downarrow\") {\n    top = repeat = \"\\u2016\";\n  } else if (delim === \"\\\\updownarrow\") {\n    top = \"\\\\uparrow\";\n    repeat = \"\\u23d0\";\n    bottom = \"\\\\downarrow\";\n  } else if (delim === \"\\\\Updownarrow\") {\n    top = \"\\\\Uparrow\";\n    repeat = \"\\u2016\";\n    bottom = \"\\\\Downarrow\";\n  } else if (delim === \"[\" || delim === \"\\\\lbrack\") {\n    top = \"\\u23a1\";\n    repeat = \"\\u23a2\";\n    bottom = \"\\u23a3\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"]\" || delim === \"\\\\rbrack\") {\n    top = \"\\u23a4\";\n    repeat = \"\\u23a5\";\n    bottom = \"\\u23a6\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\lfloor\") {\n    repeat = top = \"\\u23a2\";\n    bottom = \"\\u23a3\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\lceil\") {\n    top = \"\\u23a1\";\n    repeat = bottom = \"\\u23a2\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\rfloor\") {\n    repeat = top = \"\\u23a5\";\n    bottom = \"\\u23a6\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\rceil\") {\n    top = \"\\u23a4\";\n    repeat = bottom = \"\\u23a5\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"(\") {\n    top = \"\\u239b\";\n    repeat = \"\\u239c\";\n    bottom = \"\\u239d\";\n    font = \"Size4-Regular\";\n  } else if (delim === \")\") {\n    top = \"\\u239e\";\n    repeat = \"\\u239f\";\n    bottom = \"\\u23a0\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\{\" || delim === \"\\\\lbrace\") {\n    top = \"\\u23a7\";\n    middle = \"\\u23a8\";\n    bottom = \"\\u23a9\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\}\" || delim === \"\\\\rbrace\") {\n    top = \"\\u23ab\";\n    middle = \"\\u23ac\";\n    bottom = \"\\u23ad\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\lgroup\") {\n    top = \"\\u23a7\";\n    bottom = \"\\u23a9\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\rgroup\") {\n    top = \"\\u23ab\";\n    bottom = \"\\u23ad\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\lmoustache\") {\n    top = \"\\u23a7\";\n    bottom = \"\\u23ad\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\rmoustache\") {\n    top = \"\\u23ab\";\n    bottom = \"\\u23a9\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\surd\") {\n    top = \"\\ue001\";\n    bottom = \"\\u23b7\";\n    repeat = \"\\ue000\";\n    font = \"Size4-Regular\";\n  } // Get the metrics of the four sections\n\n\n  var topMetrics = getMetrics(top, font);\n  var topHeightTotal = topMetrics.height + topMetrics.depth;\n  var repeatMetrics = getMetrics(repeat, font);\n  var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;\n  var bottomMetrics = getMetrics(bottom, font);\n  var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;\n  var middleHeightTotal = 0;\n  var middleFactor = 1;\n\n  if (middle !== null) {\n    var middleMetrics = getMetrics(middle, font);\n    middleHeightTotal = middleMetrics.height + middleMetrics.depth;\n    middleFactor = 2; // repeat symmetrically above and below middle\n  } // Calcuate the minimal height that the delimiter can have.\n  // It is at least the size of the top, bottom, and optional middle combined.\n\n\n  var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal; // Compute the number of copies of the repeat symbol we will need\n\n  var repeatCount = Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)); // Compute the total height of the delimiter including all the symbols\n\n  var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal; // The center of the delimiter is placed at the center of the axis. Note\n  // that in this context, \"center\" means that the delimiter should be\n  // centered around the axis in the current style, while normally it is\n  // centered around the axis in textstyle.\n\n  var axisHeight = options.style.metrics.axisHeight;\n\n  if (center) {\n    axisHeight *= options.style.sizeMultiplier;\n  } // Calculate the depth\n\n\n  var depth = realHeightTotal / 2 - axisHeight; // Now, we start building the pieces that will go into the vlist\n  // Keep a list of the inner pieces\n\n  var inners = []; // Add the bottom symbol\n\n  inners.push(makeInner(bottom, font, mode));\n  var i;\n\n  if (middle === null) {\n    // Add that many symbols\n    for (i = 0; i < repeatCount; i++) {\n      inners.push(makeInner(repeat, font, mode));\n    }\n  } else {\n    // When there is a middle bit, we need the middle part and two repeated\n    // sections\n    for (i = 0; i < repeatCount; i++) {\n      inners.push(makeInner(repeat, font, mode));\n    }\n\n    inners.push(makeInner(middle, font, mode));\n\n    for (i = 0; i < repeatCount; i++) {\n      inners.push(makeInner(repeat, font, mode));\n    }\n  } // Add the top symbol\n\n\n  inners.push(makeInner(top, font, mode)); // Finally, build the vlist\n\n  var inner = buildCommon.makeVList(inners, \"bottom\", depth, options);\n  return styleWrap(makeSpan([\"delimsizing\", \"mult\"], [inner], options), Style.TEXT, options, classes);\n}; // There are three kinds of delimiters, delimiters that stack when they become\n// too large\n\n\nvar stackLargeDelimiters = [\"(\", \")\", \"[\", \"\\\\lbrack\", \"]\", \"\\\\rbrack\", \"\\\\{\", \"\\\\lbrace\", \"\\\\}\", \"\\\\rbrace\", \"\\\\lfloor\", \"\\\\rfloor\", \"\\\\lceil\", \"\\\\rceil\", \"\\\\surd\"]; // delimiters that always stack\n\nvar stackAlwaysDelimiters = [\"\\\\uparrow\", \"\\\\downarrow\", \"\\\\updownarrow\", \"\\\\Uparrow\", \"\\\\Downarrow\", \"\\\\Updownarrow\", \"|\", \"\\\\|\", \"\\\\vert\", \"\\\\Vert\", \"\\\\lvert\", \"\\\\rvert\", \"\\\\lVert\", \"\\\\rVert\", \"\\\\lgroup\", \"\\\\rgroup\", \"\\\\lmoustache\", \"\\\\rmoustache\"]; // and delimiters that never stack\n\nvar stackNeverDelimiters = [\"<\", \">\", \"\\\\langle\", \"\\\\rangle\", \"/\", \"\\\\backslash\", \"\\\\lt\", \"\\\\gt\"]; // Metrics of the different sizes. Found by looking at TeX's output of\n// $\\bigl| // \\Bigl| \\biggl| \\Biggl| \\showlists$\n// Used to create stacked delimiters of appropriate sizes in makeSizedDelim.\n\nvar sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];\n/**\n * Used to create a delimiter of a specific size, where `size` is 1, 2, 3, or 4.\n */\n\nvar makeSizedDelim = function (delim, size, options, mode, classes) {\n  // < and > turn into \\langle and \\rangle in delimiters\n  if (delim === \"<\" || delim === \"\\\\lt\") {\n    delim = \"\\\\langle\";\n  } else if (delim === \">\" || delim === \"\\\\gt\") {\n    delim = \"\\\\rangle\";\n  } // Sized delimiters are never centered.\n\n\n  if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {\n    return makeLargeDelim(delim, size, false, options, mode, classes);\n  } else if (utils.contains(stackAlwaysDelimiters, delim)) {\n    return makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);\n  } else {\n    throw new ParseError(\"Illegal delimiter: '\" + delim + \"'\");\n  }\n};\n/**\n * There are three different sequences of delimiter sizes that the delimiters\n * follow depending on the kind of delimiter. This is used when creating custom\n * sized delimiters to decide whether to create a small, large, or stacked\n * delimiter.\n *\n * In real TeX, these sequences aren't explicitly defined, but are instead\n * defined inside the font metrics. Since there are only three sequences that\n * are possible for the delimiters that TeX defines, it is easier to just encode\n * them explicitly here.\n */\n// Delimiters that never stack try small delimiters and large delimiters only\n\n\nvar stackNeverDelimiterSequence = [{\n  type: \"small\",\n  style: Style.SCRIPTSCRIPT\n}, {\n  type: \"small\",\n  style: Style.SCRIPT\n}, {\n  type: \"small\",\n  style: Style.TEXT\n}, {\n  type: \"large\",\n  size: 1\n}, {\n  type: \"large\",\n  size: 2\n}, {\n  type: \"large\",\n  size: 3\n}, {\n  type: \"large\",\n  size: 4\n}]; // Delimiters that always stack try the small delimiters first, then stack\n\nvar stackAlwaysDelimiterSequence = [{\n  type: \"small\",\n  style: Style.SCRIPTSCRIPT\n}, {\n  type: \"small\",\n  style: Style.SCRIPT\n}, {\n  type: \"small\",\n  style: Style.TEXT\n}, {\n  type: \"stack\"\n}]; // Delimiters that stack when large try the small and then large delimiters, and\n// stack afterwards\n\nvar stackLargeDelimiterSequence = [{\n  type: \"small\",\n  style: Style.SCRIPTSCRIPT\n}, {\n  type: \"small\",\n  style: Style.SCRIPT\n}, {\n  type: \"small\",\n  style: Style.TEXT\n}, {\n  type: \"large\",\n  size: 1\n}, {\n  type: \"large\",\n  size: 2\n}, {\n  type: \"large\",\n  size: 3\n}, {\n  type: \"large\",\n  size: 4\n}, {\n  type: \"stack\"\n}];\n/**\n * Get the font used in a delimiter based on what kind of delimiter it is.\n */\n\nvar delimTypeToFont = function (type) {\n  if (type.type === \"small\") {\n    return \"Main-Regular\";\n  } else if (type.type === \"large\") {\n    return \"Size\" + type.size + \"-Regular\";\n  } else if (type.type === \"stack\") {\n    return \"Size4-Regular\";\n  }\n};\n/**\n * Traverse a sequence of types of delimiters to decide what kind of delimiter\n * should be used to create a delimiter of the given height+depth.\n */\n\n\nvar traverseSequence = function (delim, height, sequence, options) {\n  // Here, we choose the index we should start at in the sequences. In smaller\n  // sizes (which correspond to larger numbers in style.size) we start earlier\n  // in the sequence. Thus, scriptscript starts at index 3-3=0, script starts\n  // at index 3-2=1, text starts at 3-1=2, and display starts at min(2,3-0)=2\n  var start = Math.min(2, 3 - options.style.size);\n\n  for (var i = start; i < sequence.length; i++) {\n    if (sequence[i].type === \"stack\") {\n      // This is always the last delimiter, so we just break the loop now.\n      break;\n    }\n\n    var metrics = getMetrics(delim, delimTypeToFont(sequence[i]));\n    var heightDepth = metrics.height + metrics.depth; // Small delimiters are scaled down versions of the same font, so we\n    // account for the style change size.\n\n    if (sequence[i].type === \"small\") {\n      heightDepth *= sequence[i].style.sizeMultiplier;\n    } // Check if the delimiter at this size works for the given height.\n\n\n    if (heightDepth > height) {\n      return sequence[i];\n    }\n  } // If we reached the end of the sequence, return the last sequence element.\n\n\n  return sequence[sequence.length - 1];\n};\n/**\n * Make a delimiter of a given height+depth, with optional centering. Here, we\n * traverse the sequences, and create a delimiter that the sequence tells us to.\n */\n\n\nvar makeCustomSizedDelim = function (delim, height, center, options, mode, classes) {\n  if (delim === \"<\" || delim === \"\\\\lt\") {\n    delim = \"\\\\langle\";\n  } else if (delim === \">\" || delim === \"\\\\gt\") {\n    delim = \"\\\\rangle\";\n  } // Decide what sequence to use\n\n\n  var sequence;\n\n  if (utils.contains(stackNeverDelimiters, delim)) {\n    sequence = stackNeverDelimiterSequence;\n  } else if (utils.contains(stackLargeDelimiters, delim)) {\n    sequence = stackLargeDelimiterSequence;\n  } else {\n    sequence = stackAlwaysDelimiterSequence;\n  } // Look through the sequence\n\n\n  var delimType = traverseSequence(delim, height, sequence, options); // Depending on the sequence element we decided on, call the appropriate\n  // function.\n\n  if (delimType.type === \"small\") {\n    return makeSmallDelim(delim, delimType.style, center, options, mode, classes);\n  } else if (delimType.type === \"large\") {\n    return makeLargeDelim(delim, delimType.size, center, options, mode, classes);\n  } else if (delimType.type === \"stack\") {\n    return makeStackedDelim(delim, height, center, options, mode, classes);\n  }\n};\n/**\n * Make a delimiter for use with `\\left` and `\\right`, given a height and depth\n * of an expression that the delimiters surround.\n */\n\n\nvar makeLeftRightDelim = function (delim, height, depth, options, mode, classes) {\n  // We always center \\left/\\right delimiters, so the axis is always shifted\n  var axisHeight = options.style.metrics.axisHeight * options.style.sizeMultiplier; // Taken from TeX source, tex.web, function make_left_right\n\n  var delimiterFactor = 901;\n  var delimiterExtend = 5.0 / fontMetrics.metrics.ptPerEm;\n  var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);\n  var totalHeight = Math.max( // In real TeX, calculations are done using integral values which are\n  // 65536 per pt, or 655360 per em. So, the division here truncates in\n  // TeX but doesn't here, producing different results. If we wanted to\n  // exactly match TeX's calculation, we could do\n  //   Math.floor(655360 * maxDistFromAxis / 500) *\n  //    delimiterFactor / 655360\n  // (To see the difference, compare\n  //    x^{x^{\\left(\\rule{0.1em}{0.68em}\\right)}}\n  // in TeX and KaTeX)\n  maxDistFromAxis / 500 * delimiterFactor, 2 * maxDistFromAxis - delimiterExtend); // Finally, we defer to `makeCustomSizedDelim` with our calculated total\n  // height\n\n  return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);\n};\n\nmodule.exports = {\n  sizedDelim: makeSizedDelim,\n  customSizedDelim: makeCustomSizedDelim,\n  leftRightDelim: makeLeftRightDelim\n};","map":{"version":3,"sources":["/Users/justinf/perseus-configured/node_modules/katex/src/delimiter.js"],"names":["ParseError","require","Style","buildCommon","fontMetrics","symbols","utils","makeSpan","getMetrics","symbol","font","math","replace","getCharacterMetrics","mathrmSize","value","size","mode","options","makeSymbol","styleWrap","delim","toStyle","classes","span","concat","style","reset","cls","multiplier","sizeMultiplier","height","depth","maxFontSize","makeSmallDelim","center","text","shift","metrics","axisHeight","top","makeLargeDelim","inner","TEXT","makeInner","sizeClass","type","elem","makeStackedDelim","heightTotal","middle","repeat","bottom","topMetrics","topHeightTotal","repeatMetrics","repeatHeightTotal","bottomMetrics","bottomHeightTotal","middleHeightTotal","middleFactor","middleMetrics","minHeight","repeatCount","Math","ceil","realHeightTotal","inners","push","i","makeVList","stackLargeDelimiters","stackAlwaysDelimiters","stackNeverDelimiters","sizeToMaxHeight","makeSizedDelim","contains","stackNeverDelimiterSequence","SCRIPTSCRIPT","SCRIPT","stackAlwaysDelimiterSequence","stackLargeDelimiterSequence","delimTypeToFont","traverseSequence","sequence","start","min","length","heightDepth","makeCustomSizedDelim","delimType","makeLeftRightDelim","delimiterFactor","delimiterExtend","ptPerEm","maxDistFromAxis","max","totalHeight","module","exports","sizedDelim","customSizedDelim","leftRightDelim"],"mappings":"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","sourcesContent":["/**\n * This file deals with creating delimiters of various sizes. The TeXbook\n * discusses these routines on page 441-442, in the \"Another subroutine sets box\n * x to a specified variable delimiter\" paragraph.\n *\n * There are three main routines here. `makeSmallDelim` makes a delimiter in the\n * normal font, but in either text, script, or scriptscript style.\n * `makeLargeDelim` makes a delimiter in textstyle, but in one of the Size1,\n * Size2, Size3, or Size4 fonts. `makeStackedDelim` makes a delimiter out of\n * smaller pieces that are stacked on top of one another.\n *\n * The functions take a parameter `center`, which determines if the delimiter\n * should be centered around the axis.\n *\n * Then, there are three exposed functions. `sizedDelim` makes a delimiter in\n * one of the given sizes. This is used for things like `\\bigl`.\n * `customSizedDelim` makes a delimiter with a given total height+depth. It is\n * called in places like `\\sqrt`. `leftRightDelim` makes an appropriate\n * delimiter which surrounds an expression of a given height an depth. It is\n * used in `\\left` and `\\right`.\n */\n\nvar ParseError = require(\"./ParseError\");\nvar Style = require(\"./Style\");\n\nvar buildCommon = require(\"./buildCommon\");\nvar fontMetrics = require(\"./fontMetrics\");\nvar symbols = require(\"./symbols\");\nvar utils = require(\"./utils\");\n\nvar makeSpan = buildCommon.makeSpan;\n\n/**\n * Get the metrics for a given symbol and font, after transformation (i.e.\n * after following replacement from symbols.js)\n */\nvar getMetrics = function(symbol, font) {\n    if (symbols.math[symbol] && symbols.math[symbol].replace) {\n        return fontMetrics.getCharacterMetrics(\n            symbols.math[symbol].replace, font);\n    } else {\n        return fontMetrics.getCharacterMetrics(\n            symbol, font);\n    }\n};\n\n/**\n * Builds a symbol in the given font size (note size is an integer)\n */\nvar mathrmSize = function(value, size, mode, options) {\n    return buildCommon.makeSymbol(value, \"Size\" + size + \"-Regular\",\n        mode, options);\n};\n\n/**\n * Puts a delimiter span in a given style, and adds appropriate height, depth,\n * and maxFontSizes.\n */\nvar styleWrap = function(delim, toStyle, options, classes) {\n    classes = classes || [];\n    var span = makeSpan(\n        classes.concat([\"style-wrap\", options.style.reset(), toStyle.cls()]),\n        [delim], options);\n\n    var multiplier = toStyle.sizeMultiplier / options.style.sizeMultiplier;\n\n    span.height *= multiplier;\n    span.depth *= multiplier;\n    span.maxFontSize = toStyle.sizeMultiplier;\n\n    return span;\n};\n\n/**\n * Makes a small delimiter. This is a delimiter that comes in the Main-Regular\n * font, but is restyled to either be in textstyle, scriptstyle, or\n * scriptscriptstyle.\n */\nvar makeSmallDelim = function(delim, style, center, options, mode, classes) {\n    var text = buildCommon.makeSymbol(delim, \"Main-Regular\", mode, options);\n\n    var span = styleWrap(text, style, options, classes);\n\n    if (center) {\n        var shift =\n            (1 - options.style.sizeMultiplier / style.sizeMultiplier) *\n            options.style.metrics.axisHeight;\n\n        span.style.top = shift + \"em\";\n        span.height -= shift;\n        span.depth += shift;\n    }\n\n    return span;\n};\n\n/**\n * Makes a large delimiter. This is a delimiter that comes in the Size1, Size2,\n * Size3, or Size4 fonts. It is always rendered in textstyle.\n */\nvar makeLargeDelim = function(delim, size, center, options, mode, classes) {\n    var inner = mathrmSize(delim, size, mode, options);\n\n    var span = styleWrap(\n        makeSpan([\"delimsizing\", \"size\" + size], [inner], options),\n        Style.TEXT, options, classes);\n\n    if (center) {\n        var shift = (1 - options.style.sizeMultiplier) *\n            options.style.metrics.axisHeight;\n\n        span.style.top = shift + \"em\";\n        span.height -= shift;\n        span.depth += shift;\n    }\n\n    return span;\n};\n\n/**\n * Make an inner span with the given offset and in the given font. This is used\n * in `makeStackedDelim` to make the stacking pieces for the delimiter.\n */\nvar makeInner = function(symbol, font, mode) {\n    var sizeClass;\n    // Apply the correct CSS class to choose the right font.\n    if (font === \"Size1-Regular\") {\n        sizeClass = \"delim-size1\";\n    } else if (font === \"Size4-Regular\") {\n        sizeClass = \"delim-size4\";\n    }\n\n    var inner = makeSpan(\n        [\"delimsizinginner\", sizeClass],\n        [makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);\n\n    // Since this will be passed into `makeVList` in the end, wrap the element\n    // in the appropriate tag that VList uses.\n    return {type: \"elem\", elem: inner};\n};\n\n/**\n * Make a stacked delimiter out of a given delimiter, with the total height at\n * least `heightTotal`. This routine is mentioned on page 442 of the TeXbook.\n */\nvar makeStackedDelim = function(delim, heightTotal, center, options, mode,\n                                classes) {\n    // There are four parts, the top, an optional middle, a repeated part, and a\n    // bottom.\n    var top;\n    var middle;\n    var repeat;\n    var bottom;\n    top = repeat = bottom = delim;\n    middle = null;\n    // Also keep track of what font the delimiters are in\n    var font = \"Size1-Regular\";\n\n    // We set the parts and font based on the symbol. Note that we use\n    // '\\u23d0' instead of '|' and '\\u2016' instead of '\\\\|' for the\n    // repeats of the arrows\n    if (delim === \"\\\\uparrow\") {\n        repeat = bottom = \"\\u23d0\";\n    } else if (delim === \"\\\\Uparrow\") {\n        repeat = bottom = \"\\u2016\";\n    } else if (delim === \"\\\\downarrow\") {\n        top = repeat = \"\\u23d0\";\n    } else if (delim === \"\\\\Downarrow\") {\n        top = repeat = \"\\u2016\";\n    } else if (delim === \"\\\\updownarrow\") {\n        top = \"\\\\uparrow\";\n        repeat = \"\\u23d0\";\n        bottom = \"\\\\downarrow\";\n    } else if (delim === \"\\\\Updownarrow\") {\n        top = \"\\\\Uparrow\";\n        repeat = \"\\u2016\";\n        bottom = \"\\\\Downarrow\";\n    } else if (delim === \"[\" || delim === \"\\\\lbrack\") {\n        top = \"\\u23a1\";\n        repeat = \"\\u23a2\";\n        bottom = \"\\u23a3\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"]\" || delim === \"\\\\rbrack\") {\n        top = \"\\u23a4\";\n        repeat = \"\\u23a5\";\n        bottom = \"\\u23a6\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"\\\\lfloor\") {\n        repeat = top = \"\\u23a2\";\n        bottom = \"\\u23a3\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"\\\\lceil\") {\n        top = \"\\u23a1\";\n        repeat = bottom = \"\\u23a2\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"\\\\rfloor\") {\n        repeat = top = \"\\u23a5\";\n        bottom = \"\\u23a6\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"\\\\rceil\") {\n        top = \"\\u23a4\";\n        repeat = bottom = \"\\u23a5\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"(\") {\n        top = \"\\u239b\";\n        repeat = \"\\u239c\";\n        bottom = \"\\u239d\";\n        font = \"Size4-Regular\";\n    } else if (delim === \")\") {\n        top = \"\\u239e\";\n        repeat = \"\\u239f\";\n        bottom = \"\\u23a0\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"\\\\{\" || delim === \"\\\\lbrace\") {\n        top = \"\\u23a7\";\n        middle = \"\\u23a8\";\n        bottom = \"\\u23a9\";\n        repeat = \"\\u23aa\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"\\\\}\" || delim === \"\\\\rbrace\") {\n        top = \"\\u23ab\";\n        middle = \"\\u23ac\";\n        bottom = \"\\u23ad\";\n        repeat = \"\\u23aa\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"\\\\lgroup\") {\n        top = \"\\u23a7\";\n        bottom = \"\\u23a9\";\n        repeat = \"\\u23aa\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"\\\\rgroup\") {\n        top = \"\\u23ab\";\n        bottom = \"\\u23ad\";\n        repeat = \"\\u23aa\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"\\\\lmoustache\") {\n        top = \"\\u23a7\";\n        bottom = \"\\u23ad\";\n        repeat = \"\\u23aa\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"\\\\rmoustache\") {\n        top = \"\\u23ab\";\n        bottom = \"\\u23a9\";\n        repeat = \"\\u23aa\";\n        font = \"Size4-Regular\";\n    } else if (delim === \"\\\\surd\") {\n        top = \"\\ue001\";\n        bottom = \"\\u23b7\";\n        repeat = \"\\ue000\";\n        font = \"Size4-Regular\";\n    }\n\n    // Get the metrics of the four sections\n    var topMetrics = getMetrics(top, font);\n    var topHeightTotal = topMetrics.height + topMetrics.depth;\n    var repeatMetrics = getMetrics(repeat, font);\n    var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;\n    var bottomMetrics = getMetrics(bottom, font);\n    var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;\n    var middleHeightTotal = 0;\n    var middleFactor = 1;\n    if (middle !== null) {\n        var middleMetrics = getMetrics(middle, font);\n        middleHeightTotal = middleMetrics.height + middleMetrics.depth;\n        middleFactor = 2; // repeat symmetrically above and below middle\n    }\n\n    // Calcuate the minimal height that the delimiter can have.\n    // It is at least the size of the top, bottom, and optional middle combined.\n    var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;\n\n    // Compute the number of copies of the repeat symbol we will need\n    var repeatCount = Math.ceil(\n        (heightTotal - minHeight) / (middleFactor * repeatHeightTotal));\n\n    // Compute the total height of the delimiter including all the symbols\n    var realHeightTotal =\n        minHeight + repeatCount * middleFactor * repeatHeightTotal;\n\n    // The center of the delimiter is placed at the center of the axis. Note\n    // that in this context, \"center\" means that the delimiter should be\n    // centered around the axis in the current style, while normally it is\n    // centered around the axis in textstyle.\n    var axisHeight = options.style.metrics.axisHeight;\n    if (center) {\n        axisHeight *= options.style.sizeMultiplier;\n    }\n    // Calculate the depth\n    var depth = realHeightTotal / 2 - axisHeight;\n\n    // Now, we start building the pieces that will go into the vlist\n\n    // Keep a list of the inner pieces\n    var inners = [];\n\n    // Add the bottom symbol\n    inners.push(makeInner(bottom, font, mode));\n\n    var i;\n    if (middle === null) {\n        // Add that many symbols\n        for (i = 0; i < repeatCount; i++) {\n            inners.push(makeInner(repeat, font, mode));\n        }\n    } else {\n        // When there is a middle bit, we need the middle part and two repeated\n        // sections\n        for (i = 0; i < repeatCount; i++) {\n            inners.push(makeInner(repeat, font, mode));\n        }\n        inners.push(makeInner(middle, font, mode));\n        for (i = 0; i < repeatCount; i++) {\n            inners.push(makeInner(repeat, font, mode));\n        }\n    }\n\n    // Add the top symbol\n    inners.push(makeInner(top, font, mode));\n\n    // Finally, build the vlist\n    var inner = buildCommon.makeVList(inners, \"bottom\", depth, options);\n\n    return styleWrap(\n        makeSpan([\"delimsizing\", \"mult\"], [inner], options),\n        Style.TEXT, options, classes);\n};\n\n// There are three kinds of delimiters, delimiters that stack when they become\n// too large\nvar stackLargeDelimiters = [\n    \"(\", \")\", \"[\", \"\\\\lbrack\", \"]\", \"\\\\rbrack\",\n    \"\\\\{\", \"\\\\lbrace\", \"\\\\}\", \"\\\\rbrace\",\n    \"\\\\lfloor\", \"\\\\rfloor\", \"\\\\lceil\", \"\\\\rceil\",\n    \"\\\\surd\"\n];\n\n// delimiters that always stack\nvar stackAlwaysDelimiters = [\n    \"\\\\uparrow\", \"\\\\downarrow\", \"\\\\updownarrow\",\n    \"\\\\Uparrow\", \"\\\\Downarrow\", \"\\\\Updownarrow\",\n    \"|\", \"\\\\|\", \"\\\\vert\", \"\\\\Vert\",\n    \"\\\\lvert\", \"\\\\rvert\", \"\\\\lVert\", \"\\\\rVert\",\n    \"\\\\lgroup\", \"\\\\rgroup\", \"\\\\lmoustache\", \"\\\\rmoustache\"\n];\n\n// and delimiters that never stack\nvar stackNeverDelimiters = [\n    \"<\", \">\", \"\\\\langle\", \"\\\\rangle\", \"/\", \"\\\\backslash\", \"\\\\lt\", \"\\\\gt\"\n];\n\n// Metrics of the different sizes. Found by looking at TeX's output of\n// $\\bigl| // \\Bigl| \\biggl| \\Biggl| \\showlists$\n// Used to create stacked delimiters of appropriate sizes in makeSizedDelim.\nvar sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];\n\n/**\n * Used to create a delimiter of a specific size, where `size` is 1, 2, 3, or 4.\n */\nvar makeSizedDelim = function(delim, size, options, mode, classes) {\n    // < and > turn into \\langle and \\rangle in delimiters\n    if (delim === \"<\" || delim === \"\\\\lt\") {\n        delim = \"\\\\langle\";\n    } else if (delim === \">\" || delim === \"\\\\gt\") {\n        delim = \"\\\\rangle\";\n    }\n\n    // Sized delimiters are never centered.\n    if (utils.contains(stackLargeDelimiters, delim) ||\n        utils.contains(stackNeverDelimiters, delim)) {\n        return makeLargeDelim(delim, size, false, options, mode, classes);\n    } else if (utils.contains(stackAlwaysDelimiters, delim)) {\n        return makeStackedDelim(\n            delim, sizeToMaxHeight[size], false, options, mode, classes);\n    } else {\n        throw new ParseError(\"Illegal delimiter: '\" + delim + \"'\");\n    }\n};\n\n/**\n * There are three different sequences of delimiter sizes that the delimiters\n * follow depending on the kind of delimiter. This is used when creating custom\n * sized delimiters to decide whether to create a small, large, or stacked\n * delimiter.\n *\n * In real TeX, these sequences aren't explicitly defined, but are instead\n * defined inside the font metrics. Since there are only three sequences that\n * are possible for the delimiters that TeX defines, it is easier to just encode\n * them explicitly here.\n */\n\n// Delimiters that never stack try small delimiters and large delimiters only\nvar stackNeverDelimiterSequence = [\n    {type: \"small\", style: Style.SCRIPTSCRIPT},\n    {type: \"small\", style: Style.SCRIPT},\n    {type: \"small\", style: Style.TEXT},\n    {type: \"large\", size: 1},\n    {type: \"large\", size: 2},\n    {type: \"large\", size: 3},\n    {type: \"large\", size: 4}\n];\n\n// Delimiters that always stack try the small delimiters first, then stack\nvar stackAlwaysDelimiterSequence = [\n    {type: \"small\", style: Style.SCRIPTSCRIPT},\n    {type: \"small\", style: Style.SCRIPT},\n    {type: \"small\", style: Style.TEXT},\n    {type: \"stack\"}\n];\n\n// Delimiters that stack when large try the small and then large delimiters, and\n// stack afterwards\nvar stackLargeDelimiterSequence = [\n    {type: \"small\", style: Style.SCRIPTSCRIPT},\n    {type: \"small\", style: Style.SCRIPT},\n    {type: \"small\", style: Style.TEXT},\n    {type: \"large\", size: 1},\n    {type: \"large\", size: 2},\n    {type: \"large\", size: 3},\n    {type: \"large\", size: 4},\n    {type: \"stack\"}\n];\n\n/**\n * Get the font used in a delimiter based on what kind of delimiter it is.\n */\nvar delimTypeToFont = function(type) {\n    if (type.type === \"small\") {\n        return \"Main-Regular\";\n    } else if (type.type === \"large\") {\n        return \"Size\" + type.size + \"-Regular\";\n    } else if (type.type === \"stack\") {\n        return \"Size4-Regular\";\n    }\n};\n\n/**\n * Traverse a sequence of types of delimiters to decide what kind of delimiter\n * should be used to create a delimiter of the given height+depth.\n */\nvar traverseSequence = function(delim, height, sequence, options) {\n    // Here, we choose the index we should start at in the sequences. In smaller\n    // sizes (which correspond to larger numbers in style.size) we start earlier\n    // in the sequence. Thus, scriptscript starts at index 3-3=0, script starts\n    // at index 3-2=1, text starts at 3-1=2, and display starts at min(2,3-0)=2\n    var start = Math.min(2, 3 - options.style.size);\n    for (var i = start; i < sequence.length; i++) {\n        if (sequence[i].type === \"stack\") {\n            // This is always the last delimiter, so we just break the loop now.\n            break;\n        }\n\n        var metrics = getMetrics(delim, delimTypeToFont(sequence[i]));\n        var heightDepth = metrics.height + metrics.depth;\n\n        // Small delimiters are scaled down versions of the same font, so we\n        // account for the style change size.\n\n        if (sequence[i].type === \"small\") {\n            heightDepth *= sequence[i].style.sizeMultiplier;\n        }\n\n        // Check if the delimiter at this size works for the given height.\n        if (heightDepth > height) {\n            return sequence[i];\n        }\n    }\n\n    // If we reached the end of the sequence, return the last sequence element.\n    return sequence[sequence.length - 1];\n};\n\n/**\n * Make a delimiter of a given height+depth, with optional centering. Here, we\n * traverse the sequences, and create a delimiter that the sequence tells us to.\n */\nvar makeCustomSizedDelim = function(delim, height, center, options, mode,\n                                    classes) {\n    if (delim === \"<\" || delim === \"\\\\lt\") {\n        delim = \"\\\\langle\";\n    } else if (delim === \">\" || delim === \"\\\\gt\") {\n        delim = \"\\\\rangle\";\n    }\n\n    // Decide what sequence to use\n    var sequence;\n    if (utils.contains(stackNeverDelimiters, delim)) {\n        sequence = stackNeverDelimiterSequence;\n    } else if (utils.contains(stackLargeDelimiters, delim)) {\n        sequence = stackLargeDelimiterSequence;\n    } else {\n        sequence = stackAlwaysDelimiterSequence;\n    }\n\n    // Look through the sequence\n    var delimType = traverseSequence(delim, height, sequence, options);\n\n    // Depending on the sequence element we decided on, call the appropriate\n    // function.\n    if (delimType.type === \"small\") {\n        return makeSmallDelim(delim, delimType.style, center, options, mode,\n                              classes);\n    } else if (delimType.type === \"large\") {\n        return makeLargeDelim(delim, delimType.size, center, options, mode,\n                              classes);\n    } else if (delimType.type === \"stack\") {\n        return makeStackedDelim(delim, height, center, options, mode, classes);\n    }\n};\n\n/**\n * Make a delimiter for use with `\\left` and `\\right`, given a height and depth\n * of an expression that the delimiters surround.\n */\nvar makeLeftRightDelim = function(delim, height, depth, options, mode,\n                                  classes) {\n    // We always center \\left/\\right delimiters, so the axis is always shifted\n    var axisHeight =\n        options.style.metrics.axisHeight * options.style.sizeMultiplier;\n\n    // Taken from TeX source, tex.web, function make_left_right\n    var delimiterFactor = 901;\n    var delimiterExtend = 5.0 / fontMetrics.metrics.ptPerEm;\n\n    var maxDistFromAxis = Math.max(\n        height - axisHeight, depth + axisHeight);\n\n    var totalHeight = Math.max(\n        // In real TeX, calculations are done using integral values which are\n        // 65536 per pt, or 655360 per em. So, the division here truncates in\n        // TeX but doesn't here, producing different results. If we wanted to\n        // exactly match TeX's calculation, we could do\n        //   Math.floor(655360 * maxDistFromAxis / 500) *\n        //    delimiterFactor / 655360\n        // (To see the difference, compare\n        //    x^{x^{\\left(\\rule{0.1em}{0.68em}\\right)}}\n        // in TeX and KaTeX)\n        maxDistFromAxis / 500 * delimiterFactor,\n        2 * maxDistFromAxis - delimiterExtend);\n\n    // Finally, we defer to `makeCustomSizedDelim` with our calculated total\n    // height\n    return makeCustomSizedDelim(delim, totalHeight, true, options, mode,\n                                classes);\n};\n\nmodule.exports = {\n    sizedDelim: makeSizedDelim,\n    customSizedDelim: makeCustomSizedDelim,\n    leftRightDelim: makeLeftRightDelim\n};\n"]},"metadata":{},"sourceType":"script"}