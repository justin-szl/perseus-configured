{"ast":null,"code":"/* eslint-disable */\n(function () {\n  React = window.React; // Perseus running in local mode depends on $_, which is defined here\n\n  if (typeof React !== 'undefined') {\n    var createFragment = React.__internalAddons.createFragment;\n  } // The plural language strings for all the languages we have\n  // listed in crowdin.  The values here need to match what crowdin\n  // uses (sometimes different platforms use different plural forms,\n  // for ambiguous languages like Turkish).  I got it by running\n  //    deploy/download_i18n.py -s\n  // and looking a the .po files in all.zip.  Each .po file has a\n  // header line that say something like:\n  //    \"Plural-Forms: nplurals=2; plural=(n != 1);\\n\"\n  // which I copied in here with the following changes:\n  //    1) I only take the 'plural=' section, which I wrapped in a function\n  //    2) Changed 'or' to '||'\n  // These functions return either true or false or a number.  We map\n  // true to 1 and false to 0 below, to always get a number out of this.\n\n  /* eslint-disable space-infix-ops, eqeqeq, max-len */\n\n\n  var likeEnglish = function (n) {\n    return n != 1;\n  }; // TODO(csilvers): auto-generate this list from the foo.po files (in dropbox)\n\n\n  var allPluralForms = {\n    \"accents\": likeEnglish,\n    // a 'fake' langauge\n    \"af\": likeEnglish,\n    \"ar\": function (n) {\n      return n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 && n % 100 <= 99 ? 4 : 5;\n    },\n    \"az\": likeEnglish,\n    \"bg\": likeEnglish,\n    \"bn\": likeEnglish,\n    \"boxes\": likeEnglish,\n    // a 'fake' langauge\n    \"ca\": likeEnglish,\n    \"cs\": function (n) {\n      return n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2;\n    },\n    \"da\": likeEnglish,\n    \"de\": likeEnglish,\n    \"el\": likeEnglish,\n    \"empty\": likeEnglish,\n    // a 'fake' langauge\n    \"en\": likeEnglish,\n    \"en-pt\": likeEnglish,\n    // a 'fake' language, used by crowdin for JIPT\n    \"es\": likeEnglish,\n    \"fa\": function (n) {\n      return 0;\n    },\n    \"fa-af\": function (n) {\n      return 0;\n    },\n    \"fi\": likeEnglish,\n    \"fr\": function (n) {\n      return n > 1;\n    },\n    \"he\": likeEnglish,\n    \"hi\": likeEnglish,\n    \"hu\": likeEnglish,\n    \"hy\": likeEnglish,\n    \"id\": function (n) {\n      return 0;\n    },\n    \"it\": likeEnglish,\n    \"ja\": function (n) {\n      return 0;\n    },\n    \"ko\": function (n) {\n      return 0;\n    },\n    \"lol\": likeEnglish,\n    // a 'fake' langauge\n    \"mn\": likeEnglish,\n    \"ms\": function (n) {\n      return 0;\n    },\n    \"nb\": likeEnglish,\n    \"nl\": likeEnglish,\n    \"pl\": function (n) {\n      return n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;\n    },\n    \"pt\": likeEnglish,\n    \"pt-pt\": likeEnglish,\n    \"ro\": function (n) {\n      return n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2;\n    },\n    \"ru\": function (n) {\n      return n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;\n    },\n    \"si-LK\": likeEnglish,\n    \"sk\": function (n) {\n      return n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2;\n    },\n    \"sr\": function (n) {\n      return n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;\n    },\n    \"sv-SE\": likeEnglish,\n    \"sw\": likeEnglish,\n    \"te\": likeEnglish,\n    \"th\": function (n) {\n      return 0;\n    },\n    \"tr\": function (n) {\n      return 0;\n    },\n    \"uk\": function (n) {\n      return n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;\n    },\n    \"ur\": likeEnglish,\n    \"vi\": function (n) {\n      return 0;\n    },\n    \"xh\": likeEnglish,\n    \"zh-hans\": function (n) {\n      return 0;\n    },\n    \"zh-hant\": function (n) {\n      return 0;\n    },\n    \"zu\": likeEnglish\n  };\n  /* eslint-enable */\n\n  var interpolationMarker = /%\\(([\\w_]+)\\)s/g;\n  /**\n   * Performs sprintf-like %(name)s replacement on str, and returns a React\n   * fragment of the string interleaved with those replacements. The replacements\n   * can be any valid React node including strings and numbers.\n   *\n   * For example:\n   *  interpolateStringToFragment(\"test\", {}) ->\n   *      test\n   *  interpolateStringToFragment(\"test %(num)s\", {num: 5}) ->\n   *      test 5\n   *  interpolateStringToFragment(\"test %(num)s\", {num: <Count />}) ->\n   *      test <Count />\n   */\n\n  var interpolateStringToFragment = function (str, options) {\n    options = options || {}; // Split the string into its language fragments and substitutions\n\n    var split = str.split(interpolationMarker);\n    var result = {\n      \"text_0\": split[0]\n    }; // Replace the substitutions with the appropriate option\n\n    for (var i = 1; i < split.length; i += 2) {\n      var key = split[i];\n      var replaceWith = options[key];\n\n      if (replaceWith === undefined) {\n        replaceWith = \"%(\" + key + \")s\";\n      } // We prefix each substitution key with a number that increments each\n      // time it's used, so \"test %(num)s %(fruit)s and %(num)s again\" turns\n      // into an object with keys:\n      // [text_0, 0_num, text_2, 0_fruit, text_4, 1_num, text_6]\n      // This is better than just using the array index in the case that we\n      // switch between two translated strings with the same variables.\n      // Admittedly, an edge case.\n\n\n      var j = 0;\n\n      while (\"\" + j + \"_\" + key in result) {\n        j++;\n      }\n\n      result[\"\" + j + \"_\" + key] = replaceWith; // Because the regex has one capturing group, the `split` array always\n      // has an odd number of elements, so this always stays in bounds.\n\n      result[\"text_\" + (i + 1)] = split[i + 1];\n    }\n\n    return createFragment(result);\n  };\n  /**\n      * Simple i18n method with sprintf-like %(name)s replacement\n      * To be used like so:\n      *   i18n._(\"Some string\")\n      *   i18n._(\"Hello %(name)s\", {name: \"John\"})\n      */\n\n\n  var _ = function (str, options) {\n    // Sometimes we're given an argument that's meant for ngettext().  This\n    // happens if the same string is used in both i18n._() and i18n.ngettext()\n    // (.g. a = i18n._(foo); b = i18n.ngettext(\"foo\", \"bar\", count);\n    // In such cases, only the plural form ends up in the .po file, and\n    // then it gets sent to us for the i18n._() case too.  No problem, though:\n    // we'll just take the singular arg.\n    if (typeof str === \"object\" && str.messages) {\n      str = str.messages[0];\n    }\n\n    options = options || {};\n    return str.replace(interpolationMarker, function (match, key) {\n      var replaceWith = options[key];\n      return replaceWith === undefined ? match : replaceWith;\n    });\n  };\n  /**\n      * A simple i18n react component-like function to allow for string\n      * interpolation destined for the output of a react render() function\n      *\n      * This function understands react components, or other things\n      * renderable by react, passed in as props.\n      *\n      * Examples:\n      *   <$_ first=\"Motoko\" last=\"Kusanagi\">\n      *       Hello, %(first)s %(last)s!\n      *   </$_>\n      *\n      * which react/jsx compiles to:\n      *   $_({first: \"Motoko\", last: \"Kusanagi\"}, \"Hello, %(first)s %(last)s!\")\n      *\n      *\n      *   <$_ textbox={<input type=\"text\" />}>\n      *       Please enter a number: %(textbox)s\n      *   </$_>\n      *\n      * which react/jsx compiles to:\n      *   $_({textbox: React.DOM.input({type: \"text\"}),\n      *       \"Please enter a number: %(textbox)s\")\n      *\n      * Note: this is not a full react component to avoid complex handling of\n      * other things added to props, such as this.props.ref and\n      * this.props.children\n      */\n\n\n  var $_ = function (options, str) {\n    if (arguments.length !== 2 || typeof str !== \"string\") {\n      return \"<$_> must have exactly one child, which must be a string\";\n    }\n\n    return interpolateStringToFragment(str, options);\n  };\n  /**\n      * A simple i18n react component-like function to allow for marking a\n      * string as not needing to be translated.\n      *\n      * Example:\n      *\n      *    <$i18nDoNotTranslate>English only text.</$i18nDoNotTranslate>\n      *\n      * which react/jsx compiles to:\n      *    $i18nDoNotTranslate(null, \"English only text.\")\n      */\n\n\n  var $i18nDoNotTranslate = function (options, str) {\n    return str;\n  };\n  /**\n      * Simple ngettext method with sprintf-like %(name)s replacement\n      * To be used like so:\n      *   i18n.ngettext(\"Singular\", \"Plural\", 3)\n      *   i18n.ngettext(\"1 Cat\", \"%(num)s Cats\", 3)\n      *   i18n.ngettext(\"1 %(type)s\", \"%(num)s %(type)s\", 3, {type: \"Cat\"})\n      * This method is also meant to be used when injecting for other\n      * non-English languages, like so (taking an array of plural messages,\n      * which varies based upon the language):\n      *   i18n.ngettext({\n      *     lang: \"ja\",\n      *     messages: [\"%(num)s çŒ« %(username)s\"]\n      *   }, 3, {username: \"John\"});\n      */\n\n\n  var ngettext = function (singular, plural, num, options) {\n    // Fall back to the default lang\n    var lang;\n    var messages; // If the first argument is an object then we're receiving a plural\n    // configuration object\n\n    if (typeof singular === \"object\") {\n      lang = singular.lang;\n      messages = singular.messages; // We only have a messages object no plural string\n      // thus we need to shift all the arguments over by one.\n\n      options = num;\n      num = plural;\n    } else {\n      lang = \"en\"; // We're using text written into the source code\n\n      messages = [singular, plural];\n    } // Get the translated string\n\n\n    var idx = ngetpos(num, lang);\n    var translation = \"\";\n\n    if (idx < messages.length) {\n      // the common (non-error) case\n      translation = messages[idx];\n    } // Get the options to substitute into the string.\n    // We automatically add in the 'magic' option-variable 'num'.\n\n\n    options = options || {};\n    options.num = options.num || num; // Then pass into i18n._ for the actual substitution\n\n    return _(translation, options);\n  };\n  /*\n      * Return the ngettext position that matches the given number and locale.\n      *\n      * Arguments:\n      *  - num: The number upon which to toggle the plural forms.\n      *  - lang: The language to use as the basis for the pluralization.\n      */\n\n\n  var ngetpos = function (num, lang) {\n    var pluralForm = allPluralForms[lang] || allPluralForms[\"en\"];\n    var pos = pluralForm(num); // Map true to 1 and false to 0, keep any numeric return value the same.\n\n    return pos === true ? 1 : pos ? pos : 0;\n  };\n  /*\n      * A dummy identity function.  It's used as a signal to automatic\n      * translation-identification tools that they shouldn't mark this\n      * text up to be translated, even though it looks like\n      * natural-language text.  (And likewise, a signal to linters that\n      * they shouldn't complain that this text isn't translated.)\n      * Use it like so: 'tag.author = i18n.i18nDoNotTranslate(\"Jim\");'\n      */\n\n\n  var i18nDoNotTranslate = _;\n  /**\n      * Dummy Handlebars _ function. Is a noop.\n      * Should be used as: {{#_}}...{{/_}}\n      * The text is extracted, at compile-time, by server-side scripts.\n      * This is just used for marking up those fragments that need translation.\n      * The translated text is injected at deploy-time.\n      */\n\n  var handlebarsUnderscore = function (options) {\n    return options.fn(this);\n  };\n  /**\n      *  Mark text as not needing translation.\n      *\n      * This function is used to let i18nize_templates.py know that\n      * everything within it does not need to be translate.\n      * Should be used as: {{#i18nDoNotTranslate}}...{{/i18nDoNotTranslate}}\n      * It does not need to actually do anything and hence returns the contents\n      * as is.\n      */\n\n\n  var handlebarsDoNotTranslate = function (options) {\n    return options.fn(this);\n  };\n  /**\n      * Handlebars ngettext function.\n      * Doesn't do any translation, is used for showing the correct string\n      * based upon the specified number and language.\n      * All strings are extracted (at compile-time) and injected (at\n      * deploy-time). By default this should be used as:\n      *   {{#ngettext NUM}}singular{{else}}plural{{/ngettext}}\n      * After injecting the translated strings into the page it'll read as:\n      *   {{#ngettext NUM \"lang\" 0}}singular{{else}}plural{{/ngettext}}\n      * (May depend upon the language used and how many different plural\n      * forms the language has.)\n      *\n      * Arguments:\n      *  - num: The number upon which to toggle the plural forms.\n      *  - lang: The language to use as the basis for the pluralization.\n      *  - pos: The expected plural form (depends upon the language)\n      */\n\n\n  var handlebarsNgettext = function (num, lang, pos, options) {\n    // This method has two signatures:\n    // (num) (the default for when the code is run in dev mode)\n    // (num, lang, pos) (for when the code is run in prod mode)\n    if (typeof lang !== \"string\") {\n      options = lang;\n      lang = \"en\";\n      pos = 0;\n    } // Add in 'num' as a magic variable.\n\n\n    this.num = this.num || num; // If the result of the plural form function given the specified\n    // number matches the expected position then we give the first\n    // result, otherwise we give the inverse result.\n\n    return ngetpos(num) === pos ? options.fn(this) : options.inverse(this);\n  };\n  /**\n   * Rounds num to X places, and uses the proper decimal seperator.\n   * But does *not* insert thousands separators.\n   */\n\n\n  var localeToFixed = function (num, places) {\n    var decimalSeperator = icu.getDecimalFormatSymbols().decimal_separator;\n    var localeFixed = num.toFixed(places).replace(\".\", decimalSeperator);\n\n    if (localeFixed === \"-0\") {\n      localeFixed = \"0\";\n    }\n\n    return localeFixed;\n  }; // This is necessary for khan-exercises, perseus, and\n  // bootstrap-daterangepicker (live-editor also uses the global i18n\n  // var, but defines its own version of it.)  We export the symbols\n  // that they need.\n\n\n  window.i18n = {\n    _: _,\n    ngettext: ngettext,\n    i18nDoNotTranslate: i18nDoNotTranslate,\n    // khan-exercises is the only client of ngetpos (which is emitted\n    // into khan-exercises by kake/translate-exercises.py).\n    ngetpos: ngetpos\n  }; // TODO(csilvers): is it still necessary to make these globals?\n\n  window.$_ = $_;\n  window.$i18nDoNotTranslate = $i18nDoNotTranslate;\n})();","map":{"version":3,"sources":["/Users/justinf/perseus-configured/src/lib/i18n.js"],"names":["React","window","createFragment","__internalAddons","likeEnglish","n","allPluralForms","interpolationMarker","interpolateStringToFragment","str","options","split","result","i","length","key","replaceWith","undefined","j","_","messages","replace","match","$_","arguments","$i18nDoNotTranslate","ngettext","singular","plural","num","lang","idx","ngetpos","translation","pluralForm","pos","i18nDoNotTranslate","handlebarsUnderscore","fn","handlebarsDoNotTranslate","handlebarsNgettext","inverse","localeToFixed","places","decimalSeperator","icu","getDecimalFormatSymbols","decimal_separator","localeFixed","toFixed","i18n"],"mappings":"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","sourcesContent":["/* eslint-disable */\n\n(function() {\nReact = window.React;\n// Perseus running in local mode depends on $_, which is defined here\nif (typeof React !== 'undefined') {\n    var createFragment = React.__internalAddons.createFragment;\n}\n\n\n// The plural language strings for all the languages we have\n// listed in crowdin.  The values here need to match what crowdin\n// uses (sometimes different platforms use different plural forms,\n// for ambiguous languages like Turkish).  I got it by running\n//    deploy/download_i18n.py -s\n// and looking a the .po files in all.zip.  Each .po file has a\n// header line that say something like:\n//    \"Plural-Forms: nplurals=2; plural=(n != 1);\\n\"\n// which I copied in here with the following changes:\n//    1) I only take the 'plural=' section, which I wrapped in a function\n//    2) Changed 'or' to '||'\n// These functions return either true or false or a number.  We map\n// true to 1 and false to 0 below, to always get a number out of this.\n\n/* eslint-disable space-infix-ops, eqeqeq, max-len */\nvar likeEnglish = function (n) {return n != 1;};\n\n// TODO(csilvers): auto-generate this list from the foo.po files (in dropbox)\nvar allPluralForms = {\n    \"accents\": likeEnglish, // a 'fake' langauge\n    \"af\": likeEnglish,\n    \"ar\": function (n) {return n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 && n % 100 <= 99 ? 4 : 5;},\n    \"az\": likeEnglish,\n    \"bg\": likeEnglish,\n    \"bn\": likeEnglish,\n    \"boxes\": likeEnglish, // a 'fake' langauge\n    \"ca\": likeEnglish,\n    \"cs\": function (n) {return n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2;},\n    \"da\": likeEnglish,\n    \"de\": likeEnglish,\n    \"el\": likeEnglish,\n    \"empty\": likeEnglish, // a 'fake' langauge\n    \"en\": likeEnglish,\n    \"en-pt\": likeEnglish, // a 'fake' language, used by crowdin for JIPT\n    \"es\": likeEnglish,\n    \"fa\": function (n) {return 0;},\n    \"fa-af\": function (n) {return 0;},\n    \"fi\": likeEnglish,\n    \"fr\": function (n) {return n > 1;},\n    \"he\": likeEnglish,\n    \"hi\": likeEnglish,\n    \"hu\": likeEnglish,\n    \"hy\": likeEnglish,\n    \"id\": function (n) {return 0;},\n    \"it\": likeEnglish,\n    \"ja\": function (n) {return 0;},\n    \"ko\": function (n) {return 0;},\n    \"lol\": likeEnglish, // a 'fake' langauge\n    \"mn\": likeEnglish,\n    \"ms\": function (n) {return 0;},\n    \"nb\": likeEnglish,\n    \"nl\": likeEnglish,\n    \"pl\": function (n) {return n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;},\n    \"pt\": likeEnglish,\n    \"pt-pt\": likeEnglish,\n    \"ro\": function (n) {return n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2;},\n    \"ru\": function (n) {return n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;},\n    \"si-LK\": likeEnglish,\n    \"sk\": function (n) {return n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2;},\n    \"sr\": function (n) {return n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;},\n    \"sv-SE\": likeEnglish,\n    \"sw\": likeEnglish,\n    \"te\": likeEnglish,\n    \"th\": function (n) {return 0;},\n    \"tr\": function (n) {return 0;},\n    \"uk\": function (n) {return n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;},\n    \"ur\": likeEnglish,\n    \"vi\": function (n) {return 0;},\n    \"xh\": likeEnglish,\n    \"zh-hans\": function (n) {return 0;},\n    \"zh-hant\": function (n) {return 0;},\n    \"zu\": likeEnglish };\n\n/* eslint-enable */\n\nvar interpolationMarker = /%\\(([\\w_]+)\\)s/g;\n/**\n * Performs sprintf-like %(name)s replacement on str, and returns a React\n * fragment of the string interleaved with those replacements. The replacements\n * can be any valid React node including strings and numbers.\n *\n * For example:\n *  interpolateStringToFragment(\"test\", {}) ->\n *      test\n *  interpolateStringToFragment(\"test %(num)s\", {num: 5}) ->\n *      test 5\n *  interpolateStringToFragment(\"test %(num)s\", {num: <Count />}) ->\n *      test <Count />\n */\nvar interpolateStringToFragment = function (str, options) {\n    options = options || {};\n\n    // Split the string into its language fragments and substitutions\n    var split = str.split(interpolationMarker);\n\n    var result = { \"text_0\": split[0] };\n\n    // Replace the substitutions with the appropriate option\n    for (var i = 1; i < split.length; i += 2) {\n        var key = split[i];\n        var replaceWith = options[key];\n        if (replaceWith === undefined) {\n            replaceWith = \"%(\" + key + \")s\";}\n\n\n        // We prefix each substitution key with a number that increments each\n        // time it's used, so \"test %(num)s %(fruit)s and %(num)s again\" turns\n        // into an object with keys:\n        // [text_0, 0_num, text_2, 0_fruit, text_4, 1_num, text_6]\n        // This is better than just using the array index in the case that we\n        // switch between two translated strings with the same variables.\n        // Admittedly, an edge case.\n        var j = 0;\n        while (\"\" + j + \"_\" + key in result) {\n            j++;}\n\n        result[\"\" + j + \"_\" + key] = replaceWith;\n        // Because the regex has one capturing group, the `split` array always\n        // has an odd number of elements, so this always stays in bounds.\n        result[\"text_\" + (i + 1)] = split[i + 1];}\n\n\n    return createFragment(result);};\n\n\n/**\n    * Simple i18n method with sprintf-like %(name)s replacement\n    * To be used like so:\n    *   i18n._(\"Some string\")\n    *   i18n._(\"Hello %(name)s\", {name: \"John\"})\n    */\nvar _ = function (str, options) {\n    // Sometimes we're given an argument that's meant for ngettext().  This\n    // happens if the same string is used in both i18n._() and i18n.ngettext()\n    // (.g. a = i18n._(foo); b = i18n.ngettext(\"foo\", \"bar\", count);\n    // In such cases, only the plural form ends up in the .po file, and\n    // then it gets sent to us for the i18n._() case too.  No problem, though:\n    // we'll just take the singular arg.\n    if (typeof str === \"object\" && str.messages) {\n        str = str.messages[0];}\n\n\n    options = options || {};\n\n    return str.replace(interpolationMarker, function (match, key) {\n        var replaceWith = options[key];\n        return replaceWith === undefined ? match : replaceWith;});};\n\n\n\n/**\n    * A simple i18n react component-like function to allow for string\n    * interpolation destined for the output of a react render() function\n    *\n    * This function understands react components, or other things\n    * renderable by react, passed in as props.\n    *\n    * Examples:\n    *   <$_ first=\"Motoko\" last=\"Kusanagi\">\n    *       Hello, %(first)s %(last)s!\n    *   </$_>\n    *\n    * which react/jsx compiles to:\n    *   $_({first: \"Motoko\", last: \"Kusanagi\"}, \"Hello, %(first)s %(last)s!\")\n    *\n    *\n    *   <$_ textbox={<input type=\"text\" />}>\n    *       Please enter a number: %(textbox)s\n    *   </$_>\n    *\n    * which react/jsx compiles to:\n    *   $_({textbox: React.DOM.input({type: \"text\"}),\n    *       \"Please enter a number: %(textbox)s\")\n    *\n    * Note: this is not a full react component to avoid complex handling of\n    * other things added to props, such as this.props.ref and\n    * this.props.children\n    */\nvar $_ = function (options, str) {\n    if (arguments.length !== 2 || typeof str !== \"string\") {\n        return \"<$_> must have exactly one child, which must be a string\";}\n\n    return interpolateStringToFragment(str, options);};\n\n\n/**\n    * A simple i18n react component-like function to allow for marking a\n    * string as not needing to be translated.\n    *\n    * Example:\n    *\n    *    <$i18nDoNotTranslate>English only text.</$i18nDoNotTranslate>\n    *\n    * which react/jsx compiles to:\n    *    $i18nDoNotTranslate(null, \"English only text.\")\n    */\nvar $i18nDoNotTranslate = function (options, str) {\n    return str;};\n\n\n/**\n    * Simple ngettext method with sprintf-like %(name)s replacement\n    * To be used like so:\n    *   i18n.ngettext(\"Singular\", \"Plural\", 3)\n    *   i18n.ngettext(\"1 Cat\", \"%(num)s Cats\", 3)\n    *   i18n.ngettext(\"1 %(type)s\", \"%(num)s %(type)s\", 3, {type: \"Cat\"})\n    * This method is also meant to be used when injecting for other\n    * non-English languages, like so (taking an array of plural messages,\n    * which varies based upon the language):\n    *   i18n.ngettext({\n    *     lang: \"ja\",\n    *     messages: [\"%(num)s çŒ« %(username)s\"]\n    *   }, 3, {username: \"John\"});\n    */\nvar ngettext = function (singular, plural, num, options) {\n    // Fall back to the default lang\n    var lang;\n    var messages;\n\n    // If the first argument is an object then we're receiving a plural\n    // configuration object\n    if (typeof singular === \"object\") {\n        lang = singular.lang;\n        messages = singular.messages;\n        // We only have a messages object no plural string\n        // thus we need to shift all the arguments over by one.\n        options = num;\n        num = plural;} else\n    {\n        lang = \"en\"; // We're using text written into the source code\n        messages = [singular, plural];}\n\n\n    // Get the translated string\n    var idx = ngetpos(num, lang);\n    var translation = \"\";\n    if (idx < messages.length) {// the common (non-error) case\n        translation = messages[idx];}\n\n\n    // Get the options to substitute into the string.\n    // We automatically add in the 'magic' option-variable 'num'.\n    options = options || {};\n    options.num = options.num || num;\n\n    // Then pass into i18n._ for the actual substitution\n    return _(translation, options);};\n\n\n/*\n    * Return the ngettext position that matches the given number and locale.\n    *\n    * Arguments:\n    *  - num: The number upon which to toggle the plural forms.\n    *  - lang: The language to use as the basis for the pluralization.\n    */\nvar ngetpos = function (num, lang) {\n    var pluralForm = allPluralForms[lang] || allPluralForms[\"en\"];\n    var pos = pluralForm(num);\n    // Map true to 1 and false to 0, keep any numeric return value the same.\n    return pos === true ? 1 : pos ? pos : 0;};\n\n\n/*\n    * A dummy identity function.  It's used as a signal to automatic\n    * translation-identification tools that they shouldn't mark this\n    * text up to be translated, even though it looks like\n    * natural-language text.  (And likewise, a signal to linters that\n    * they shouldn't complain that this text isn't translated.)\n    * Use it like so: 'tag.author = i18n.i18nDoNotTranslate(\"Jim\");'\n    */\nvar i18nDoNotTranslate = _;\n\n/**\n    * Dummy Handlebars _ function. Is a noop.\n    * Should be used as: {{#_}}...{{/_}}\n    * The text is extracted, at compile-time, by server-side scripts.\n    * This is just used for marking up those fragments that need translation.\n    * The translated text is injected at deploy-time.\n    */\nvar handlebarsUnderscore = function (options) {\n    return options.fn(this);};\n\n\n/**\n    *  Mark text as not needing translation.\n    *\n    * This function is used to let i18nize_templates.py know that\n    * everything within it does not need to be translate.\n    * Should be used as: {{#i18nDoNotTranslate}}...{{/i18nDoNotTranslate}}\n    * It does not need to actually do anything and hence returns the contents\n    * as is.\n    */\nvar handlebarsDoNotTranslate = function (options) {\n    return options.fn(this);};\n\n\n/**\n    * Handlebars ngettext function.\n    * Doesn't do any translation, is used for showing the correct string\n    * based upon the specified number and language.\n    * All strings are extracted (at compile-time) and injected (at\n    * deploy-time). By default this should be used as:\n    *   {{#ngettext NUM}}singular{{else}}plural{{/ngettext}}\n    * After injecting the translated strings into the page it'll read as:\n    *   {{#ngettext NUM \"lang\" 0}}singular{{else}}plural{{/ngettext}}\n    * (May depend upon the language used and how many different plural\n    * forms the language has.)\n    *\n    * Arguments:\n    *  - num: The number upon which to toggle the plural forms.\n    *  - lang: The language to use as the basis for the pluralization.\n    *  - pos: The expected plural form (depends upon the language)\n    */\nvar handlebarsNgettext = function (num, lang, pos, options) {\n    // This method has two signatures:\n    // (num) (the default for when the code is run in dev mode)\n    // (num, lang, pos) (for when the code is run in prod mode)\n    if (typeof lang !== \"string\") {\n        options = lang;\n        lang = \"en\";\n        pos = 0;}\n\n\n    // Add in 'num' as a magic variable.\n    this.num = this.num || num;\n\n    // If the result of the plural form function given the specified\n    // number matches the expected position then we give the first\n    // result, otherwise we give the inverse result.\n    return ngetpos(num) === pos ?\n    options.fn(this) :\n    options.inverse(this);};\n\n\n/**\n * Rounds num to X places, and uses the proper decimal seperator.\n * But does *not* insert thousands separators.\n */\nvar localeToFixed = function (num, places) {\n    var decimalSeperator = icu.getDecimalFormatSymbols().decimal_separator;\n    var localeFixed = num.toFixed(places).replace(\".\", decimalSeperator);\n    if (localeFixed === \"-0\") {\n        localeFixed = \"0\";}\n\n    return localeFixed;};\n\n\n// This is necessary for khan-exercises, perseus, and\n// bootstrap-daterangepicker (live-editor also uses the global i18n\n// var, but defines its own version of it.)  We export the symbols\n// that they need.\nwindow.i18n = {\n    _: _,\n    ngettext: ngettext,\n    i18nDoNotTranslate: i18nDoNotTranslate,\n    // khan-exercises is the only client of ngetpos (which is emitted\n    // into khan-exercises by kake/translate-exercises.py).\n    ngetpos: ngetpos };\n\n\n// TODO(csilvers): is it still necessary to make these globals?\nwindow.$_ = $_;\nwindow.$i18nDoNotTranslate = $i18nDoNotTranslate;\n\n})();\n"]},"metadata":{},"sourceType":"module"}