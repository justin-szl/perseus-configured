{"ast":null,"code":"/**\n * These objects store the data about the DOM nodes we create, as well as some\n * extra data. They can then be transformed into real DOM nodes with the\n * `toNode` function or HTML markup using `toMarkup`. They are useful for both\n * storing extra properties on the nodes, as well as providing a way to easily\n * work with the DOM.\n *\n * Similar functions for working with MathML nodes exist in mathMLTree.js.\n */\nvar unicodeRegexes = require(\"./unicodeRegexes\");\n\nvar utils = require(\"./utils\");\n/**\n * Create an HTML className based on a list of classes. In addition to joining\n * with spaces, we also remove null or empty classes.\n */\n\n\nvar createClass = function (classes) {\n  classes = classes.slice();\n\n  for (var i = classes.length - 1; i >= 0; i--) {\n    if (!classes[i]) {\n      classes.splice(i, 1);\n    }\n  }\n\n  return classes.join(\" \");\n};\n/**\n * This node represents a span node, with a className, a list of children, and\n * an inline style. It also contains information about its height, depth, and\n * maxFontSize.\n */\n\n\nfunction span(classes, children, options) {\n  this.classes = classes || [];\n  this.children = children || [];\n  this.height = 0;\n  this.depth = 0;\n  this.maxFontSize = 0;\n  this.style = {};\n  this.attributes = {};\n\n  if (options) {\n    if (options.style.isTight()) {\n      this.classes.push(\"mtight\");\n    }\n\n    if (options.getColor()) {\n      this.style.color = options.getColor();\n    }\n  }\n}\n/**\n * Sets an arbitrary attribute on the span. Warning: use this wisely. Not all\n * browsers support attributes the same, and having too many custom attributes\n * is probably bad.\n */\n\n\nspan.prototype.setAttribute = function (attribute, value) {\n  this.attributes[attribute] = value;\n};\n\nspan.prototype.tryCombine = function (sibling) {\n  return false;\n};\n/**\n * Convert the span into an HTML node\n */\n\n\nspan.prototype.toNode = function () {\n  var span = document.createElement(\"span\"); // Apply the class\n\n  span.className = createClass(this.classes); // Apply inline styles\n\n  for (var style in this.style) {\n    if (Object.prototype.hasOwnProperty.call(this.style, style)) {\n      span.style[style] = this.style[style];\n    }\n  } // Apply attributes\n\n\n  for (var attr in this.attributes) {\n    if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n      span.setAttribute(attr, this.attributes[attr]);\n    }\n  } // Append the children, also as HTML nodes\n\n\n  for (var i = 0; i < this.children.length; i++) {\n    span.appendChild(this.children[i].toNode());\n  }\n\n  return span;\n};\n/**\n * Convert the span into an HTML markup string\n */\n\n\nspan.prototype.toMarkup = function () {\n  var markup = \"<span\"; // Add the class\n\n  if (this.classes.length) {\n    markup += \" class=\\\"\";\n    markup += utils.escape(createClass(this.classes));\n    markup += \"\\\"\";\n  }\n\n  var styles = \"\"; // Add the styles, after hyphenation\n\n  for (var style in this.style) {\n    if (this.style.hasOwnProperty(style)) {\n      styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n    }\n  }\n\n  if (styles) {\n    markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n  } // Add the attributes\n\n\n  for (var attr in this.attributes) {\n    if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n      markup += \" \" + attr + \"=\\\"\";\n      markup += utils.escape(this.attributes[attr]);\n      markup += \"\\\"\";\n    }\n  }\n\n  markup += \">\"; // Add the markup of the children, also as markup\n\n  for (var i = 0; i < this.children.length; i++) {\n    markup += this.children[i].toMarkup();\n  }\n\n  markup += \"</span>\";\n  return markup;\n};\n/**\n * This node represents a document fragment, which contains elements, but when\n * placed into the DOM doesn't have any representation itself. Thus, it only\n * contains children and doesn't have any HTML properties. It also keeps track\n * of a height, depth, and maxFontSize.\n */\n\n\nfunction documentFragment(children) {\n  this.children = children || [];\n  this.height = 0;\n  this.depth = 0;\n  this.maxFontSize = 0;\n}\n/**\n * Convert the fragment into a node\n */\n\n\ndocumentFragment.prototype.toNode = function () {\n  // Create a fragment\n  var frag = document.createDocumentFragment(); // Append the children\n\n  for (var i = 0; i < this.children.length; i++) {\n    frag.appendChild(this.children[i].toNode());\n  }\n\n  return frag;\n};\n/**\n * Convert the fragment into HTML markup\n */\n\n\ndocumentFragment.prototype.toMarkup = function () {\n  var markup = \"\"; // Simply concatenate the markup for the children together\n\n  for (var i = 0; i < this.children.length; i++) {\n    markup += this.children[i].toMarkup();\n  }\n\n  return markup;\n};\n\nvar iCombinations = {\n  'î': '\\u0131\\u0302',\n  'ï': '\\u0131\\u0308',\n  'í': '\\u0131\\u0301',\n  // 'ī': '\\u0131\\u0304', // enable when we add Extended Latin\n  'ì': '\\u0131\\u0300'\n};\n/**\n * A symbol node contains information about a single symbol. It either renders\n * to a single text node, or a span with a single text node in it, depending on\n * whether it has CSS classes, styles, or needs italic correction.\n */\n\nfunction symbolNode(value, height, depth, italic, skew, classes, style) {\n  this.value = value || \"\";\n  this.height = height || 0;\n  this.depth = depth || 0;\n  this.italic = italic || 0;\n  this.skew = skew || 0;\n  this.classes = classes || [];\n  this.style = style || {};\n  this.maxFontSize = 0; // Mark CJK characters with specific classes so that we can specify which\n  // fonts to use.  This allows us to render these characters with a serif\n  // font in situations where the browser would either default to a sans serif\n  // or render a placeholder character.\n\n  if (unicodeRegexes.cjkRegex.test(value)) {\n    // I couldn't find any fonts that contained Hangul as well as all of\n    // the other characters we wanted to test there for it gets its own\n    // CSS class.\n    if (unicodeRegexes.hangulRegex.test(value)) {\n      this.classes.push('hangul_fallback');\n    } else {\n      this.classes.push('cjk_fallback');\n    }\n  }\n\n  if (/[îïíì]/.test(this.value)) {\n    // add ī when we add Extended Latin\n    this.value = iCombinations[this.value];\n  }\n}\n\nsymbolNode.prototype.tryCombine = function (sibling) {\n  if (!sibling || !(sibling instanceof symbolNode) || this.italic > 0 || createClass(this.classes) !== createClass(sibling.classes) || this.skew !== sibling.skew || this.maxFontSize !== sibling.maxFontSize) {\n    return false;\n  }\n\n  for (var style in this.style) {\n    if (this.style.hasOwnProperty(style) && this.style[style] !== sibling.style[style]) {\n      return false;\n    }\n  }\n\n  for (style in sibling.style) {\n    if (sibling.style.hasOwnProperty(style) && this.style[style] !== sibling.style[style]) {\n      return false;\n    }\n  }\n\n  this.value += sibling.value;\n  this.height = Math.max(this.height, sibling.height);\n  this.depth = Math.max(this.depth, sibling.depth);\n  this.italic = sibling.italic;\n  return true;\n};\n/**\n * Creates a text node or span from a symbol node. Note that a span is only\n * created if it is needed.\n */\n\n\nsymbolNode.prototype.toNode = function () {\n  var node = document.createTextNode(this.value);\n  var span = null;\n\n  if (this.italic > 0) {\n    span = document.createElement(\"span\");\n    span.style.marginRight = this.italic + \"em\";\n  }\n\n  if (this.classes.length > 0) {\n    span = span || document.createElement(\"span\");\n    span.className = createClass(this.classes);\n  }\n\n  for (var style in this.style) {\n    if (this.style.hasOwnProperty(style)) {\n      span = span || document.createElement(\"span\");\n      span.style[style] = this.style[style];\n    }\n  }\n\n  if (span) {\n    span.appendChild(node);\n    return span;\n  } else {\n    return node;\n  }\n};\n/**\n * Creates markup for a symbol node.\n */\n\n\nsymbolNode.prototype.toMarkup = function () {\n  // TODO(alpert): More duplication than I'd like from\n  // span.prototype.toMarkup and symbolNode.prototype.toNode...\n  var needsSpan = false;\n  var markup = \"<span\";\n\n  if (this.classes.length) {\n    needsSpan = true;\n    markup += \" class=\\\"\";\n    markup += utils.escape(createClass(this.classes));\n    markup += \"\\\"\";\n  }\n\n  var styles = \"\";\n\n  if (this.italic > 0) {\n    styles += \"margin-right:\" + this.italic + \"em;\";\n  }\n\n  for (var style in this.style) {\n    if (this.style.hasOwnProperty(style)) {\n      styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n    }\n  }\n\n  if (styles) {\n    needsSpan = true;\n    markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n  }\n\n  var escaped = utils.escape(this.value);\n\n  if (needsSpan) {\n    markup += \">\";\n    markup += escaped;\n    markup += \"</span>\";\n    return markup;\n  } else {\n    return escaped;\n  }\n};\n\nmodule.exports = {\n  span: span,\n  documentFragment: documentFragment,\n  symbolNode: symbolNode\n};","map":{"version":3,"sources":["/Users/justinf/perseus-configured/node_modules/katex/src/domTree.js"],"names":["unicodeRegexes","require","utils","createClass","classes","slice","i","length","splice","join","span","children","options","height","depth","maxFontSize","style","attributes","isTight","push","getColor","color","prototype","setAttribute","attribute","value","tryCombine","sibling","toNode","document","createElement","className","Object","hasOwnProperty","call","attr","appendChild","toMarkup","markup","escape","styles","hyphenate","documentFragment","frag","createDocumentFragment","iCombinations","symbolNode","italic","skew","cjkRegex","test","hangulRegex","Math","max","node","createTextNode","marginRight","needsSpan","escaped","module","exports"],"mappings":"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","sourcesContent":["/**\n * These objects store the data about the DOM nodes we create, as well as some\n * extra data. They can then be transformed into real DOM nodes with the\n * `toNode` function or HTML markup using `toMarkup`. They are useful for both\n * storing extra properties on the nodes, as well as providing a way to easily\n * work with the DOM.\n *\n * Similar functions for working with MathML nodes exist in mathMLTree.js.\n */\nvar unicodeRegexes = require(\"./unicodeRegexes\");\nvar utils = require(\"./utils\");\n\n/**\n * Create an HTML className based on a list of classes. In addition to joining\n * with spaces, we also remove null or empty classes.\n */\nvar createClass = function(classes) {\n    classes = classes.slice();\n    for (var i = classes.length - 1; i >= 0; i--) {\n        if (!classes[i]) {\n            classes.splice(i, 1);\n        }\n    }\n\n    return classes.join(\" \");\n};\n\n/**\n * This node represents a span node, with a className, a list of children, and\n * an inline style. It also contains information about its height, depth, and\n * maxFontSize.\n */\nfunction span(classes, children, options) {\n    this.classes = classes || [];\n    this.children = children || [];\n    this.height = 0;\n    this.depth = 0;\n    this.maxFontSize = 0;\n    this.style = {};\n    this.attributes = {};\n    if (options) {\n        if (options.style.isTight()) {\n            this.classes.push(\"mtight\");\n        }\n        if (options.getColor()) {\n            this.style.color = options.getColor();\n        }\n    }\n}\n\n/**\n * Sets an arbitrary attribute on the span. Warning: use this wisely. Not all\n * browsers support attributes the same, and having too many custom attributes\n * is probably bad.\n */\nspan.prototype.setAttribute = function(attribute, value) {\n    this.attributes[attribute] = value;\n};\n\nspan.prototype.tryCombine = function(sibling) {\n    return false;\n};\n\n/**\n * Convert the span into an HTML node\n */\nspan.prototype.toNode = function() {\n    var span = document.createElement(\"span\");\n\n    // Apply the class\n    span.className = createClass(this.classes);\n\n    // Apply inline styles\n    for (var style in this.style) {\n        if (Object.prototype.hasOwnProperty.call(this.style, style)) {\n            span.style[style] = this.style[style];\n        }\n    }\n\n    // Apply attributes\n    for (var attr in this.attributes) {\n        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n            span.setAttribute(attr, this.attributes[attr]);\n        }\n    }\n\n    // Append the children, also as HTML nodes\n    for (var i = 0; i < this.children.length; i++) {\n        span.appendChild(this.children[i].toNode());\n    }\n\n    return span;\n};\n\n/**\n * Convert the span into an HTML markup string\n */\nspan.prototype.toMarkup = function() {\n    var markup = \"<span\";\n\n    // Add the class\n    if (this.classes.length) {\n        markup += \" class=\\\"\";\n        markup += utils.escape(createClass(this.classes));\n        markup += \"\\\"\";\n    }\n\n    var styles = \"\";\n\n    // Add the styles, after hyphenation\n    for (var style in this.style) {\n        if (this.style.hasOwnProperty(style)) {\n            styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n        }\n    }\n\n    if (styles) {\n        markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n    }\n\n    // Add the attributes\n    for (var attr in this.attributes) {\n        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n            markup += \" \" + attr + \"=\\\"\";\n            markup += utils.escape(this.attributes[attr]);\n            markup += \"\\\"\";\n        }\n    }\n\n    markup += \">\";\n\n    // Add the markup of the children, also as markup\n    for (var i = 0; i < this.children.length; i++) {\n        markup += this.children[i].toMarkup();\n    }\n\n    markup += \"</span>\";\n\n    return markup;\n};\n\n/**\n * This node represents a document fragment, which contains elements, but when\n * placed into the DOM doesn't have any representation itself. Thus, it only\n * contains children and doesn't have any HTML properties. It also keeps track\n * of a height, depth, and maxFontSize.\n */\nfunction documentFragment(children) {\n    this.children = children || [];\n    this.height = 0;\n    this.depth = 0;\n    this.maxFontSize = 0;\n}\n\n/**\n * Convert the fragment into a node\n */\ndocumentFragment.prototype.toNode = function() {\n    // Create a fragment\n    var frag = document.createDocumentFragment();\n\n    // Append the children\n    for (var i = 0; i < this.children.length; i++) {\n        frag.appendChild(this.children[i].toNode());\n    }\n\n    return frag;\n};\n\n/**\n * Convert the fragment into HTML markup\n */\ndocumentFragment.prototype.toMarkup = function() {\n    var markup = \"\";\n\n    // Simply concatenate the markup for the children together\n    for (var i = 0; i < this.children.length; i++) {\n        markup += this.children[i].toMarkup();\n    }\n\n    return markup;\n};\n\nvar iCombinations = {\n    'î': '\\u0131\\u0302',\n    'ï': '\\u0131\\u0308',\n    'í': '\\u0131\\u0301',\n    // 'ī': '\\u0131\\u0304', // enable when we add Extended Latin\n    'ì': '\\u0131\\u0300'\n};\n\n/**\n * A symbol node contains information about a single symbol. It either renders\n * to a single text node, or a span with a single text node in it, depending on\n * whether it has CSS classes, styles, or needs italic correction.\n */\nfunction symbolNode(value, height, depth, italic, skew, classes, style) {\n    this.value = value || \"\";\n    this.height = height || 0;\n    this.depth = depth || 0;\n    this.italic = italic || 0;\n    this.skew = skew || 0;\n    this.classes = classes || [];\n    this.style = style || {};\n    this.maxFontSize = 0;\n\n    // Mark CJK characters with specific classes so that we can specify which\n    // fonts to use.  This allows us to render these characters with a serif\n    // font in situations where the browser would either default to a sans serif\n    // or render a placeholder character.\n    if (unicodeRegexes.cjkRegex.test(value)) {\n        // I couldn't find any fonts that contained Hangul as well as all of\n        // the other characters we wanted to test there for it gets its own\n        // CSS class.\n        if (unicodeRegexes.hangulRegex.test(value)) {\n            this.classes.push('hangul_fallback');\n        } else {\n            this.classes.push('cjk_fallback');\n        }\n    }\n\n    if (/[îïíì]/.test(this.value)) {    // add ī when we add Extended Latin\n        this.value = iCombinations[this.value];\n    }\n}\n\nsymbolNode.prototype.tryCombine = function(sibling) {\n    if (!sibling\n        || !(sibling instanceof symbolNode)\n        || this.italic > 0\n        || createClass(this.classes) !== createClass(sibling.classes)\n        || this.skew !== sibling.skew\n        || this.maxFontSize !== sibling.maxFontSize) {\n        return false;\n    }\n    for (var style in this.style) {\n        if (this.style.hasOwnProperty(style)\n            && this.style[style] !== sibling.style[style]) {\n            return false;\n        }\n    }\n    for (style in sibling.style) {\n        if (sibling.style.hasOwnProperty(style)\n            && this.style[style] !== sibling.style[style]) {\n            return false;\n        }\n    }\n    this.value += sibling.value;\n    this.height = Math.max(this.height, sibling.height);\n    this.depth = Math.max(this.depth, sibling.depth);\n    this.italic = sibling.italic;\n    return true;\n};\n\n/**\n * Creates a text node or span from a symbol node. Note that a span is only\n * created if it is needed.\n */\nsymbolNode.prototype.toNode = function() {\n    var node = document.createTextNode(this.value);\n    var span = null;\n\n    if (this.italic > 0) {\n        span = document.createElement(\"span\");\n        span.style.marginRight = this.italic + \"em\";\n    }\n\n    if (this.classes.length > 0) {\n        span = span || document.createElement(\"span\");\n        span.className = createClass(this.classes);\n    }\n\n    for (var style in this.style) {\n        if (this.style.hasOwnProperty(style)) {\n            span = span || document.createElement(\"span\");\n            span.style[style] = this.style[style];\n        }\n    }\n\n    if (span) {\n        span.appendChild(node);\n        return span;\n    } else {\n        return node;\n    }\n};\n\n/**\n * Creates markup for a symbol node.\n */\nsymbolNode.prototype.toMarkup = function() {\n    // TODO(alpert): More duplication than I'd like from\n    // span.prototype.toMarkup and symbolNode.prototype.toNode...\n    var needsSpan = false;\n\n    var markup = \"<span\";\n\n    if (this.classes.length) {\n        needsSpan = true;\n        markup += \" class=\\\"\";\n        markup += utils.escape(createClass(this.classes));\n        markup += \"\\\"\";\n    }\n\n    var styles = \"\";\n\n    if (this.italic > 0) {\n        styles += \"margin-right:\" + this.italic + \"em;\";\n    }\n    for (var style in this.style) {\n        if (this.style.hasOwnProperty(style)) {\n            styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n        }\n    }\n\n    if (styles) {\n        needsSpan = true;\n        markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n    }\n\n    var escaped = utils.escape(this.value);\n    if (needsSpan) {\n        markup += \">\";\n        markup += escaped;\n        markup += \"</span>\";\n        return markup;\n    } else {\n        return escaped;\n    }\n};\n\nmodule.exports = {\n    span: span,\n    documentFragment: documentFragment,\n    symbolNode: symbolNode\n};\n"]},"metadata":{},"sourceType":"script"}