{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _asap = require('asap');\n\nvar _asap2 = _interopRequireDefault(_asap);\n\nvar _orderedElements = require('./ordered-elements');\n\nvar _orderedElements2 = _interopRequireDefault(_orderedElements);\n\nvar _generate = require('./generate');\n\nvar _util = require('./util');\n/* ::\nimport type { SheetDefinition, SheetDefinitions } from './index.js';\nimport type { MaybeSheetDefinition } from './exports.js';\nimport type { SelectorHandler } from './generate.js';\ntype ProcessedStyleDefinitions = {\n  classNameBits: Array<string>,\n  definitionBits: Array<Object>,\n};\n*/\n// The current <style> tag we are inserting into, or null if we haven't\n// inserted anything yet. We could find this each time using\n// `document.querySelector(\"style[data-aphrodite\"])`, but holding onto it is\n// faster.\n\n\nvar styleTag = null; // Inject a string of styles into a <style> tag in the head of the document. This\n// will automatically create a style tag and then continue to use it for\n// multiple injections. It will also use a style tag with the `data-aphrodite`\n// tag on it if that exists in the DOM. This could be used for e.g. reusing the\n// same style tag that server-side rendering inserts.\n\nvar injectStyleTag = function injectStyleTag(cssContents\n/* : string */\n) {\n  if (styleTag == null) {\n    // Try to find a style tag with the `data-aphrodite` attribute first.\n    styleTag = document.querySelector(\"style[data-aphrodite]\"); // If that doesn't work, generate a new style tag.\n\n    if (styleTag == null) {\n      // Taken from\n      // http://stackoverflow.com/questions/524696/how-to-create-a-style-tag-with-javascript\n      var head = document.head || document.getElementsByTagName('head')[0];\n      styleTag = document.createElement('style');\n      styleTag.type = 'text/css';\n      styleTag.setAttribute(\"data-aphrodite\", \"\");\n      head.appendChild(styleTag);\n    }\n  }\n\n  if (styleTag.styleSheet) {\n    // $FlowFixMe: legacy Internet Explorer compatibility\n    styleTag.styleSheet.cssText += cssContents;\n  } else {\n    styleTag.appendChild(document.createTextNode(cssContents));\n  }\n}; // Custom handlers for stringifying CSS values that have side effects\n// (such as fontFamily, which can cause @font-face rules to be injected)\n\n\nvar stringHandlers = {\n  // With fontFamily we look for objects that are passed in and interpret\n  // them as @font-face rules that we need to inject. The value of fontFamily\n  // can either be a string (as normal), an object (a single font face), or\n  // an array of objects and strings.\n  fontFamily: function fontFamily(val) {\n    if (Array.isArray(val)) {\n      return val.map(fontFamily).join(\",\");\n    } else if (typeof val === \"object\") {\n      injectStyleOnce(val.src, \"@font-face\", [val], false);\n      return '\"' + val.fontFamily + '\"';\n    } else {\n      return val;\n    }\n  },\n  // With animationName we look for an object that contains keyframes and\n  // inject them as an `@keyframes` block, returning a uniquely generated\n  // name. The keyframes object should look like\n  //  animationName: {\n  //    from: {\n  //      left: 0,\n  //      top: 0,\n  //    },\n  //    '50%': {\n  //      left: 15,\n  //      top: 5,\n  //    },\n  //    to: {\n  //      left: 20,\n  //      top: 20,\n  //    }\n  //  }\n  // TODO(emily): `stringHandlers` doesn't let us rename the key, so I have\n  // to use `animationName` here. Improve that so we can call this\n  // `animation` instead of `animationName`.\n  animationName: function animationName(val, selectorHandlers) {\n    if (Array.isArray(val)) {\n      return val.map(function (v) {\n        return animationName(v, selectorHandlers);\n      }).join(\",\");\n    } else if (typeof val === \"object\") {\n      // Generate a unique name based on the hash of the object. We can't\n      // just use the hash because the name can't start with a number.\n      // TODO(emily): this probably makes debugging hard, allow a custom\n      // name?\n      var _name = 'keyframe_' + (0, _util.hashObject)(val); // Since keyframes need 3 layers of nesting, we use `generateCSS` to\n      // build the inner layers and wrap it in `@keyframes` ourselves.\n\n\n      var finalVal = '@keyframes ' + _name + '{'; // TODO see if we can find a way where checking for OrderedElements\n      // here is not necessary. Alternatively, perhaps we should have a\n      // utility method that can iterate over either a plain object, an\n      // instance of OrderedElements, or a Map, and then use that here and\n      // elsewhere.\n\n      if (val instanceof _orderedElements2['default']) {\n        val.forEach(function (valVal, valKey) {\n          finalVal += (0, _generate.generateCSS)(valKey, [valVal], selectorHandlers, stringHandlers, false);\n        });\n      } else {\n        Object.keys(val).forEach(function (key) {\n          finalVal += (0, _generate.generateCSS)(key, [val[key]], selectorHandlers, stringHandlers, false);\n        });\n      }\n\n      finalVal += '}';\n      injectGeneratedCSSOnce(_name, finalVal);\n      return _name;\n    } else {\n      return val;\n    }\n  }\n}; // This is a map from Aphrodite's generated class names to `true` (acting as a\n// set of class names)\n\nvar alreadyInjected = {}; // This is the buffer of styles which have not yet been flushed.\n\nvar injectionBuffer = \"\"; // A flag to tell if we are already buffering styles. This could happen either\n// because we scheduled a flush call already, so newly added styles will\n// already be flushed, or because we are statically buffering on the server.\n\nvar isBuffering = false;\n\nvar injectGeneratedCSSOnce = function injectGeneratedCSSOnce(key, generatedCSS) {\n  if (alreadyInjected[key]) {\n    return;\n  }\n\n  if (!isBuffering) {\n    // We should never be automatically buffering on the server (or any\n    // place without a document), so guard against that.\n    if (typeof document === \"undefined\") {\n      throw new Error(\"Cannot automatically buffer without a document\");\n    } // If we're not already buffering, schedule a call to flush the\n    // current styles.\n\n\n    isBuffering = true;\n    (0, _asap2['default'])(flushToStyleTag);\n  }\n\n  injectionBuffer += generatedCSS;\n  alreadyInjected[key] = true;\n};\n\nvar injectStyleOnce = function injectStyleOnce(key,\n/* : string */\nselector,\n/* : string */\ndefinitions,\n/* : SheetDefinition[] */\nuseImportant\n/* : boolean */\n) {\n  var selectorHandlers\n  /* : SelectorHandler[] */\n  = arguments.length <= 4 || arguments[4] === undefined ? [] : arguments[4];\n\n  if (alreadyInjected[key]) {\n    return;\n  }\n\n  var generated = (0, _generate.generateCSS)(selector, definitions, selectorHandlers, stringHandlers, useImportant);\n  injectGeneratedCSSOnce(key, generated);\n};\n\nexports.injectStyleOnce = injectStyleOnce;\n\nvar reset = function reset() {\n  injectionBuffer = \"\";\n  alreadyInjected = {};\n  isBuffering = false;\n  styleTag = null;\n};\n\nexports.reset = reset;\n\nvar startBuffering = function startBuffering() {\n  if (isBuffering) {\n    throw new Error(\"Cannot buffer while already buffering\");\n  }\n\n  isBuffering = true;\n};\n\nexports.startBuffering = startBuffering;\n\nvar flushToString = function flushToString() {\n  isBuffering = false;\n  var ret = injectionBuffer;\n  injectionBuffer = \"\";\n  return ret;\n};\n\nexports.flushToString = flushToString;\n\nvar flushToStyleTag = function flushToStyleTag() {\n  var cssContent = flushToString();\n\n  if (cssContent.length > 0) {\n    injectStyleTag(cssContent);\n  }\n};\n\nexports.flushToStyleTag = flushToStyleTag;\n\nvar getRenderedClassNames = function getRenderedClassNames() {\n  return Object.keys(alreadyInjected);\n};\n\nexports.getRenderedClassNames = getRenderedClassNames;\n\nvar addRenderedClassNames = function addRenderedClassNames(classNames\n/* : string[] */\n) {\n  classNames.forEach(function (className) {\n    alreadyInjected[className] = true;\n  });\n};\n\nexports.addRenderedClassNames = addRenderedClassNames;\n\nvar processStyleDefinitions = function processStyleDefinitions(styleDefinitions,\n/* : any[] */\nresult\n/* : ProcessedStyleDefinitions */\n)\n/* : void */\n{\n  for (var i = 0; i < styleDefinitions.length; i += 1) {\n    // Filter out falsy values from the input, to allow for\n    // `css(a, test && c)`\n    if (styleDefinitions[i]) {\n      if (Array.isArray(styleDefinitions[i])) {\n        // We've encountered an array, so let's recurse\n        processStyleDefinitions(styleDefinitions[i], result);\n      } else {\n        result.classNameBits.push(styleDefinitions[i]._name);\n        result.definitionBits.push(styleDefinitions[i]._definition);\n      }\n    }\n  }\n}; // Sum up the lengths of the stringified style definitions (which was saved as _len property)\n// and use modulus to return a single byte hash value.\n// We append this extra byte to the 32bit hash to decrease the chance of hash collisions.\n\n\nvar getStyleDefinitionsLengthHash = function getStyleDefinitionsLengthHash(styleDefinitions\n/* : any[] */\n) {\n  return (\n    /* : string */\n    (styleDefinitions.reduce(function (length, styleDefinition) {\n      return length + (styleDefinition ? styleDefinition._len : 0);\n    }, 0) % 36).toString(36)\n  );\n};\n/**\n * Inject styles associated with the passed style definition objects, and return\n * an associated CSS class name.\n *\n * @param {boolean} useImportant If true, will append !important to generated\n *     CSS output. e.g. {color: red} -> \"color: red !important\".\n * @param {(Object|Object[])[]} styleDefinitions style definition objects, or\n *     arbitrarily nested arrays of them, as returned as properties of the\n *     return value of StyleSheet.create().\n */\n\n\nvar injectAndGetClassName = function injectAndGetClassName(useImportant,\n/* : boolean */\nstyleDefinitions,\n/* : MaybeSheetDefinition[] */\nselectorHandlers\n/* : SelectorHandler[] */\n)\n/* : string */\n{\n  var processedStyleDefinitions\n  /* : ProcessedStyleDefinitions */\n  = {\n    classNameBits: [],\n    definitionBits: []\n  }; // Mutates processedStyleDefinitions\n\n  processStyleDefinitions(styleDefinitions, processedStyleDefinitions); // Break if there aren't any valid styles.\n\n  if (processedStyleDefinitions.classNameBits.length === 0) {\n    return \"\";\n  }\n\n  var className = undefined;\n\n  if (process.env.NODE_ENV === 'production') {\n    className = processedStyleDefinitions.classNameBits.length === 1 ? '_' + processedStyleDefinitions.classNameBits[0] : '_' + (0, _util.hashString)(processedStyleDefinitions.classNameBits.join()) + getStyleDefinitionsLengthHash(styleDefinitions);\n  } else {\n    className = processedStyleDefinitions.classNameBits.join(\"-o_O-\");\n  }\n\n  injectStyleOnce(className, '.' + className, processedStyleDefinitions.definitionBits, useImportant, selectorHandlers);\n  return className;\n};\n\nexports.injectAndGetClassName = injectAndGetClassName;","map":{"version":3,"sources":["/Users/justinf/perseus-configured/node_modules/aphrodite/lib/inject.js"],"names":["Object","defineProperty","exports","value","_interopRequireDefault","obj","__esModule","_asap","require","_asap2","_orderedElements","_orderedElements2","_generate","_util","styleTag","injectStyleTag","cssContents","document","querySelector","head","getElementsByTagName","createElement","type","setAttribute","appendChild","styleSheet","cssText","createTextNode","stringHandlers","fontFamily","val","Array","isArray","map","join","injectStyleOnce","src","animationName","selectorHandlers","v","_name","hashObject","finalVal","forEach","valVal","valKey","generateCSS","keys","key","injectGeneratedCSSOnce","alreadyInjected","injectionBuffer","isBuffering","generatedCSS","Error","flushToStyleTag","selector","definitions","useImportant","arguments","length","undefined","generated","reset","startBuffering","flushToString","ret","cssContent","getRenderedClassNames","addRenderedClassNames","classNames","className","processStyleDefinitions","styleDefinitions","result","i","classNameBits","push","definitionBits","_definition","getStyleDefinitionsLengthHash","reduce","styleDefinition","_len","toString","injectAndGetClassName","processedStyleDefinitions","process","env","NODE_ENV","hashString"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n    value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _asap = require('asap');\n\nvar _asap2 = _interopRequireDefault(_asap);\n\nvar _orderedElements = require('./ordered-elements');\n\nvar _orderedElements2 = _interopRequireDefault(_orderedElements);\n\nvar _generate = require('./generate');\n\nvar _util = require('./util');\n\n/* ::\nimport type { SheetDefinition, SheetDefinitions } from './index.js';\nimport type { MaybeSheetDefinition } from './exports.js';\nimport type { SelectorHandler } from './generate.js';\ntype ProcessedStyleDefinitions = {\n  classNameBits: Array<string>,\n  definitionBits: Array<Object>,\n};\n*/\n\n// The current <style> tag we are inserting into, or null if we haven't\n// inserted anything yet. We could find this each time using\n// `document.querySelector(\"style[data-aphrodite\"])`, but holding onto it is\n// faster.\nvar styleTag = null;\n\n// Inject a string of styles into a <style> tag in the head of the document. This\n// will automatically create a style tag and then continue to use it for\n// multiple injections. It will also use a style tag with the `data-aphrodite`\n// tag on it if that exists in the DOM. This could be used for e.g. reusing the\n// same style tag that server-side rendering inserts.\nvar injectStyleTag = function injectStyleTag(cssContents /* : string */) {\n    if (styleTag == null) {\n        // Try to find a style tag with the `data-aphrodite` attribute first.\n        styleTag = document.querySelector(\"style[data-aphrodite]\");\n\n        // If that doesn't work, generate a new style tag.\n        if (styleTag == null) {\n            // Taken from\n            // http://stackoverflow.com/questions/524696/how-to-create-a-style-tag-with-javascript\n            var head = document.head || document.getElementsByTagName('head')[0];\n            styleTag = document.createElement('style');\n\n            styleTag.type = 'text/css';\n            styleTag.setAttribute(\"data-aphrodite\", \"\");\n            head.appendChild(styleTag);\n        }\n    }\n\n    if (styleTag.styleSheet) {\n        // $FlowFixMe: legacy Internet Explorer compatibility\n        styleTag.styleSheet.cssText += cssContents;\n    } else {\n        styleTag.appendChild(document.createTextNode(cssContents));\n    }\n};\n\n// Custom handlers for stringifying CSS values that have side effects\n// (such as fontFamily, which can cause @font-face rules to be injected)\nvar stringHandlers = {\n    // With fontFamily we look for objects that are passed in and interpret\n    // them as @font-face rules that we need to inject. The value of fontFamily\n    // can either be a string (as normal), an object (a single font face), or\n    // an array of objects and strings.\n    fontFamily: function fontFamily(val) {\n        if (Array.isArray(val)) {\n            return val.map(fontFamily).join(\",\");\n        } else if (typeof val === \"object\") {\n            injectStyleOnce(val.src, \"@font-face\", [val], false);\n            return '\"' + val.fontFamily + '\"';\n        } else {\n            return val;\n        }\n    },\n\n    // With animationName we look for an object that contains keyframes and\n    // inject them as an `@keyframes` block, returning a uniquely generated\n    // name. The keyframes object should look like\n    //  animationName: {\n    //    from: {\n    //      left: 0,\n    //      top: 0,\n    //    },\n    //    '50%': {\n    //      left: 15,\n    //      top: 5,\n    //    },\n    //    to: {\n    //      left: 20,\n    //      top: 20,\n    //    }\n    //  }\n    // TODO(emily): `stringHandlers` doesn't let us rename the key, so I have\n    // to use `animationName` here. Improve that so we can call this\n    // `animation` instead of `animationName`.\n    animationName: function animationName(val, selectorHandlers) {\n        if (Array.isArray(val)) {\n            return val.map(function (v) {\n                return animationName(v, selectorHandlers);\n            }).join(\",\");\n        } else if (typeof val === \"object\") {\n            // Generate a unique name based on the hash of the object. We can't\n            // just use the hash because the name can't start with a number.\n            // TODO(emily): this probably makes debugging hard, allow a custom\n            // name?\n            var _name = 'keyframe_' + (0, _util.hashObject)(val);\n\n            // Since keyframes need 3 layers of nesting, we use `generateCSS` to\n            // build the inner layers and wrap it in `@keyframes` ourselves.\n            var finalVal = '@keyframes ' + _name + '{';\n\n            // TODO see if we can find a way where checking for OrderedElements\n            // here is not necessary. Alternatively, perhaps we should have a\n            // utility method that can iterate over either a plain object, an\n            // instance of OrderedElements, or a Map, and then use that here and\n            // elsewhere.\n            if (val instanceof _orderedElements2['default']) {\n                val.forEach(function (valVal, valKey) {\n                    finalVal += (0, _generate.generateCSS)(valKey, [valVal], selectorHandlers, stringHandlers, false);\n                });\n            } else {\n                Object.keys(val).forEach(function (key) {\n                    finalVal += (0, _generate.generateCSS)(key, [val[key]], selectorHandlers, stringHandlers, false);\n                });\n            }\n            finalVal += '}';\n\n            injectGeneratedCSSOnce(_name, finalVal);\n\n            return _name;\n        } else {\n            return val;\n        }\n    }\n};\n\n// This is a map from Aphrodite's generated class names to `true` (acting as a\n// set of class names)\nvar alreadyInjected = {};\n\n// This is the buffer of styles which have not yet been flushed.\nvar injectionBuffer = \"\";\n\n// A flag to tell if we are already buffering styles. This could happen either\n// because we scheduled a flush call already, so newly added styles will\n// already be flushed, or because we are statically buffering on the server.\nvar isBuffering = false;\n\nvar injectGeneratedCSSOnce = function injectGeneratedCSSOnce(key, generatedCSS) {\n    if (alreadyInjected[key]) {\n        return;\n    }\n\n    if (!isBuffering) {\n        // We should never be automatically buffering on the server (or any\n        // place without a document), so guard against that.\n        if (typeof document === \"undefined\") {\n            throw new Error(\"Cannot automatically buffer without a document\");\n        }\n\n        // If we're not already buffering, schedule a call to flush the\n        // current styles.\n        isBuffering = true;\n        (0, _asap2['default'])(flushToStyleTag);\n    }\n\n    injectionBuffer += generatedCSS;\n    alreadyInjected[key] = true;\n};\n\nvar injectStyleOnce = function injectStyleOnce(key, /* : string */\nselector, /* : string */\ndefinitions, /* : SheetDefinition[] */\nuseImportant /* : boolean */\n) {\n    var selectorHandlers /* : SelectorHandler[] */ = arguments.length <= 4 || arguments[4] === undefined ? [] : arguments[4];\n\n    if (alreadyInjected[key]) {\n        return;\n    }\n\n    var generated = (0, _generate.generateCSS)(selector, definitions, selectorHandlers, stringHandlers, useImportant);\n\n    injectGeneratedCSSOnce(key, generated);\n};\n\nexports.injectStyleOnce = injectStyleOnce;\nvar reset = function reset() {\n    injectionBuffer = \"\";\n    alreadyInjected = {};\n    isBuffering = false;\n    styleTag = null;\n};\n\nexports.reset = reset;\nvar startBuffering = function startBuffering() {\n    if (isBuffering) {\n        throw new Error(\"Cannot buffer while already buffering\");\n    }\n    isBuffering = true;\n};\n\nexports.startBuffering = startBuffering;\nvar flushToString = function flushToString() {\n    isBuffering = false;\n    var ret = injectionBuffer;\n    injectionBuffer = \"\";\n    return ret;\n};\n\nexports.flushToString = flushToString;\nvar flushToStyleTag = function flushToStyleTag() {\n    var cssContent = flushToString();\n    if (cssContent.length > 0) {\n        injectStyleTag(cssContent);\n    }\n};\n\nexports.flushToStyleTag = flushToStyleTag;\nvar getRenderedClassNames = function getRenderedClassNames() {\n    return Object.keys(alreadyInjected);\n};\n\nexports.getRenderedClassNames = getRenderedClassNames;\nvar addRenderedClassNames = function addRenderedClassNames(classNames /* : string[] */) {\n    classNames.forEach(function (className) {\n        alreadyInjected[className] = true;\n    });\n};\n\nexports.addRenderedClassNames = addRenderedClassNames;\nvar processStyleDefinitions = function processStyleDefinitions(styleDefinitions, /* : any[] */\nresult /* : ProcessedStyleDefinitions */\n) /* : void */{\n    for (var i = 0; i < styleDefinitions.length; i += 1) {\n        // Filter out falsy values from the input, to allow for\n        // `css(a, test && c)`\n        if (styleDefinitions[i]) {\n            if (Array.isArray(styleDefinitions[i])) {\n                // We've encountered an array, so let's recurse\n                processStyleDefinitions(styleDefinitions[i], result);\n            } else {\n                result.classNameBits.push(styleDefinitions[i]._name);\n                result.definitionBits.push(styleDefinitions[i]._definition);\n            }\n        }\n    }\n};\n\n// Sum up the lengths of the stringified style definitions (which was saved as _len property)\n// and use modulus to return a single byte hash value.\n// We append this extra byte to the 32bit hash to decrease the chance of hash collisions.\nvar getStyleDefinitionsLengthHash = function getStyleDefinitionsLengthHash(styleDefinitions /* : any[] */) {\n    return (/* : string */(styleDefinitions.reduce(function (length, styleDefinition) {\n            return length + (styleDefinition ? styleDefinition._len : 0);\n        }, 0) % 36).toString(36)\n    );\n};\n\n/**\n * Inject styles associated with the passed style definition objects, and return\n * an associated CSS class name.\n *\n * @param {boolean} useImportant If true, will append !important to generated\n *     CSS output. e.g. {color: red} -> \"color: red !important\".\n * @param {(Object|Object[])[]} styleDefinitions style definition objects, or\n *     arbitrarily nested arrays of them, as returned as properties of the\n *     return value of StyleSheet.create().\n */\nvar injectAndGetClassName = function injectAndGetClassName(useImportant, /* : boolean */\nstyleDefinitions, /* : MaybeSheetDefinition[] */\nselectorHandlers /* : SelectorHandler[] */\n) /* : string */{\n    var processedStyleDefinitions /* : ProcessedStyleDefinitions */ = {\n        classNameBits: [],\n        definitionBits: []\n    };\n    // Mutates processedStyleDefinitions\n    processStyleDefinitions(styleDefinitions, processedStyleDefinitions);\n\n    // Break if there aren't any valid styles.\n    if (processedStyleDefinitions.classNameBits.length === 0) {\n        return \"\";\n    }\n\n    var className = undefined;\n    if (process.env.NODE_ENV === 'production') {\n        className = processedStyleDefinitions.classNameBits.length === 1 ? '_' + processedStyleDefinitions.classNameBits[0] : '_' + (0, _util.hashString)(processedStyleDefinitions.classNameBits.join()) + getStyleDefinitionsLengthHash(styleDefinitions);\n    } else {\n        className = processedStyleDefinitions.classNameBits.join(\"-o_O-\");\n    }\n\n    injectStyleOnce(className, '.' + className, processedStyleDefinitions.definitionBits, useImportant, selectorHandlers);\n\n    return className;\n};\nexports.injectAndGetClassName = injectAndGetClassName;"]},"metadata":{},"sourceType":"script"}