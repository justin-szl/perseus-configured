{"ast":null,"code":"/**\n * This file converts a parse tree into a cooresponding MathML tree. The main\n * entry point is the `buildMathML` function, which takes a parse tree from the\n * parser.\n */\nvar buildCommon = require(\"./buildCommon\");\n\nvar fontMetrics = require(\"./fontMetrics\");\n\nvar mathMLTree = require(\"./mathMLTree\");\n\nvar ParseError = require(\"./ParseError\");\n\nvar symbols = require(\"./symbols\");\n\nvar utils = require(\"./utils\");\n\nvar makeSpan = buildCommon.makeSpan;\nvar fontMap = buildCommon.fontMap;\n/**\n * Takes a symbol and converts it into a MathML text node after performing\n * optional replacement from symbols.js.\n */\n\nvar makeText = function (text, mode) {\n  if (symbols[mode][text] && symbols[mode][text].replace) {\n    text = symbols[mode][text].replace;\n  }\n\n  return new mathMLTree.TextNode(text);\n};\n/**\n * Returns the math variant as a string or null if none is required.\n */\n\n\nvar getVariant = function (group, options) {\n  var font = options.font;\n\n  if (!font) {\n    return null;\n  }\n\n  var mode = group.mode;\n\n  if (font === \"mathit\") {\n    return \"italic\";\n  }\n\n  var value = group.value;\n\n  if (utils.contains([\"\\\\imath\", \"\\\\jmath\"], value)) {\n    return null;\n  }\n\n  if (symbols[mode][value] && symbols[mode][value].replace) {\n    value = symbols[mode][value].replace;\n  }\n\n  var fontName = fontMap[font].fontName;\n\n  if (fontMetrics.getCharacterMetrics(value, fontName)) {\n    return fontMap[options.font].variant;\n  }\n\n  return null;\n};\n/**\n * Functions for handling the different types of groups found in the parse\n * tree. Each function should take a parse group and return a MathML node.\n */\n\n\nvar groupTypes = {};\n\ngroupTypes.mathord = function (group, options) {\n  var node = new mathMLTree.MathNode(\"mi\", [makeText(group.value, group.mode)]);\n  var variant = getVariant(group, options);\n\n  if (variant) {\n    node.setAttribute(\"mathvariant\", variant);\n  }\n\n  return node;\n};\n\ngroupTypes.textord = function (group, options) {\n  var text = makeText(group.value, group.mode);\n  var variant = getVariant(group, options) || \"normal\";\n  var node;\n\n  if (/[0-9]/.test(group.value)) {\n    // TODO(kevinb) merge adjacent <mn> nodes\n    // do it as a post processing step\n    node = new mathMLTree.MathNode(\"mn\", [text]);\n\n    if (options.font) {\n      node.setAttribute(\"mathvariant\", variant);\n    }\n  } else {\n    node = new mathMLTree.MathNode(\"mi\", [text]);\n    node.setAttribute(\"mathvariant\", variant);\n  }\n\n  return node;\n};\n\ngroupTypes.bin = function (group) {\n  var node = new mathMLTree.MathNode(\"mo\", [makeText(group.value, group.mode)]);\n  return node;\n};\n\ngroupTypes.rel = function (group) {\n  var node = new mathMLTree.MathNode(\"mo\", [makeText(group.value, group.mode)]);\n  return node;\n};\n\ngroupTypes.open = function (group) {\n  var node = new mathMLTree.MathNode(\"mo\", [makeText(group.value, group.mode)]);\n  return node;\n};\n\ngroupTypes.close = function (group) {\n  var node = new mathMLTree.MathNode(\"mo\", [makeText(group.value, group.mode)]);\n  return node;\n};\n\ngroupTypes.inner = function (group) {\n  var node = new mathMLTree.MathNode(\"mo\", [makeText(group.value, group.mode)]);\n  return node;\n};\n\ngroupTypes.punct = function (group) {\n  var node = new mathMLTree.MathNode(\"mo\", [makeText(group.value, group.mode)]);\n  node.setAttribute(\"separator\", \"true\");\n  return node;\n};\n\ngroupTypes.ordgroup = function (group, options) {\n  var inner = buildExpression(group.value, options);\n  var node = new mathMLTree.MathNode(\"mrow\", inner);\n  return node;\n};\n\ngroupTypes.text = function (group, options) {\n  var inner = buildExpression(group.value.body, options);\n  var node = new mathMLTree.MathNode(\"mtext\", inner);\n  return node;\n};\n\ngroupTypes.color = function (group, options) {\n  var inner = buildExpression(group.value.value, options);\n  var node = new mathMLTree.MathNode(\"mstyle\", inner);\n  node.setAttribute(\"mathcolor\", group.value.color);\n  return node;\n};\n\ngroupTypes.supsub = function (group, options) {\n  var children = [buildGroup(group.value.base, options)];\n\n  if (group.value.sub) {\n    children.push(buildGroup(group.value.sub, options));\n  }\n\n  if (group.value.sup) {\n    children.push(buildGroup(group.value.sup, options));\n  }\n\n  var nodeType;\n\n  if (!group.value.sub) {\n    nodeType = \"msup\";\n  } else if (!group.value.sup) {\n    nodeType = \"msub\";\n  } else {\n    nodeType = \"msubsup\";\n  }\n\n  var node = new mathMLTree.MathNode(nodeType, children);\n  return node;\n};\n\ngroupTypes.genfrac = function (group, options) {\n  var node = new mathMLTree.MathNode(\"mfrac\", [buildGroup(group.value.numer, options), buildGroup(group.value.denom, options)]);\n\n  if (!group.value.hasBarLine) {\n    node.setAttribute(\"linethickness\", \"0px\");\n  }\n\n  if (group.value.leftDelim != null || group.value.rightDelim != null) {\n    var withDelims = [];\n\n    if (group.value.leftDelim != null) {\n      var leftOp = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(group.value.leftDelim)]);\n      leftOp.setAttribute(\"fence\", \"true\");\n      withDelims.push(leftOp);\n    }\n\n    withDelims.push(node);\n\n    if (group.value.rightDelim != null) {\n      var rightOp = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(group.value.rightDelim)]);\n      rightOp.setAttribute(\"fence\", \"true\");\n      withDelims.push(rightOp);\n    }\n\n    var outerNode = new mathMLTree.MathNode(\"mrow\", withDelims);\n    return outerNode;\n  }\n\n  return node;\n};\n\ngroupTypes.array = function (group, options) {\n  return new mathMLTree.MathNode(\"mtable\", group.value.body.map(function (row) {\n    return new mathMLTree.MathNode(\"mtr\", row.map(function (cell) {\n      return new mathMLTree.MathNode(\"mtd\", [buildGroup(cell, options)]);\n    }));\n  }));\n};\n\ngroupTypes.sqrt = function (group, options) {\n  var node;\n\n  if (group.value.index) {\n    node = new mathMLTree.MathNode(\"mroot\", [buildGroup(group.value.body, options), buildGroup(group.value.index, options)]);\n  } else {\n    node = new mathMLTree.MathNode(\"msqrt\", [buildGroup(group.value.body, options)]);\n  }\n\n  return node;\n};\n\ngroupTypes.leftright = function (group, options) {\n  var inner = buildExpression(group.value.body, options);\n\n  if (group.value.left !== \".\") {\n    var leftNode = new mathMLTree.MathNode(\"mo\", [makeText(group.value.left, group.mode)]);\n    leftNode.setAttribute(\"fence\", \"true\");\n    inner.unshift(leftNode);\n  }\n\n  if (group.value.right !== \".\") {\n    var rightNode = new mathMLTree.MathNode(\"mo\", [makeText(group.value.right, group.mode)]);\n    rightNode.setAttribute(\"fence\", \"true\");\n    inner.push(rightNode);\n  }\n\n  var outerNode = new mathMLTree.MathNode(\"mrow\", inner);\n  return outerNode;\n};\n\ngroupTypes.middle = function (group, options) {\n  var middleNode = new mathMLTree.MathNode(\"mo\", [makeText(group.value.middle, group.mode)]);\n  middleNode.setAttribute(\"fence\", \"true\");\n  return middleNode;\n};\n\ngroupTypes.accent = function (group, options) {\n  var accentNode = new mathMLTree.MathNode(\"mo\", [makeText(group.value.accent, group.mode)]);\n  var node = new mathMLTree.MathNode(\"mover\", [buildGroup(group.value.base, options), accentNode]);\n  node.setAttribute(\"accent\", \"true\");\n  return node;\n};\n\ngroupTypes.spacing = function (group) {\n  var node;\n\n  if (group.value === \"\\\\ \" || group.value === \"\\\\space\" || group.value === \" \" || group.value === \"~\") {\n    node = new mathMLTree.MathNode(\"mtext\", [new mathMLTree.TextNode(\"\\u00a0\")]);\n  } else {\n    node = new mathMLTree.MathNode(\"mspace\");\n    node.setAttribute(\"width\", buildCommon.spacingFunctions[group.value].size);\n  }\n\n  return node;\n};\n\ngroupTypes.op = function (group, options) {\n  var node; // TODO(emily): handle big operators using the `largeop` attribute\n\n  if (group.value.symbol) {\n    // This is a symbol. Just add the symbol.\n    node = new mathMLTree.MathNode(\"mo\", [makeText(group.value.body, group.mode)]);\n  } else if (group.value.value) {\n    // This is an operator with children. Add them.\n    node = new mathMLTree.MathNode(\"mo\", buildExpression(group.value.value, options));\n  } else {\n    // This is a text operator. Add all of the characters from the\n    // operator's name.\n    // TODO(emily): Add a space in the middle of some of these\n    // operators, like \\limsup.\n    node = new mathMLTree.MathNode(\"mi\", [new mathMLTree.TextNode(group.value.body.slice(1))]);\n  }\n\n  return node;\n};\n\ngroupTypes.mod = function (group, options) {\n  var inner = [];\n\n  if (group.value.modType === \"pod\" || group.value.modType === \"pmod\") {\n    inner.push(new mathMLTree.MathNode(\"mo\", [makeText(\"(\", group.mode)]));\n  }\n\n  if (group.value.modType !== \"pod\") {\n    inner.push(new mathMLTree.MathNode(\"mo\", [makeText(\"mod\", group.mode)]));\n  }\n\n  if (group.value.value) {\n    var space = new mathMLTree.MathNode(\"mspace\");\n    space.setAttribute(\"width\", \"0.333333em\");\n    inner.push(space);\n    inner = inner.concat(buildExpression(group.value.value, options));\n  }\n\n  if (group.value.modType === \"pod\" || group.value.modType === \"pmod\") {\n    inner.push(new mathMLTree.MathNode(\"mo\", [makeText(\")\", group.mode)]));\n  }\n\n  return new mathMLTree.MathNode(\"mo\", inner);\n};\n\ngroupTypes.katex = function (group) {\n  var node = new mathMLTree.MathNode(\"mtext\", [new mathMLTree.TextNode(\"KaTeX\")]);\n  return node;\n};\n\ngroupTypes.font = function (group, options) {\n  var font = group.value.font;\n  return buildGroup(group.value.body, options.withFont(font));\n};\n\ngroupTypes.delimsizing = function (group) {\n  var children = [];\n\n  if (group.value.value !== \".\") {\n    children.push(makeText(group.value.value, group.mode));\n  }\n\n  var node = new mathMLTree.MathNode(\"mo\", children);\n\n  if (group.value.mclass === \"mopen\" || group.value.mclass === \"mclose\") {\n    // Only some of the delimsizing functions act as fences, and they\n    // return \"mopen\" or \"mclose\" mclass.\n    node.setAttribute(\"fence\", \"true\");\n  } else {\n    // Explicitly disable fencing if it's not a fence, to override the\n    // defaults.\n    node.setAttribute(\"fence\", \"false\");\n  }\n\n  return node;\n};\n\ngroupTypes.styling = function (group, options) {\n  var inner = buildExpression(group.value.value, options);\n  var node = new mathMLTree.MathNode(\"mstyle\", inner);\n  var styleAttributes = {\n    \"display\": [\"0\", \"true\"],\n    \"text\": [\"0\", \"false\"],\n    \"script\": [\"1\", \"false\"],\n    \"scriptscript\": [\"2\", \"false\"]\n  };\n  var attr = styleAttributes[group.value.style];\n  node.setAttribute(\"scriptlevel\", attr[0]);\n  node.setAttribute(\"displaystyle\", attr[1]);\n  return node;\n};\n\ngroupTypes.sizing = function (group, options) {\n  var inner = buildExpression(group.value.value, options);\n  var node = new mathMLTree.MathNode(\"mstyle\", inner); // TODO(emily): This doesn't produce the correct size for nested size\n  // changes, because we don't keep state of what style we're currently\n  // in, so we can't reset the size to normal before changing it.  Now\n  // that we're passing an options parameter we should be able to fix\n  // this.\n\n  node.setAttribute(\"mathsize\", buildCommon.sizingMultiplier[group.value.size] + \"em\");\n  return node;\n};\n\ngroupTypes.overline = function (group, options) {\n  var operator = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(\"\\u203e\")]);\n  operator.setAttribute(\"stretchy\", \"true\");\n  var node = new mathMLTree.MathNode(\"mover\", [buildGroup(group.value.body, options), operator]);\n  node.setAttribute(\"accent\", \"true\");\n  return node;\n};\n\ngroupTypes.underline = function (group, options) {\n  var operator = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(\"\\u203e\")]);\n  operator.setAttribute(\"stretchy\", \"true\");\n  var node = new mathMLTree.MathNode(\"munder\", [buildGroup(group.value.body, options), operator]);\n  node.setAttribute(\"accentunder\", \"true\");\n  return node;\n};\n\ngroupTypes.rule = function (group) {\n  // TODO(emily): Figure out if there's an actual way to draw black boxes\n  // in MathML.\n  var node = new mathMLTree.MathNode(\"mrow\");\n  return node;\n};\n\ngroupTypes.kern = function (group) {\n  // TODO(kevin): Figure out if there's a way to add space in MathML\n  var node = new mathMLTree.MathNode(\"mrow\");\n  return node;\n};\n\ngroupTypes.llap = function (group, options) {\n  var node = new mathMLTree.MathNode(\"mpadded\", [buildGroup(group.value.body, options)]);\n  node.setAttribute(\"lspace\", \"-1width\");\n  node.setAttribute(\"width\", \"0px\");\n  return node;\n};\n\ngroupTypes.rlap = function (group, options) {\n  var node = new mathMLTree.MathNode(\"mpadded\", [buildGroup(group.value.body, options)]);\n  node.setAttribute(\"width\", \"0px\");\n  return node;\n};\n\ngroupTypes.phantom = function (group, options) {\n  var inner = buildExpression(group.value.value, options);\n  return new mathMLTree.MathNode(\"mphantom\", inner);\n};\n\ngroupTypes.mclass = function (group, options) {\n  var inner = buildExpression(group.value.value, options);\n  return new mathMLTree.MathNode(\"mstyle\", inner);\n};\n/**\n * Takes a list of nodes, builds them, and returns a list of the generated\n * MathML nodes. A little simpler than the HTML version because we don't do any\n * previous-node handling.\n */\n\n\nvar buildExpression = function (expression, options) {\n  var groups = [];\n\n  for (var i = 0; i < expression.length; i++) {\n    var group = expression[i];\n    groups.push(buildGroup(group, options));\n  }\n\n  return groups;\n};\n/**\n * Takes a group from the parser and calls the appropriate groupTypes function\n * on it to produce a MathML node.\n */\n\n\nvar buildGroup = function (group, options) {\n  if (!group) {\n    return new mathMLTree.MathNode(\"mrow\");\n  }\n\n  if (groupTypes[group.type]) {\n    // Call the groupTypes function\n    return groupTypes[group.type](group, options);\n  } else {\n    throw new ParseError(\"Got group of unknown type: '\" + group.type + \"'\");\n  }\n};\n/**\n * Takes a full parse tree and settings and builds a MathML representation of\n * it. In particular, we put the elements from building the parse tree into a\n * <semantics> tag so we can also include that TeX source as an annotation.\n *\n * Note that we actually return a domTree element with a `<math>` inside it so\n * we can do appropriate styling.\n */\n\n\nvar buildMathML = function (tree, texExpression, options) {\n  var expression = buildExpression(tree, options); // Wrap up the expression in an mrow so it is presented in the semantics\n  // tag correctly.\n\n  var wrapper = new mathMLTree.MathNode(\"mrow\", expression); // Build a TeX annotation of the source\n\n  var annotation = new mathMLTree.MathNode(\"annotation\", [new mathMLTree.TextNode(texExpression)]);\n  annotation.setAttribute(\"encoding\", \"application/x-tex\");\n  var semantics = new mathMLTree.MathNode(\"semantics\", [wrapper, annotation]);\n  var math = new mathMLTree.MathNode(\"math\", [semantics]); // You can't style <math> nodes, so we wrap the node in a span.\n\n  return makeSpan([\"katex-mathml\"], [math]);\n};\n\nmodule.exports = buildMathML;","map":{"version":3,"sources":["/Users/justinf/perseus-configured/node_modules/katex/src/buildMathML.js"],"names":["buildCommon","require","fontMetrics","mathMLTree","ParseError","symbols","utils","makeSpan","fontMap","makeText","text","mode","replace","TextNode","getVariant","group","options","font","value","contains","fontName","getCharacterMetrics","variant","groupTypes","mathord","node","MathNode","setAttribute","textord","test","bin","rel","open","close","inner","punct","ordgroup","buildExpression","body","color","supsub","children","buildGroup","base","sub","push","sup","nodeType","genfrac","numer","denom","hasBarLine","leftDelim","rightDelim","withDelims","leftOp","rightOp","outerNode","array","map","row","cell","sqrt","index","leftright","left","leftNode","unshift","right","rightNode","middle","middleNode","accent","accentNode","spacing","spacingFunctions","size","op","symbol","slice","mod","modType","space","concat","katex","withFont","delimsizing","mclass","styling","styleAttributes","attr","style","sizing","sizingMultiplier","overline","operator","underline","rule","kern","llap","rlap","phantom","expression","groups","i","length","type","buildMathML","tree","texExpression","wrapper","annotation","semantics","math","module","exports"],"mappings":"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","sourcesContent":["/**\n * This file converts a parse tree into a cooresponding MathML tree. The main\n * entry point is the `buildMathML` function, which takes a parse tree from the\n * parser.\n */\n\nvar buildCommon = require(\"./buildCommon\");\nvar fontMetrics = require(\"./fontMetrics\");\nvar mathMLTree = require(\"./mathMLTree\");\nvar ParseError = require(\"./ParseError\");\nvar symbols = require(\"./symbols\");\nvar utils = require(\"./utils\");\n\nvar makeSpan = buildCommon.makeSpan;\nvar fontMap = buildCommon.fontMap;\n\n/**\n * Takes a symbol and converts it into a MathML text node after performing\n * optional replacement from symbols.js.\n */\nvar makeText = function(text, mode) {\n    if (symbols[mode][text] && symbols[mode][text].replace) {\n        text = symbols[mode][text].replace;\n    }\n\n    return new mathMLTree.TextNode(text);\n};\n\n/**\n * Returns the math variant as a string or null if none is required.\n */\nvar getVariant = function(group, options) {\n    var font = options.font;\n    if (!font) {\n        return null;\n    }\n\n    var mode = group.mode;\n    if (font === \"mathit\") {\n        return \"italic\";\n    }\n\n    var value = group.value;\n    if (utils.contains([\"\\\\imath\", \"\\\\jmath\"], value)) {\n        return null;\n    }\n\n    if (symbols[mode][value] && symbols[mode][value].replace) {\n        value = symbols[mode][value].replace;\n    }\n\n    var fontName = fontMap[font].fontName;\n    if (fontMetrics.getCharacterMetrics(value, fontName)) {\n        return fontMap[options.font].variant;\n    }\n\n    return null;\n};\n\n/**\n * Functions for handling the different types of groups found in the parse\n * tree. Each function should take a parse group and return a MathML node.\n */\nvar groupTypes = {};\n\ngroupTypes.mathord = function(group, options) {\n    var node = new mathMLTree.MathNode(\n        \"mi\",\n        [makeText(group.value, group.mode)]);\n\n    var variant = getVariant(group, options);\n    if (variant) {\n        node.setAttribute(\"mathvariant\", variant);\n    }\n    return node;\n};\n\ngroupTypes.textord = function(group, options) {\n    var text = makeText(group.value, group.mode);\n\n    var variant = getVariant(group, options) || \"normal\";\n\n    var node;\n    if (/[0-9]/.test(group.value)) {\n        // TODO(kevinb) merge adjacent <mn> nodes\n        // do it as a post processing step\n        node = new mathMLTree.MathNode(\"mn\", [text]);\n        if (options.font) {\n            node.setAttribute(\"mathvariant\", variant);\n        }\n    } else {\n        node = new mathMLTree.MathNode(\"mi\", [text]);\n        node.setAttribute(\"mathvariant\", variant);\n    }\n\n    return node;\n};\n\ngroupTypes.bin = function(group) {\n    var node = new mathMLTree.MathNode(\n        \"mo\", [makeText(group.value, group.mode)]);\n\n    return node;\n};\n\ngroupTypes.rel = function(group) {\n    var node = new mathMLTree.MathNode(\n        \"mo\", [makeText(group.value, group.mode)]);\n\n    return node;\n};\n\ngroupTypes.open = function(group) {\n    var node = new mathMLTree.MathNode(\n        \"mo\", [makeText(group.value, group.mode)]);\n\n    return node;\n};\n\ngroupTypes.close = function(group) {\n    var node = new mathMLTree.MathNode(\n        \"mo\", [makeText(group.value, group.mode)]);\n\n    return node;\n};\n\ngroupTypes.inner = function(group) {\n    var node = new mathMLTree.MathNode(\n        \"mo\", [makeText(group.value, group.mode)]);\n\n    return node;\n};\n\ngroupTypes.punct = function(group) {\n    var node = new mathMLTree.MathNode(\n        \"mo\", [makeText(group.value, group.mode)]);\n\n    node.setAttribute(\"separator\", \"true\");\n\n    return node;\n};\n\ngroupTypes.ordgroup = function(group, options) {\n    var inner = buildExpression(group.value, options);\n\n    var node = new mathMLTree.MathNode(\"mrow\", inner);\n\n    return node;\n};\n\ngroupTypes.text = function(group, options) {\n    var inner = buildExpression(group.value.body, options);\n\n    var node = new mathMLTree.MathNode(\"mtext\", inner);\n\n    return node;\n};\n\ngroupTypes.color = function(group, options) {\n    var inner = buildExpression(group.value.value, options);\n\n    var node = new mathMLTree.MathNode(\"mstyle\", inner);\n\n    node.setAttribute(\"mathcolor\", group.value.color);\n\n    return node;\n};\n\ngroupTypes.supsub = function(group, options) {\n    var children = [buildGroup(group.value.base, options)];\n\n    if (group.value.sub) {\n        children.push(buildGroup(group.value.sub, options));\n    }\n\n    if (group.value.sup) {\n        children.push(buildGroup(group.value.sup, options));\n    }\n\n    var nodeType;\n    if (!group.value.sub) {\n        nodeType = \"msup\";\n    } else if (!group.value.sup) {\n        nodeType = \"msub\";\n    } else {\n        nodeType = \"msubsup\";\n    }\n\n    var node = new mathMLTree.MathNode(nodeType, children);\n\n    return node;\n};\n\ngroupTypes.genfrac = function(group, options) {\n    var node = new mathMLTree.MathNode(\n        \"mfrac\",\n        [buildGroup(group.value.numer, options),\n            buildGroup(group.value.denom, options)]);\n\n    if (!group.value.hasBarLine) {\n        node.setAttribute(\"linethickness\", \"0px\");\n    }\n\n    if (group.value.leftDelim != null || group.value.rightDelim != null) {\n        var withDelims = [];\n\n        if (group.value.leftDelim != null) {\n            var leftOp = new mathMLTree.MathNode(\n                \"mo\", [new mathMLTree.TextNode(group.value.leftDelim)]);\n\n            leftOp.setAttribute(\"fence\", \"true\");\n\n            withDelims.push(leftOp);\n        }\n\n        withDelims.push(node);\n\n        if (group.value.rightDelim != null) {\n            var rightOp = new mathMLTree.MathNode(\n                \"mo\", [new mathMLTree.TextNode(group.value.rightDelim)]);\n\n            rightOp.setAttribute(\"fence\", \"true\");\n\n            withDelims.push(rightOp);\n        }\n\n        var outerNode = new mathMLTree.MathNode(\"mrow\", withDelims);\n\n        return outerNode;\n    }\n\n    return node;\n};\n\ngroupTypes.array = function(group, options) {\n    return new mathMLTree.MathNode(\n        \"mtable\", group.value.body.map(function(row) {\n            return new mathMLTree.MathNode(\n                \"mtr\", row.map(function(cell) {\n                    return new mathMLTree.MathNode(\n                        \"mtd\", [buildGroup(cell, options)]);\n                }));\n        }));\n};\n\ngroupTypes.sqrt = function(group, options) {\n    var node;\n    if (group.value.index) {\n        node = new mathMLTree.MathNode(\n            \"mroot\", [\n                buildGroup(group.value.body, options),\n                buildGroup(group.value.index, options)\n            ]);\n    } else {\n        node = new mathMLTree.MathNode(\n            \"msqrt\", [buildGroup(group.value.body, options)]);\n    }\n\n    return node;\n};\n\ngroupTypes.leftright = function(group, options) {\n    var inner = buildExpression(group.value.body, options);\n\n    if (group.value.left !== \".\") {\n        var leftNode = new mathMLTree.MathNode(\n            \"mo\", [makeText(group.value.left, group.mode)]);\n\n        leftNode.setAttribute(\"fence\", \"true\");\n\n        inner.unshift(leftNode);\n    }\n\n    if (group.value.right !== \".\") {\n        var rightNode = new mathMLTree.MathNode(\n            \"mo\", [makeText(group.value.right, group.mode)]);\n\n        rightNode.setAttribute(\"fence\", \"true\");\n\n        inner.push(rightNode);\n    }\n\n    var outerNode = new mathMLTree.MathNode(\"mrow\", inner);\n\n    return outerNode;\n};\n\ngroupTypes.middle = function(group, options) {\n    var middleNode = new mathMLTree.MathNode(\n        \"mo\", [makeText(group.value.middle, group.mode)]);\n    middleNode.setAttribute(\"fence\", \"true\");\n    return middleNode;\n};\n\ngroupTypes.accent = function(group, options) {\n    var accentNode = new mathMLTree.MathNode(\n        \"mo\", [makeText(group.value.accent, group.mode)]);\n\n    var node = new mathMLTree.MathNode(\n        \"mover\",\n        [buildGroup(group.value.base, options),\n            accentNode]);\n\n    node.setAttribute(\"accent\", \"true\");\n\n    return node;\n};\n\ngroupTypes.spacing = function(group) {\n    var node;\n\n    if (group.value === \"\\\\ \" || group.value === \"\\\\space\" ||\n        group.value === \" \" || group.value === \"~\") {\n        node = new mathMLTree.MathNode(\n            \"mtext\", [new mathMLTree.TextNode(\"\\u00a0\")]);\n    } else {\n        node = new mathMLTree.MathNode(\"mspace\");\n\n        node.setAttribute(\n            \"width\", buildCommon.spacingFunctions[group.value].size);\n    }\n\n    return node;\n};\n\ngroupTypes.op = function(group, options) {\n    var node;\n\n    // TODO(emily): handle big operators using the `largeop` attribute\n\n    if (group.value.symbol) {\n        // This is a symbol. Just add the symbol.\n        node = new mathMLTree.MathNode(\n            \"mo\", [makeText(group.value.body, group.mode)]);\n    } else if (group.value.value) {\n        // This is an operator with children. Add them.\n        node = new mathMLTree.MathNode(\n            \"mo\", buildExpression(group.value.value, options));\n    } else {\n        // This is a text operator. Add all of the characters from the\n        // operator's name.\n        // TODO(emily): Add a space in the middle of some of these\n        // operators, like \\limsup.\n        node = new mathMLTree.MathNode(\n            \"mi\", [new mathMLTree.TextNode(group.value.body.slice(1))]);\n    }\n\n    return node;\n};\n\ngroupTypes.mod = function(group, options) {\n    var inner = [];\n\n    if (group.value.modType === \"pod\" || group.value.modType === \"pmod\") {\n        inner.push(new mathMLTree.MathNode(\n            \"mo\", [makeText(\"(\", group.mode)]));\n    }\n    if (group.value.modType !== \"pod\") {\n        inner.push(new mathMLTree.MathNode(\n            \"mo\", [makeText(\"mod\", group.mode)]));\n    }\n    if (group.value.value) {\n        var space = new mathMLTree.MathNode(\"mspace\");\n        space.setAttribute(\"width\", \"0.333333em\");\n        inner.push(space);\n        inner = inner.concat(buildExpression(group.value.value, options));\n    }\n    if (group.value.modType === \"pod\" || group.value.modType === \"pmod\") {\n        inner.push(new mathMLTree.MathNode(\n            \"mo\", [makeText(\")\", group.mode)]));\n    }\n\n    return new mathMLTree.MathNode(\"mo\", inner);\n};\n\ngroupTypes.katex = function(group) {\n    var node = new mathMLTree.MathNode(\n        \"mtext\", [new mathMLTree.TextNode(\"KaTeX\")]);\n\n    return node;\n};\n\ngroupTypes.font = function(group, options) {\n    var font = group.value.font;\n    return buildGroup(group.value.body, options.withFont(font));\n};\n\ngroupTypes.delimsizing = function(group) {\n    var children = [];\n\n    if (group.value.value !== \".\") {\n        children.push(makeText(group.value.value, group.mode));\n    }\n\n    var node = new mathMLTree.MathNode(\"mo\", children);\n\n    if (group.value.mclass === \"mopen\" ||\n        group.value.mclass === \"mclose\") {\n        // Only some of the delimsizing functions act as fences, and they\n        // return \"mopen\" or \"mclose\" mclass.\n        node.setAttribute(\"fence\", \"true\");\n    } else {\n        // Explicitly disable fencing if it's not a fence, to override the\n        // defaults.\n        node.setAttribute(\"fence\", \"false\");\n    }\n\n    return node;\n};\n\ngroupTypes.styling = function(group, options) {\n    var inner = buildExpression(group.value.value, options);\n\n    var node = new mathMLTree.MathNode(\"mstyle\", inner);\n\n    var styleAttributes = {\n        \"display\": [\"0\", \"true\"],\n        \"text\": [\"0\", \"false\"],\n        \"script\": [\"1\", \"false\"],\n        \"scriptscript\": [\"2\", \"false\"]\n    };\n\n    var attr = styleAttributes[group.value.style];\n\n    node.setAttribute(\"scriptlevel\", attr[0]);\n    node.setAttribute(\"displaystyle\", attr[1]);\n\n    return node;\n};\n\ngroupTypes.sizing = function(group, options) {\n    var inner = buildExpression(group.value.value, options);\n\n    var node = new mathMLTree.MathNode(\"mstyle\", inner);\n\n    // TODO(emily): This doesn't produce the correct size for nested size\n    // changes, because we don't keep state of what style we're currently\n    // in, so we can't reset the size to normal before changing it.  Now\n    // that we're passing an options parameter we should be able to fix\n    // this.\n    node.setAttribute(\n        \"mathsize\", buildCommon.sizingMultiplier[group.value.size] + \"em\");\n\n    return node;\n};\n\ngroupTypes.overline = function(group, options) {\n    var operator = new mathMLTree.MathNode(\n        \"mo\", [new mathMLTree.TextNode(\"\\u203e\")]);\n    operator.setAttribute(\"stretchy\", \"true\");\n\n    var node = new mathMLTree.MathNode(\n        \"mover\",\n        [buildGroup(group.value.body, options),\n            operator]);\n    node.setAttribute(\"accent\", \"true\");\n\n    return node;\n};\n\ngroupTypes.underline = function(group, options) {\n    var operator = new mathMLTree.MathNode(\n        \"mo\", [new mathMLTree.TextNode(\"\\u203e\")]);\n    operator.setAttribute(\"stretchy\", \"true\");\n\n    var node = new mathMLTree.MathNode(\n        \"munder\",\n        [buildGroup(group.value.body, options),\n            operator]);\n    node.setAttribute(\"accentunder\", \"true\");\n\n    return node;\n};\n\ngroupTypes.rule = function(group) {\n    // TODO(emily): Figure out if there's an actual way to draw black boxes\n    // in MathML.\n    var node = new mathMLTree.MathNode(\"mrow\");\n\n    return node;\n};\n\ngroupTypes.kern = function(group) {\n    // TODO(kevin): Figure out if there's a way to add space in MathML\n    var node = new mathMLTree.MathNode(\"mrow\");\n\n    return node;\n};\n\ngroupTypes.llap = function(group, options) {\n    var node = new mathMLTree.MathNode(\n        \"mpadded\", [buildGroup(group.value.body, options)]);\n\n    node.setAttribute(\"lspace\", \"-1width\");\n    node.setAttribute(\"width\", \"0px\");\n\n    return node;\n};\n\ngroupTypes.rlap = function(group, options) {\n    var node = new mathMLTree.MathNode(\n        \"mpadded\", [buildGroup(group.value.body, options)]);\n\n    node.setAttribute(\"width\", \"0px\");\n\n    return node;\n};\n\ngroupTypes.phantom = function(group, options) {\n    var inner = buildExpression(group.value.value, options);\n    return new mathMLTree.MathNode(\"mphantom\", inner);\n};\n\ngroupTypes.mclass = function(group, options) {\n    var inner = buildExpression(group.value.value, options);\n    return new mathMLTree.MathNode(\"mstyle\", inner);\n};\n\n/**\n * Takes a list of nodes, builds them, and returns a list of the generated\n * MathML nodes. A little simpler than the HTML version because we don't do any\n * previous-node handling.\n */\nvar buildExpression = function(expression, options) {\n    var groups = [];\n    for (var i = 0; i < expression.length; i++) {\n        var group = expression[i];\n        groups.push(buildGroup(group, options));\n    }\n    return groups;\n};\n\n/**\n * Takes a group from the parser and calls the appropriate groupTypes function\n * on it to produce a MathML node.\n */\nvar buildGroup = function(group, options) {\n    if (!group) {\n        return new mathMLTree.MathNode(\"mrow\");\n    }\n\n    if (groupTypes[group.type]) {\n        // Call the groupTypes function\n        return groupTypes[group.type](group, options);\n    } else {\n        throw new ParseError(\n            \"Got group of unknown type: '\" + group.type + \"'\");\n    }\n};\n\n/**\n * Takes a full parse tree and settings and builds a MathML representation of\n * it. In particular, we put the elements from building the parse tree into a\n * <semantics> tag so we can also include that TeX source as an annotation.\n *\n * Note that we actually return a domTree element with a `<math>` inside it so\n * we can do appropriate styling.\n */\nvar buildMathML = function(tree, texExpression, options) {\n    var expression = buildExpression(tree, options);\n\n    // Wrap up the expression in an mrow so it is presented in the semantics\n    // tag correctly.\n    var wrapper = new mathMLTree.MathNode(\"mrow\", expression);\n\n    // Build a TeX annotation of the source\n    var annotation = new mathMLTree.MathNode(\n        \"annotation\", [new mathMLTree.TextNode(texExpression)]);\n\n    annotation.setAttribute(\"encoding\", \"application/x-tex\");\n\n    var semantics = new mathMLTree.MathNode(\n        \"semantics\", [wrapper, annotation]);\n\n    var math = new mathMLTree.MathNode(\"math\", [semantics]);\n\n    // You can't style <math> nodes, so we wrap the node in a span.\n    return makeSpan([\"katex-mathml\"], [math]);\n};\n\nmodule.exports = buildMathML;\n"]},"metadata":{},"sourceType":"script"}