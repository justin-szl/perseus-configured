{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _inlineStylePrefixerStaticCreatePrefixer = require('inline-style-prefixer/static/createPrefixer');\n\nvar _inlineStylePrefixerStaticCreatePrefixer2 = _interopRequireDefault(_inlineStylePrefixerStaticCreatePrefixer);\n\nvar _libStaticPrefixData = require('../lib/staticPrefixData');\n\nvar _libStaticPrefixData2 = _interopRequireDefault(_libStaticPrefixData);\n\nvar _orderedElements = require('./ordered-elements');\n\nvar _orderedElements2 = _interopRequireDefault(_orderedElements);\n\nvar _util = require('./util');\n\nvar prefixAll = (0, _inlineStylePrefixerStaticCreatePrefixer2['default'])(_libStaticPrefixData2['default']);\n/* ::\nimport type { SheetDefinition } from './index.js';\ntype StringHandlers = { [id:string]: Function };\ntype SelectorCallback = (selector: string) => any;\nexport type SelectorHandler = (\n    selector: string,\n    baseSelector: string,\n    callback: SelectorCallback\n) => string | null;\n*/\n\n/**\n * `selectorHandlers` are functions which handle special selectors which act\n * differently than normal style definitions. These functions look at the\n * current selector and can generate CSS for the styles in their subtree by\n * calling the callback with a new selector.\n *\n * For example, when generating styles with a base selector of '.foo' and the\n * following styles object:\n *\n *   {\n *     ':nth-child(2n)': {\n *       ':hover': {\n *         color: 'red'\n *       }\n *     }\n *   }\n *\n * when we reach the ':hover' style, we would call our selector handlers like\n *\n *   handler(':hover', '.foo:nth-child(2n)', callback)\n *\n * Since our `pseudoSelectors` handles ':hover' styles, that handler would call\n * the callback like\n *\n *   callback('.foo:nth-child(2n):hover')\n *\n * to generate its subtree `{ color: 'red' }` styles with a\n * '.foo:nth-child(2n):hover' selector. The callback would return CSS like\n *\n *   '.foo:nth-child(2n):hover{color:red !important;}'\n *\n * and the handler would then return that resulting CSS.\n *\n * `defaultSelectorHandlers` is the list of default handlers used in a call to\n * `generateCSS`.\n *\n * @name SelectorHandler\n * @function\n * @param {string} selector: The currently inspected selector. ':hover' in the\n *     example above.\n * @param {string} baseSelector: The selector of the parent styles.\n *     '.foo:nth-child(2n)' in the example above.\n * @param {function} generateSubtreeStyles: A function which can be called to\n *     generate CSS for the subtree of styles corresponding to the selector.\n *     Accepts a new baseSelector to use for generating those styles.\n * @returns {?string} The generated CSS for this selector, or null if we don't\n *     handle this selector.\n */\n\nvar defaultSelectorHandlers = [// Handle pseudo-selectors, like :hover and :nth-child(3n)\nfunction pseudoSelectors(selector,\n/* : string */\nbaseSelector,\n/* : string */\ngenerateSubtreeStyles\n/* : Function */\n)\n/* */\n{\n  if (selector[0] !== \":\") {\n    return null;\n  }\n\n  return generateSubtreeStyles(baseSelector + selector);\n}, // Handle media queries (or font-faces)\nfunction mediaQueries(selector,\n/* : string */\nbaseSelector,\n/* : string */\ngenerateSubtreeStyles\n/* : Function */\n)\n/* */\n{\n  if (selector[0] !== \"@\") {\n    return null;\n  } // Generate the styles normally, and then wrap them in the media query.\n\n\n  var generated = generateSubtreeStyles(baseSelector);\n  return selector + '{' + generated + '}';\n}];\nexports.defaultSelectorHandlers = defaultSelectorHandlers;\n/**\n * Generate CSS for a selector and some styles.\n *\n * This function handles the media queries and pseudo selectors that can be used\n * in aphrodite styles.\n *\n * @param {string} selector: A base CSS selector for the styles to be generated\n *     with.\n * @param {Object} styleTypes: A list of properties of the return type of\n *     StyleSheet.create, e.g. [styles.red, styles.blue].\n * @param {Array.<SelectorHandler>} selectorHandlers: A list of selector\n *     handlers to use for handling special selectors. See\n *     `defaultSelectorHandlers`.\n * @param stringHandlers: See `generateCSSRuleset`\n * @param useImportant: See `generateCSSRuleset`\n *\n * To actually generate the CSS special-construct-less styles are passed to\n * `generateCSSRuleset`.\n *\n * For instance, a call to\n *\n *     generateCSS(\".foo\", [{\n *       color: \"red\",\n *       \"@media screen\": {\n *         height: 20,\n *         \":hover\": {\n *           backgroundColor: \"black\"\n *         }\n *       },\n *       \":active\": {\n *         fontWeight: \"bold\"\n *       }\n *     }], defaultSelectorHandlers);\n *\n * with the default `selectorHandlers` will make 5 calls to\n * `generateCSSRuleset`:\n *\n *     generateCSSRuleset(\".foo\", { color: \"red\" }, ...)\n *     generateCSSRuleset(\".foo:active\", { fontWeight: \"bold\" }, ...)\n *     // These 2 will be wrapped in @media screen {}\n *     generateCSSRuleset(\".foo\", { height: 20 }, ...)\n *     generateCSSRuleset(\".foo:hover\", { backgroundColor: \"black\" }, ...)\n */\n\nvar generateCSS = function generateCSS(selector,\n/* : string */\nstyleTypes,\n/* : SheetDefinition[] */\nselectorHandlers,\n/* : SelectorHandler[] */\nstringHandlers,\n/* : StringHandlers */\nuseImportant\n/* : boolean */\n)\n/* : string */\n{\n  var merged = new _orderedElements2['default']();\n\n  for (var i = 0; i < styleTypes.length; i++) {\n    merged.addStyleType(styleTypes[i]);\n  }\n\n  var plainDeclarations = new _orderedElements2['default']();\n  var generatedStyles = \"\"; // TODO(emily): benchmark this to see if a plain for loop would be faster.\n\n  merged.forEach(function (val, key) {\n    // For each key, see if one of the selector handlers will handle these\n    // styles.\n    var foundHandler = selectorHandlers.some(function (handler) {\n      var result = handler(key, selector, function (newSelector) {\n        return generateCSS(newSelector, [val], selectorHandlers, stringHandlers, useImportant);\n      });\n\n      if (result != null) {\n        // If the handler returned something, add it to the generated\n        // CSS and stop looking for another handler.\n        generatedStyles += result;\n        return true;\n      }\n    }); // If none of the handlers handled it, add it to the list of plain\n    // style declarations.\n\n    if (!foundHandler) {\n      plainDeclarations.set(key, val, true);\n    }\n  });\n  return generateCSSRuleset(selector, plainDeclarations, stringHandlers, useImportant, selectorHandlers) + generatedStyles;\n};\n\nexports.generateCSS = generateCSS;\n/**\n * Helper method of generateCSSRuleset to facilitate custom handling of certain\n * CSS properties. Used for e.g. font families.\n *\n * See generateCSSRuleset for usage and documentation of paramater types.\n */\n\nvar runStringHandlers = function runStringHandlers(declarations,\n/* : OrderedElements */\nstringHandlers,\n/* : StringHandlers */\nselectorHandlers\n/* : SelectorHandler[] */\n)\n/* : void */\n{\n  if (!stringHandlers) {\n    return;\n  }\n\n  var stringHandlerKeys = Object.keys(stringHandlers);\n\n  for (var i = 0; i < stringHandlerKeys.length; i++) {\n    var key = stringHandlerKeys[i];\n\n    if (declarations.has(key)) {\n      // A declaration exists for this particular string handler, so we\n      // need to let the string handler interpret the declaration first\n      // before proceeding.\n      //\n      // TODO(emily): Pass in a callback which generates CSS, similar to\n      // how our selector handlers work, instead of passing in\n      // `selectorHandlers` and have them make calls to `generateCSS`\n      // themselves. Right now, this is impractical because our string\n      // handlers are very specialized and do complex things.\n      declarations.set(key, stringHandlers[key](declarations.get(key), selectorHandlers), // Preserve order here, since we are really replacing an\n      // unprocessed style with a processed style, not overriding an\n      // earlier style\n      false);\n    }\n  }\n};\n\nvar transformRule = function transformRule(key,\n/* : string */\nvalue,\n/* : string */\ntransformValue\n/* : function */\n) {\n  return (\n    /* : string */\n    (0, _util.kebabifyStyleName)(key) + ':' + transformValue(key, value) + ';'\n  );\n};\n/**\n * Generate a CSS ruleset with the selector and containing the declarations.\n *\n * This function assumes that the given declarations don't contain any special\n * children (such as media queries, pseudo-selectors, or descendant styles).\n *\n * Note that this method does not deal with nesting used for e.g.\n * psuedo-selectors or media queries. That responsibility is left to  the\n * `generateCSS` function.\n *\n * @param {string} selector: the selector associated with the ruleset\n * @param {Object} declarations: a map from camelCased CSS property name to CSS\n *     property value.\n * @param {Object.<string, function>} stringHandlers: a map from camelCased CSS\n *     property name to a function which will map the given value to the value\n *     that is output.\n * @param {bool} useImportant: A boolean saying whether to append \"!important\"\n *     to each of the CSS declarations.\n * @returns {string} A string of raw CSS.\n *\n * Examples:\n *\n *    generateCSSRuleset(\".blah\", { color: \"red\" })\n *    -> \".blah{color: red !important;}\"\n *    generateCSSRuleset(\".blah\", { color: \"red\" }, {}, false)\n *    -> \".blah{color: red}\"\n *    generateCSSRuleset(\".blah\", { color: \"red\" }, {color: c => c.toUpperCase})\n *    -> \".blah{color: RED}\"\n *    generateCSSRuleset(\".blah:hover\", { color: \"red\" })\n *    -> \".blah:hover{color: red}\"\n */\n\n\nvar generateCSSRuleset = function generateCSSRuleset(selector,\n/* : string */\ndeclarations,\n/* : OrderedElements */\nstringHandlers,\n/* : StringHandlers */\nuseImportant,\n/* : boolean */\nselectorHandlers\n/* : SelectorHandler[] */\n)\n/* : string */\n{\n  // Mutates declarations\n  runStringHandlers(declarations, stringHandlers, selectorHandlers);\n\n  var originalElements = _extends({}, declarations.elements); // NOTE(emily): This mutates handledDeclarations.elements.\n\n\n  var prefixedElements = prefixAll(declarations.elements);\n  var elementNames = Object.keys(prefixedElements);\n\n  if (elementNames.length !== declarations.keyOrder.length) {\n    // There are some prefixed values, so we need to figure out how to sort\n    // them.\n    //\n    // Loop through prefixedElements, looking for anything that is not in\n    // sortOrder, which means it was added by prefixAll. This means that we\n    // need to figure out where it should appear in the sortOrder.\n    for (var i = 0; i < elementNames.length; i++) {\n      if (!originalElements.hasOwnProperty(elementNames[i])) {\n        // This element is not in the sortOrder, which means it is a prefixed\n        // value that was added by prefixAll. Let's try to figure out where it\n        // goes.\n        var originalStyle = undefined;\n\n        if (elementNames[i][0] === 'W') {\n          // This is a Webkit-prefixed style, like \"WebkitTransition\". Let's\n          // find its original style's sort order.\n          originalStyle = elementNames[i][6].toLowerCase() + elementNames[i].slice(7);\n        } else if (elementNames[i][1] === 'o') {\n          // This is a Moz-prefixed style, like \"MozTransition\". We check\n          // the second character to avoid colliding with Ms-prefixed\n          // styles. Let's find its original style's sort order.\n          originalStyle = elementNames[i][3].toLowerCase() + elementNames[i].slice(4);\n        } else {\n          // if (elementNames[i][1] === 's') {\n          // This is a Ms-prefixed style, like \"MsTransition\".\n          originalStyle = elementNames[i][2].toLowerCase() + elementNames[i].slice(3);\n        }\n\n        if (originalStyle && originalElements.hasOwnProperty(originalStyle)) {\n          var originalIndex = declarations.keyOrder.indexOf(originalStyle);\n          declarations.keyOrder.splice(originalIndex, 0, elementNames[i]);\n        } else {\n          // We don't know what the original style was, so sort it to\n          // top. This can happen for styles that are added that don't\n          // have the same base name as the original style.\n          declarations.keyOrder.unshift(elementNames[i]);\n        }\n      }\n    }\n  }\n\n  var transformValue = useImportant === false ? _util.stringifyValue : _util.stringifyAndImportantifyValue;\n  var rules = [];\n\n  for (var i = 0; i < declarations.keyOrder.length; i++) {\n    var key = declarations.keyOrder[i];\n    var value = prefixedElements[key];\n\n    if (Array.isArray(value)) {\n      // inline-style-prefixer returns an array when there should be\n      // multiple rules for the same key. Here we flatten to multiple\n      // pairs with the same key.\n      for (var j = 0; j < value.length; j++) {\n        rules.push(transformRule(key, value[j], transformValue));\n      }\n    } else {\n      rules.push(transformRule(key, value, transformValue));\n    }\n  }\n\n  if (rules.length) {\n    return selector + '{' + rules.join(\"\") + '}';\n  } else {\n    return \"\";\n  }\n};\n\nexports.generateCSSRuleset = generateCSSRuleset;","map":{"version":3,"sources":["/Users/justinf/perseus-configured/node_modules/aphrodite/lib/generate.js"],"names":["Object","defineProperty","exports","value","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_interopRequireDefault","obj","__esModule","_inlineStylePrefixerStaticCreatePrefixer","require","_inlineStylePrefixerStaticCreatePrefixer2","_libStaticPrefixData","_libStaticPrefixData2","_orderedElements","_orderedElements2","_util","prefixAll","defaultSelectorHandlers","pseudoSelectors","selector","baseSelector","generateSubtreeStyles","mediaQueries","generated","generateCSS","styleTypes","selectorHandlers","stringHandlers","useImportant","merged","addStyleType","plainDeclarations","generatedStyles","forEach","val","foundHandler","some","handler","result","newSelector","set","generateCSSRuleset","runStringHandlers","declarations","stringHandlerKeys","keys","has","get","transformRule","transformValue","kebabifyStyleName","originalElements","elements","prefixedElements","elementNames","keyOrder","originalStyle","undefined","toLowerCase","slice","originalIndex","indexOf","splice","unshift","stringifyValue","stringifyAndImportantifyValue","rules","Array","isArray","j","push","join"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AACzCC,EAAAA,KAAK,EAAE;AADkC,CAA7C;;AAIA,IAAIC,QAAQ,GAAGJ,MAAM,CAACK,MAAP,IAAiB,UAAUC,MAAV,EAAkB;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAAE,QAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAtB;;AAA2B,SAAK,IAAII,GAAT,IAAgBD,MAAhB,EAAwB;AAAE,UAAIV,MAAM,CAACY,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCJ,MAArC,EAA6CC,GAA7C,CAAJ,EAAuD;AAAEL,QAAAA,MAAM,CAACK,GAAD,CAAN,GAAcD,MAAM,CAACC,GAAD,CAApB;AAA4B;AAAE;AAAE;;AAAC,SAAOL,MAAP;AAAgB,CAAhQ;;AAEA,SAASS,sBAAT,CAAgCC,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAAE,eAAWA;AAAb,GAArC;AAA0D;;AAEjG,IAAIE,wCAAwC,GAAGC,OAAO,CAAC,6CAAD,CAAtD;;AAEA,IAAIC,yCAAyC,GAAGL,sBAAsB,CAACG,wCAAD,CAAtE;;AAEA,IAAIG,oBAAoB,GAAGF,OAAO,CAAC,yBAAD,CAAlC;;AAEA,IAAIG,qBAAqB,GAAGP,sBAAsB,CAACM,oBAAD,CAAlD;;AAEA,IAAIE,gBAAgB,GAAGJ,OAAO,CAAC,oBAAD,CAA9B;;AAEA,IAAIK,iBAAiB,GAAGT,sBAAsB,CAACQ,gBAAD,CAA9C;;AAEA,IAAIE,KAAK,GAAGN,OAAO,CAAC,QAAD,CAAnB;;AAEA,IAAIO,SAAS,GAAG,CAAC,GAAGN,yCAAyC,CAAC,SAAD,CAA7C,EAA0DE,qBAAqB,CAAC,SAAD,CAA/E,CAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIK,uBAAuB,GAAG,CAC9B;AACA,SAASC,eAAT,CAAyBC,QAAzB;AAAmC;AACnCC,YADA;AACc;AACdC;AAAsB;AAFtB;AAGE;AAAK;AACH,MAAIF,QAAQ,CAAC,CAAD,CAAR,KAAgB,GAApB,EAAyB;AACrB,WAAO,IAAP;AACH;;AACD,SAAOE,qBAAqB,CAACD,YAAY,GAAGD,QAAhB,CAA5B;AACH,CAV6B,EAY9B;AACA,SAASG,YAAT,CAAsBH,QAAtB;AAAgC;AAChCC,YADA;AACc;AACdC;AAAsB;AAFtB;AAGE;AAAK;AACH,MAAIF,QAAQ,CAAC,CAAD,CAAR,KAAgB,GAApB,EAAyB;AACrB,WAAO,IAAP;AACH,GAHE,CAIH;;;AACA,MAAII,SAAS,GAAGF,qBAAqB,CAACD,YAAD,CAArC;AACA,SAAOD,QAAQ,GAAG,GAAX,GAAiBI,SAAjB,GAA6B,GAApC;AACH,CAvB6B,CAA9B;AAyBA/B,OAAO,CAACyB,uBAAR,GAAkCA,uBAAlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIO,WAAW,GAAG,SAASA,WAAT,CAAqBL,QAArB;AAA+B;AACjDM,UADkB;AACN;AACZC,gBAFkB;AAEA;AAClBC,cAHkB;AAGF;AAChBC;AAAa;AAJK;AAKhB;AAAc;AACZ,MAAIC,MAAM,GAAG,IAAIf,iBAAiB,CAAC,SAAD,CAArB,EAAb;;AAEA,OAAK,IAAIjB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4B,UAAU,CAAC1B,M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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n    value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _inlineStylePrefixerStaticCreatePrefixer = require('inline-style-prefixer/static/createPrefixer');\n\nvar _inlineStylePrefixerStaticCreatePrefixer2 = _interopRequireDefault(_inlineStylePrefixerStaticCreatePrefixer);\n\nvar _libStaticPrefixData = require('../lib/staticPrefixData');\n\nvar _libStaticPrefixData2 = _interopRequireDefault(_libStaticPrefixData);\n\nvar _orderedElements = require('./ordered-elements');\n\nvar _orderedElements2 = _interopRequireDefault(_orderedElements);\n\nvar _util = require('./util');\n\nvar prefixAll = (0, _inlineStylePrefixerStaticCreatePrefixer2['default'])(_libStaticPrefixData2['default']);\n\n/* ::\nimport type { SheetDefinition } from './index.js';\ntype StringHandlers = { [id:string]: Function };\ntype SelectorCallback = (selector: string) => any;\nexport type SelectorHandler = (\n    selector: string,\n    baseSelector: string,\n    callback: SelectorCallback\n) => string | null;\n*/\n\n/**\n * `selectorHandlers` are functions which handle special selectors which act\n * differently than normal style definitions. These functions look at the\n * current selector and can generate CSS for the styles in their subtree by\n * calling the callback with a new selector.\n *\n * For example, when generating styles with a base selector of '.foo' and the\n * following styles object:\n *\n *   {\n *     ':nth-child(2n)': {\n *       ':hover': {\n *         color: 'red'\n *       }\n *     }\n *   }\n *\n * when we reach the ':hover' style, we would call our selector handlers like\n *\n *   handler(':hover', '.foo:nth-child(2n)', callback)\n *\n * Since our `pseudoSelectors` handles ':hover' styles, that handler would call\n * the callback like\n *\n *   callback('.foo:nth-child(2n):hover')\n *\n * to generate its subtree `{ color: 'red' }` styles with a\n * '.foo:nth-child(2n):hover' selector. The callback would return CSS like\n *\n *   '.foo:nth-child(2n):hover{color:red !important;}'\n *\n * and the handler would then return that resulting CSS.\n *\n * `defaultSelectorHandlers` is the list of default handlers used in a call to\n * `generateCSS`.\n *\n * @name SelectorHandler\n * @function\n * @param {string} selector: The currently inspected selector. ':hover' in the\n *     example above.\n * @param {string} baseSelector: The selector of the parent styles.\n *     '.foo:nth-child(2n)' in the example above.\n * @param {function} generateSubtreeStyles: A function which can be called to\n *     generate CSS for the subtree of styles corresponding to the selector.\n *     Accepts a new baseSelector to use for generating those styles.\n * @returns {?string} The generated CSS for this selector, or null if we don't\n *     handle this selector.\n */\nvar defaultSelectorHandlers = [\n// Handle pseudo-selectors, like :hover and :nth-child(3n)\nfunction pseudoSelectors(selector, /* : string */\nbaseSelector, /* : string */\ngenerateSubtreeStyles /* : Function */\n) /* */{\n    if (selector[0] !== \":\") {\n        return null;\n    }\n    return generateSubtreeStyles(baseSelector + selector);\n},\n\n// Handle media queries (or font-faces)\nfunction mediaQueries(selector, /* : string */\nbaseSelector, /* : string */\ngenerateSubtreeStyles /* : Function */\n) /* */{\n    if (selector[0] !== \"@\") {\n        return null;\n    }\n    // Generate the styles normally, and then wrap them in the media query.\n    var generated = generateSubtreeStyles(baseSelector);\n    return selector + '{' + generated + '}';\n}];\n\nexports.defaultSelectorHandlers = defaultSelectorHandlers;\n/**\n * Generate CSS for a selector and some styles.\n *\n * This function handles the media queries and pseudo selectors that can be used\n * in aphrodite styles.\n *\n * @param {string} selector: A base CSS selector for the styles to be generated\n *     with.\n * @param {Object} styleTypes: A list of properties of the return type of\n *     StyleSheet.create, e.g. [styles.red, styles.blue].\n * @param {Array.<SelectorHandler>} selectorHandlers: A list of selector\n *     handlers to use for handling special selectors. See\n *     `defaultSelectorHandlers`.\n * @param stringHandlers: See `generateCSSRuleset`\n * @param useImportant: See `generateCSSRuleset`\n *\n * To actually generate the CSS special-construct-less styles are passed to\n * `generateCSSRuleset`.\n *\n * For instance, a call to\n *\n *     generateCSS(\".foo\", [{\n *       color: \"red\",\n *       \"@media screen\": {\n *         height: 20,\n *         \":hover\": {\n *           backgroundColor: \"black\"\n *         }\n *       },\n *       \":active\": {\n *         fontWeight: \"bold\"\n *       }\n *     }], defaultSelectorHandlers);\n *\n * with the default `selectorHandlers` will make 5 calls to\n * `generateCSSRuleset`:\n *\n *     generateCSSRuleset(\".foo\", { color: \"red\" }, ...)\n *     generateCSSRuleset(\".foo:active\", { fontWeight: \"bold\" }, ...)\n *     // These 2 will be wrapped in @media screen {}\n *     generateCSSRuleset(\".foo\", { height: 20 }, ...)\n *     generateCSSRuleset(\".foo:hover\", { backgroundColor: \"black\" }, ...)\n */\nvar generateCSS = function generateCSS(selector, /* : string */\nstyleTypes, /* : SheetDefinition[] */\nselectorHandlers, /* : SelectorHandler[] */\nstringHandlers, /* : StringHandlers */\nuseImportant /* : boolean */\n) /* : string */{\n    var merged = new _orderedElements2['default']();\n\n    for (var i = 0; i < styleTypes.length; i++) {\n        merged.addStyleType(styleTypes[i]);\n    }\n\n    var plainDeclarations = new _orderedElements2['default']();\n    var generatedStyles = \"\";\n\n    // TODO(emily): benchmark this to see if a plain for loop would be faster.\n    merged.forEach(function (val, key) {\n        // For each key, see if one of the selector handlers will handle these\n        // styles.\n        var foundHandler = selectorHandlers.some(function (handler) {\n            var result = handler(key, selector, function (newSelector) {\n                return generateCSS(newSelector, [val], selectorHandlers, stringHandlers, useImportant);\n            });\n            if (result != null) {\n                // If the handler returned something, add it to the generated\n                // CSS and stop looking for another handler.\n                generatedStyles += result;\n                return true;\n            }\n        });\n        // If none of the handlers handled it, add it to the list of plain\n        // style declarations.\n        if (!foundHandler) {\n            plainDeclarations.set(key, val, true);\n        }\n    });\n\n    return generateCSSRuleset(selector, plainDeclarations, stringHandlers, useImportant, selectorHandlers) + generatedStyles;\n};\n\nexports.generateCSS = generateCSS;\n/**\n * Helper method of generateCSSRuleset to facilitate custom handling of certain\n * CSS properties. Used for e.g. font families.\n *\n * See generateCSSRuleset for usage and documentation of paramater types.\n */\nvar runStringHandlers = function runStringHandlers(declarations, /* : OrderedElements */\nstringHandlers, /* : StringHandlers */\nselectorHandlers /* : SelectorHandler[] */\n) /* : void */{\n    if (!stringHandlers) {\n        return;\n    }\n\n    var stringHandlerKeys = Object.keys(stringHandlers);\n    for (var i = 0; i < stringHandlerKeys.length; i++) {\n        var key = stringHandlerKeys[i];\n        if (declarations.has(key)) {\n            // A declaration exists for this particular string handler, so we\n            // need to let the string handler interpret the declaration first\n            // before proceeding.\n            //\n            // TODO(emily): Pass in a callback which generates CSS, similar to\n            // how our selector handlers work, instead of passing in\n            // `selectorHandlers` and have them make calls to `generateCSS`\n            // themselves. Right now, this is impractical because our string\n            // handlers are very specialized and do complex things.\n            declarations.set(key, stringHandlers[key](declarations.get(key), selectorHandlers),\n\n            // Preserve order here, since we are really replacing an\n            // unprocessed style with a processed style, not overriding an\n            // earlier style\n            false);\n        }\n    }\n};\n\nvar transformRule = function transformRule(key, /* : string */\nvalue, /* : string */\ntransformValue /* : function */\n) {\n    return (/* : string */(0, _util.kebabifyStyleName)(key) + ':' + transformValue(key, value) + ';'\n    );\n};\n\n/**\n * Generate a CSS ruleset with the selector and containing the declarations.\n *\n * This function assumes that the given declarations don't contain any special\n * children (such as media queries, pseudo-selectors, or descendant styles).\n *\n * Note that this method does not deal with nesting used for e.g.\n * psuedo-selectors or media queries. That responsibility is left to  the\n * `generateCSS` function.\n *\n * @param {string} selector: the selector associated with the ruleset\n * @param {Object} declarations: a map from camelCased CSS property name to CSS\n *     property value.\n * @param {Object.<string, function>} stringHandlers: a map from camelCased CSS\n *     property name to a function which will map the given value to the value\n *     that is output.\n * @param {bool} useImportant: A boolean saying whether to append \"!important\"\n *     to each of the CSS declarations.\n * @returns {string} A string of raw CSS.\n *\n * Examples:\n *\n *    generateCSSRuleset(\".blah\", { color: \"red\" })\n *    -> \".blah{color: red !important;}\"\n *    generateCSSRuleset(\".blah\", { color: \"red\" }, {}, false)\n *    -> \".blah{color: red}\"\n *    generateCSSRuleset(\".blah\", { color: \"red\" }, {color: c => c.toUpperCase})\n *    -> \".blah{color: RED}\"\n *    generateCSSRuleset(\".blah:hover\", { color: \"red\" })\n *    -> \".blah:hover{color: red}\"\n */\nvar generateCSSRuleset = function generateCSSRuleset(selector, /* : string */\ndeclarations, /* : OrderedElements */\nstringHandlers, /* : StringHandlers */\nuseImportant, /* : boolean */\nselectorHandlers /* : SelectorHandler[] */\n) /* : string */{\n    // Mutates declarations\n    runStringHandlers(declarations, stringHandlers, selectorHandlers);\n\n    var originalElements = _extends({}, declarations.elements);\n\n    // NOTE(emily): This mutates handledDeclarations.elements.\n    var prefixedElements = prefixAll(declarations.elements);\n\n    var elementNames = Object.keys(prefixedElements);\n    if (elementNames.length !== declarations.keyOrder.length) {\n        // There are some prefixed values, so we need to figure out how to sort\n        // them.\n        //\n        // Loop through prefixedElements, looking for anything that is not in\n        // sortOrder, which means it was added by prefixAll. This means that we\n        // need to figure out where it should appear in the sortOrder.\n        for (var i = 0; i < elementNames.length; i++) {\n            if (!originalElements.hasOwnProperty(elementNames[i])) {\n                // This element is not in the sortOrder, which means it is a prefixed\n                // value that was added by prefixAll. Let's try to figure out where it\n                // goes.\n                var originalStyle = undefined;\n                if (elementNames[i][0] === 'W') {\n                    // This is a Webkit-prefixed style, like \"WebkitTransition\". Let's\n                    // find its original style's sort order.\n                    originalStyle = elementNames[i][6].toLowerCase() + elementNames[i].slice(7);\n                } else if (elementNames[i][1] === 'o') {\n                    // This is a Moz-prefixed style, like \"MozTransition\". We check\n                    // the second character to avoid colliding with Ms-prefixed\n                    // styles. Let's find its original style's sort order.\n                    originalStyle = elementNames[i][3].toLowerCase() + elementNames[i].slice(4);\n                } else {\n                    // if (elementNames[i][1] === 's') {\n                    // This is a Ms-prefixed style, like \"MsTransition\".\n                    originalStyle = elementNames[i][2].toLowerCase() + elementNames[i].slice(3);\n                }\n\n                if (originalStyle && originalElements.hasOwnProperty(originalStyle)) {\n                    var originalIndex = declarations.keyOrder.indexOf(originalStyle);\n                    declarations.keyOrder.splice(originalIndex, 0, elementNames[i]);\n                } else {\n                    // We don't know what the original style was, so sort it to\n                    // top. This can happen for styles that are added that don't\n                    // have the same base name as the original style.\n                    declarations.keyOrder.unshift(elementNames[i]);\n                }\n            }\n        }\n    }\n\n    var transformValue = useImportant === false ? _util.stringifyValue : _util.stringifyAndImportantifyValue;\n\n    var rules = [];\n    for (var i = 0; i < declarations.keyOrder.length; i++) {\n        var key = declarations.keyOrder[i];\n        var value = prefixedElements[key];\n        if (Array.isArray(value)) {\n            // inline-style-prefixer returns an array when there should be\n            // multiple rules for the same key. Here we flatten to multiple\n            // pairs with the same key.\n            for (var j = 0; j < value.length; j++) {\n                rules.push(transformRule(key, value[j], transformValue));\n            }\n        } else {\n            rules.push(transformRule(key, value, transformValue));\n        }\n    }\n\n    if (rules.length) {\n        return selector + '{' + rules.join(\"\") + '}';\n    } else {\n        return \"\";\n    }\n};\nexports.generateCSSRuleset = generateCSSRuleset;"]},"metadata":{},"sourceType":"script"}